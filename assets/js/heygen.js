var Vt = Object.defineProperty;
var Rt = (B) => {
  throw TypeError(B);
};
var $t = (B, U, F) =>
  U in B
    ? Vt(B, U, { enumerable: !0, configurable: !0, writable: !0, value: F })
    : (B[U] = F);
var xe = (B, U, F) => $t(B, typeof U != "symbol" ? U + "" : U, F),
  Pt = (B, U, F) => U.has(B) || Rt("Cannot " + F);
var _e = (B, U, F) => (
    Pt(B, U, "read from private field"), F ? F.call(B) : U.get(B)
  ),
  Ae = (B, U, F) =>
    U.has(B)
      ? Rt("Cannot add the same private member more than once")
      : U instanceof WeakSet
      ? U.add(B)
      : U.set(B, F),
  De = (B, U, F, q) => (
    Pt(B, U, "write to private field"), q ? q.call(B, F) : U.set(B, F), F
  );
function _mergeNamespaces(B, U) {
  for (var F = 0; F < U.length; F++) {
    const q = U[F];
    if (typeof q != "string" && !Array.isArray(q)) {
      for (const j in q)
        if (j !== "default" && !(j in B)) {
          const V = Object.getOwnPropertyDescriptor(q, j);
          V &&
            Object.defineProperty(
              B,
              j,
              V.get ? V : { enumerable: !0, get: () => q[j] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(B, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const U = document.createElement("link").relList;
  if (U && U.supports && U.supports("modulepreload")) return;
  for (const j of document.querySelectorAll('link[rel="modulepreload"]')) q(j);
  new MutationObserver((j) => {
    for (const V of j)
      if (V.type === "childList")
        for (const $ of V.addedNodes)
          $.tagName === "LINK" && $.rel === "modulepreload" && q($);
  }).observe(document, { childList: !0, subtree: !0 });
  function F(j) {
    const V = {};
    return (
      j.integrity && (V.integrity = j.integrity),
      j.referrerPolicy && (V.referrerPolicy = j.referrerPolicy),
      j.crossOrigin === "use-credentials"
        ? (V.credentials = "include")
        : j.crossOrigin === "anonymous"
        ? (V.credentials = "omit")
        : (V.credentials = "same-origin"),
      V
    );
  }
  function q(j) {
    if (j.ep) return;
    j.ep = !0;
    const V = F(j);
    fetch(j.href, V);
  }
})();
var define_process_env_default$1 = {};
function _mergeNamespaces$1(B, U) {
  return (
    U.forEach(function (F) {
      F &&
        typeof F != "string" &&
        !Array.isArray(F) &&
        Object.keys(F).forEach(function (q) {
          if (q !== "default" && !(q in B)) {
            var j = Object.getOwnPropertyDescriptor(F, q);
            Object.defineProperty(
              B,
              q,
              j.get
                ? j
                : {
                    enumerable: !0,
                    get: function () {
                      return F[q];
                    },
                  }
            );
          }
        });
    }),
    Object.freeze(B)
  );
}
var e$1 = Object.defineProperty,
  h$1 = (B, U, F) =>
    U in B
      ? e$1(B, U, { enumerable: !0, configurable: !0, writable: !0, value: F })
      : (B[U] = F),
  o$1 = (B, U, F) => h$1(B, typeof U != "symbol" ? U + "" : U, F);
let _$1 = class {
  constructor() {
    o$1(this, "_locking"),
      o$1(this, "_locks"),
      (this._locking = Promise.resolve()),
      (this._locks = 0);
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let U;
    const F = new Promise(
        (j) =>
          (U = () => {
            (this._locks -= 1), j();
          })
      ),
      q = this._locking.then(() => U);
    return (this._locking = this._locking.then(() => F)), q;
  }
};
function assert(B, U) {
  if (!B) throw new Error(U);
}
const FLOAT32_MAX = 34028234663852886e22,
  FLOAT32_MIN = -34028234663852886e22,
  UINT32_MAX = 4294967295,
  INT32_MAX = 2147483647,
  INT32_MIN = -2147483648;
function assertInt32(B) {
  if (typeof B != "number") throw new Error("invalid int 32: " + typeof B);
  if (!Number.isInteger(B) || B > INT32_MAX || B < INT32_MIN)
    throw new Error("invalid int 32: " + B);
}
function assertUInt32(B) {
  if (typeof B != "number") throw new Error("invalid uint 32: " + typeof B);
  if (!Number.isInteger(B) || B > UINT32_MAX || B < 0)
    throw new Error("invalid uint 32: " + B);
}
function assertFloat32(B) {
  if (typeof B != "number") throw new Error("invalid float 32: " + typeof B);
  if (Number.isFinite(B) && (B > FLOAT32_MAX || B < FLOAT32_MIN))
    throw new Error("invalid float 32: " + B);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(B) {
  const U = B[enumTypeSymbol];
  return assert(U, "missing enum type on enum object"), U;
}
function setEnumType(B, U, F, q) {
  B[enumTypeSymbol] = makeEnumType(
    U,
    F.map((j) => ({ no: j.no, name: j.name, localName: B[j.no] }))
  );
}
function makeEnumType(B, U, F) {
  const q = Object.create(null),
    j = Object.create(null),
    V = [];
  for (const $ of U) {
    const W = normalizeEnumValue($);
    V.push(W), (q[$.name] = W), (j[$.no] = W);
  }
  return {
    typeName: B,
    values: V,
    findName($) {
      return q[$];
    },
    findNumber($) {
      return j[$];
    },
  };
}
function makeEnum(B, U, F) {
  const q = {};
  for (const j of U) {
    const V = normalizeEnumValue(j);
    (q[V.localName] = V.no), (q[V.no] = V.localName);
  }
  return setEnumType(q, B, U), q;
}
function normalizeEnumValue(B) {
  return "localName" in B
    ? B
    : Object.assign(Object.assign({}, B), { localName: B.name });
}
class Message {
  equals(U) {
    return this.getType().runtime.util.equals(this.getType(), this, U);
  }
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  fromBinary(U, F) {
    const q = this.getType(),
      j = q.runtime.bin,
      V = j.makeReadOptions(F);
    return j.readMessage(this, V.readerFactory(U), U.byteLength, V), this;
  }
  fromJson(U, F) {
    const q = this.getType(),
      j = q.runtime.json,
      V = j.makeReadOptions(F);
    return j.readMessage(q, U, V, this), this;
  }
  fromJsonString(U, F) {
    let q;
    try {
      q = JSON.parse(U);
    } catch (j) {
      throw new Error(
        "cannot decode "
          .concat(this.getType().typeName, " from JSON: ")
          .concat(j instanceof Error ? j.message : String(j))
      );
    }
    return this.fromJson(q, F);
  }
  toBinary(U) {
    const F = this.getType(),
      q = F.runtime.bin,
      j = q.makeWriteOptions(U),
      V = j.writerFactory();
    return q.writeMessage(this, V, j), V.finish();
  }
  toJson(U) {
    const F = this.getType(),
      q = F.runtime.json,
      j = q.makeWriteOptions(U);
    return q.writeMessage(this, j);
  }
  toJsonString(U) {
    var F;
    const q = this.toJson(U);
    return JSON.stringify(
      q,
      null,
      (F = U == null ? void 0 : U.prettySpaces) !== null && F !== void 0 ? F : 0
    );
  }
  toJSON() {
    return this.toJson({ emitDefaultValues: !0 });
  }
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(B, U, F, q) {
  var j;
  const V =
      (j = q == null ? void 0 : q.localName) !== null && j !== void 0
        ? j
        : U.substring(U.lastIndexOf(".") + 1),
    $ = {
      [V]: function (W) {
        B.util.initFields(this), B.util.initPartial(W, this);
      },
    }[V];
  return (
    Object.setPrototypeOf($.prototype, new Message()),
    Object.assign($, {
      runtime: B,
      typeName: U,
      fields: B.util.newFieldList(F),
      fromBinary(W, K) {
        return new $().fromBinary(W, K);
      },
      fromJson(W, K) {
        return new $().fromJson(W, K);
      },
      fromJsonString(W, K) {
        return new $().fromJsonString(W, K);
      },
      equals(W, K) {
        return B.util.equals($, W, K);
      },
    }),
    $
  );
}
function varint64read() {
  let B = 0,
    U = 0;
  for (let q = 0; q < 28; q += 7) {
    let j = this.buf[this.pos++];
    if (((B |= (j & 127) << q), (j & 128) == 0))
      return this.assertBounds(), [B, U];
  }
  let F = this.buf[this.pos++];
  if (((B |= (F & 15) << 28), (U = (F & 112) >> 4), (F & 128) == 0))
    return this.assertBounds(), [B, U];
  for (let q = 3; q <= 31; q += 7) {
    let j = this.buf[this.pos++];
    if (((U |= (j & 127) << q), (j & 128) == 0))
      return this.assertBounds(), [B, U];
  }
  throw new Error("invalid varint");
}
function varint64write(B, U, F) {
  for (let V = 0; V < 28; V = V + 7) {
    const $ = B >>> V,
      W = !(!($ >>> 7) && U == 0),
      K = (W ? $ | 128 : $) & 255;
    if ((F.push(K), !W)) return;
  }
  const q = ((B >>> 28) & 15) | ((U & 7) << 4),
    j = U >> 3 != 0;
  if ((F.push((j ? q | 128 : q) & 255), !!j)) {
    for (let V = 3; V < 31; V = V + 7) {
      const $ = U >>> V,
        W = !!($ >>> 7),
        K = (W ? $ | 128 : $) & 255;
      if ((F.push(K), !W)) return;
    }
    F.push((U >>> 31) & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(B) {
  const U = B[0] === "-";
  U && (B = B.slice(1));
  const F = 1e6;
  let q = 0,
    j = 0;
  function V($, W) {
    const K = Number(B.slice($, W));
    (j *= F),
      (q = q * F + K),
      q >= TWO_PWR_32_DBL &&
        ((j = j + ((q / TWO_PWR_32_DBL) | 0)), (q = q % TWO_PWR_32_DBL));
  }
  return (
    V(-24, -18),
    V(-18, -12),
    V(-12, -6),
    V(-6),
    U ? negate(q, j) : newBits(q, j)
  );
}
function int64ToString(B, U) {
  let F = newBits(B, U);
  const q = F.hi & 2147483648;
  q && (F = negate(F.lo, F.hi));
  const j = uInt64ToString(F.lo, F.hi);
  return q ? "-" + j : j;
}
function uInt64ToString(B, U) {
  if ((({ lo: B, hi: U } = toUnsigned(B, U)), U <= 2097151))
    return String(TWO_PWR_32_DBL * U + B);
  const F = B & 16777215,
    q = ((B >>> 24) | (U << 8)) & 16777215,
    j = (U >> 16) & 65535;
  let V = F + q * 6777216 + j * 6710656,
    $ = q + j * 8147497,
    W = j * 2;
  const K = 1e7;
  return (
    V >= K && (($ += Math.floor(V / K)), (V %= K)),
    $ >= K && ((W += Math.floor($ / K)), ($ %= K)),
    W.toString() +
      decimalFrom1e7WithLeadingZeros($) +
      decimalFrom1e7WithLeadingZeros(V)
  );
}
function toUnsigned(B, U) {
  return { lo: B >>> 0, hi: U >>> 0 };
}
function newBits(B, U) {
  return { lo: B | 0, hi: U | 0 };
}
function negate(B, U) {
  return (U = ~U), B ? (B = ~B + 1) : (U += 1), newBits(B, U);
}
const decimalFrom1e7WithLeadingZeros = (B) => {
  const U = String(B);
  return "0000000".slice(U.length) + U;
};
function varint32write(B, U) {
  if (B >= 0) {
    for (; B > 127; ) U.push((B & 127) | 128), (B = B >>> 7);
    U.push(B);
  } else {
    for (let F = 0; F < 9; F++) U.push((B & 127) | 128), (B = B >> 7);
    U.push(1);
  }
}
function varint32read() {
  let B = this.buf[this.pos++],
    U = B & 127;
  if ((B & 128) == 0) return this.assertBounds(), U;
  if (((B = this.buf[this.pos++]), (U |= (B & 127) << 7), (B & 128) == 0))
    return this.assertBounds(), U;
  if (((B = this.buf[this.pos++]), (U |= (B & 127) << 14), (B & 128) == 0))
    return this.assertBounds(), U;
  if (((B = this.buf[this.pos++]), (U |= (B & 127) << 21), (B & 128) == 0))
    return this.assertBounds(), U;
  (B = this.buf[this.pos++]), (U |= (B & 15) << 28);
  for (let F = 5; (B & 128) !== 0 && F < 10; F++) B = this.buf[this.pos++];
  if ((B & 128) != 0) throw new Error("invalid varint");
  return this.assertBounds(), U >>> 0;
}
function makeInt64Support() {
  const B = new DataView(new ArrayBuffer(8));
  if (
    typeof BigInt == "function" &&
    typeof B.getBigInt64 == "function" &&
    typeof B.getBigUint64 == "function" &&
    typeof B.setBigInt64 == "function" &&
    typeof B.setBigUint64 == "function" &&
    (typeof process != "object" ||
      typeof define_process_env_default$1 != "object" ||
      define_process_env_default$1.BUF_BIGINT_DISABLE !== "1")
  ) {
    const j = BigInt("-9223372036854775808"),
      V = BigInt("9223372036854775807"),
      $ = BigInt("0"),
      W = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(K) {
        const G = typeof K == "bigint" ? K : BigInt(K);
        if (G > V || G < j) throw new Error("int64 invalid: ".concat(K));
        return G;
      },
      uParse(K) {
        const G = typeof K == "bigint" ? K : BigInt(K);
        if (G > W || G < $) throw new Error("uint64 invalid: ".concat(K));
        return G;
      },
      enc(K) {
        return (
          B.setBigInt64(0, this.parse(K), !0),
          { lo: B.getInt32(0, !0), hi: B.getInt32(4, !0) }
        );
      },
      uEnc(K) {
        return (
          B.setBigInt64(0, this.uParse(K), !0),
          { lo: B.getInt32(0, !0), hi: B.getInt32(4, !0) }
        );
      },
      dec(K, G) {
        return B.setInt32(0, K, !0), B.setInt32(4, G, !0), B.getBigInt64(0, !0);
      },
      uDec(K, G) {
        return (
          B.setInt32(0, K, !0), B.setInt32(4, G, !0), B.getBigUint64(0, !0)
        );
      },
    };
  }
  const F = (j) => assert(/^-?[0-9]+$/.test(j), "int64 invalid: ".concat(j)),
    q = (j) => assert(/^[0-9]+$/.test(j), "uint64 invalid: ".concat(j));
  return {
    zero: "0",
    supported: !1,
    parse(j) {
      return typeof j != "string" && (j = j.toString()), F(j), j;
    },
    uParse(j) {
      return typeof j != "string" && (j = j.toString()), q(j), j;
    },
    enc(j) {
      return (
        typeof j != "string" && (j = j.toString()), F(j), int64FromString(j)
      );
    },
    uEnc(j) {
      return (
        typeof j != "string" && (j = j.toString()), q(j), int64FromString(j)
      );
    },
    dec(j, V) {
      return int64ToString(j, V);
    },
    uDec(j, V) {
      return uInt64ToString(j, V);
    },
  };
}
const protoInt64 = makeInt64Support();
var ScalarType;
(function (B) {
  (B[(B.DOUBLE = 1)] = "DOUBLE"),
    (B[(B.FLOAT = 2)] = "FLOAT"),
    (B[(B.INT64 = 3)] = "INT64"),
    (B[(B.UINT64 = 4)] = "UINT64"),
    (B[(B.INT32 = 5)] = "INT32"),
    (B[(B.FIXED64 = 6)] = "FIXED64"),
    (B[(B.FIXED32 = 7)] = "FIXED32"),
    (B[(B.BOOL = 8)] = "BOOL"),
    (B[(B.STRING = 9)] = "STRING"),
    (B[(B.BYTES = 12)] = "BYTES"),
    (B[(B.UINT32 = 13)] = "UINT32"),
    (B[(B.SFIXED32 = 15)] = "SFIXED32"),
    (B[(B.SFIXED64 = 16)] = "SFIXED64"),
    (B[(B.SINT32 = 17)] = "SINT32"),
    (B[(B.SINT64 = 18)] = "SINT64");
})(ScalarType || (ScalarType = {}));
var LongType;
(function (B) {
  (B[(B.BIGINT = 0)] = "BIGINT"), (B[(B.STRING = 1)] = "STRING");
})(LongType || (LongType = {}));
function scalarEquals(B, U, F) {
  if (U === F) return !0;
  if (B == ScalarType.BYTES) {
    if (
      !(U instanceof Uint8Array) ||
      !(F instanceof Uint8Array) ||
      U.length !== F.length
    )
      return !1;
    for (let q = 0; q < U.length; q++) if (U[q] !== F[q]) return !1;
    return !0;
  }
  switch (B) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return U == F;
  }
  return !1;
}
function scalarZeroValue(B, U) {
  switch (B) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return U == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(B, U) {
  switch (B) {
    case ScalarType.BOOL:
      return U === !1;
    case ScalarType.STRING:
      return U === "";
    case ScalarType.BYTES:
      return U instanceof Uint8Array && !U.byteLength;
    default:
      return U == 0;
  }
}
var WireType;
(function (B) {
  (B[(B.Varint = 0)] = "Varint"),
    (B[(B.Bit64 = 1)] = "Bit64"),
    (B[(B.LengthDelimited = 2)] = "LengthDelimited"),
    (B[(B.StartGroup = 3)] = "StartGroup"),
    (B[(B.EndGroup = 4)] = "EndGroup"),
    (B[(B.Bit32 = 5)] = "Bit32");
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(U) {
    (this.stack = []),
      (this.textEncoder = U ?? new TextEncoder()),
      (this.chunks = []),
      (this.buf = []);
  }
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let U = 0;
    for (let j = 0; j < this.chunks.length; j++) U += this.chunks[j].length;
    let F = new Uint8Array(U),
      q = 0;
    for (let j = 0; j < this.chunks.length; j++)
      F.set(this.chunks[j], q), (q += this.chunks[j].length);
    return (this.chunks = []), F;
  }
  fork() {
    return (
      this.stack.push({ chunks: this.chunks, buf: this.buf }),
      (this.chunks = []),
      (this.buf = []),
      this
    );
  }
  join() {
    let U = this.finish(),
      F = this.stack.pop();
    if (!F) throw new Error("invalid state, fork stack empty");
    return (
      (this.chunks = F.chunks),
      (this.buf = F.buf),
      this.uint32(U.byteLength),
      this.raw(U)
    );
  }
  tag(U, F) {
    return this.uint32(((U << 3) | F) >>> 0);
  }
  raw(U) {
    return (
      this.buf.length &&
        (this.chunks.push(new Uint8Array(this.buf)), (this.buf = [])),
      this.chunks.push(U),
      this
    );
  }
  uint32(U) {
    for (assertUInt32(U); U > 127; )
      this.buf.push((U & 127) | 128), (U = U >>> 7);
    return this.buf.push(U), this;
  }
  int32(U) {
    return assertInt32(U), varint32write(U, this.buf), this;
  }
  bool(U) {
    return this.buf.push(U ? 1 : 0), this;
  }
  bytes(U) {
    return this.uint32(U.byteLength), this.raw(U);
  }
  string(U) {
    let F = this.textEncoder.encode(U);
    return this.uint32(F.byteLength), this.raw(F);
  }
  float(U) {
    assertFloat32(U);
    let F = new Uint8Array(4);
    return new DataView(F.buffer).setFloat32(0, U, !0), this.raw(F);
  }
  double(U) {
    let F = new Uint8Array(8);
    return new DataView(F.buffer).setFloat64(0, U, !0), this.raw(F);
  }
  fixed32(U) {
    assertUInt32(U);
    let F = new Uint8Array(4);
    return new DataView(F.buffer).setUint32(0, U, !0), this.raw(F);
  }
  sfixed32(U) {
    assertInt32(U);
    let F = new Uint8Array(4);
    return new DataView(F.buffer).setInt32(0, U, !0), this.raw(F);
  }
  sint32(U) {
    return (
      assertInt32(U),
      (U = ((U << 1) ^ (U >> 31)) >>> 0),
      varint32write(U, this.buf),
      this
    );
  }
  sfixed64(U) {
    let F = new Uint8Array(8),
      q = new DataView(F.buffer),
      j = protoInt64.enc(U);
    return q.setInt32(0, j.lo, !0), q.setInt32(4, j.hi, !0), this.raw(F);
  }
  fixed64(U) {
    let F = new Uint8Array(8),
      q = new DataView(F.buffer),
      j = protoInt64.uEnc(U);
    return q.setInt32(0, j.lo, !0), q.setInt32(4, j.hi, !0), this.raw(F);
  }
  int64(U) {
    let F = protoInt64.enc(U);
    return varint64write(F.lo, F.hi, this.buf), this;
  }
  sint64(U) {
    let F = protoInt64.enc(U),
      q = F.hi >> 31,
      j = (F.lo << 1) ^ q,
      V = ((F.hi << 1) | (F.lo >>> 31)) ^ q;
    return varint64write(j, V, this.buf), this;
  }
  uint64(U) {
    let F = protoInt64.uEnc(U);
    return varint64write(F.lo, F.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(U, F) {
    (this.varint64 = varint64read),
      (this.uint32 = varint32read),
      (this.buf = U),
      (this.len = U.length),
      (this.pos = 0),
      (this.view = new DataView(U.buffer, U.byteOffset, U.byteLength)),
      (this.textDecoder = F ?? new TextDecoder());
  }
  tag() {
    let U = this.uint32(),
      F = U >>> 3,
      q = U & 7;
    if (F <= 0 || q < 0 || q > 5)
      throw new Error("illegal tag: field no " + F + " wire type " + q);
    return [F, q];
  }
  skip(U, F) {
    let q = this.pos;
    switch (U) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; );
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let j = this.uint32();
        this.pos += j;
        break;
      case WireType.StartGroup:
        for (;;) {
          const [V, $] = this.tag();
          if ($ === WireType.EndGroup) {
            if (F !== void 0 && V !== F)
              throw new Error("invalid end group tag");
            break;
          }
          this.skip($, V);
        }
        break;
      default:
        throw new Error("cant skip wire type " + U);
    }
    return this.assertBounds(), this.buf.subarray(q, this.pos);
  }
  assertBounds() {
    if (this.pos > this.len) throw new RangeError("premature EOF");
  }
  int32() {
    return this.uint32() | 0;
  }
  sint32() {
    let U = this.uint32();
    return (U >>> 1) ^ -(U & 1);
  }
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  sint64() {
    let [U, F] = this.varint64(),
      q = -(U & 1);
    return (
      (U = ((U >>> 1) | ((F & 1) << 31)) ^ q),
      (F = (F >>> 1) ^ q),
      protoInt64.dec(U, F)
    );
  }
  bool() {
    let [U, F] = this.varint64();
    return U !== 0 || F !== 0;
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  bytes() {
    let U = this.uint32(),
      F = this.pos;
    return (this.pos += U), this.assertBounds(), this.buf.subarray(F, F + U);
  }
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function makeExtension(B, U, F, q) {
  let j;
  return {
    typeName: U,
    extendee: F,
    get field() {
      if (!j) {
        const V = typeof q == "function" ? q() : q;
        (V.name = U.split(".").pop()),
          (V.jsonName = "[".concat(U, "]")),
          (j = B.util.newFieldList([V]).list()[0]);
      }
      return j;
    },
    runtime: B,
  };
}
function createExtensionContainer(B) {
  const U = B.field.localName,
    F = Object.create(null);
  return (F[U] = initExtensionField(B)), [F, () => F[U]];
}
function initExtensionField(B) {
  const U = B.field;
  if (U.repeated) return [];
  if (U.default !== void 0) return U.default;
  switch (U.kind) {
    case "enum":
      return U.T.values[0].no;
    case "scalar":
      return scalarZeroValue(U.T, U.L);
    case "message":
      const F = U.T,
        q = new F();
      return F.fieldWrapper ? F.fieldWrapper.unwrapField(q) : q;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(B, U) {
  if (!U.repeated && (U.kind == "enum" || U.kind == "scalar")) {
    for (let F = B.length - 1; F >= 0; --F) if (B[F].no == U.no) return [B[F]];
    return [];
  }
  return B.filter((F) => F.no === U.no);
}
let encTable =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      ""
    ),
  decTable = [];
for (let B = 0; B < encTable.length; B++)
  decTable[encTable[B].charCodeAt(0)] = B;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  dec(B) {
    let U = (B.length * 3) / 4;
    B[B.length - 2] == "=" ? (U -= 2) : B[B.length - 1] == "=" && (U -= 1);
    let F = new Uint8Array(U),
      q = 0,
      j = 0,
      V,
      $ = 0;
    for (let W = 0; W < B.length; W++) {
      if (((V = decTable[B.charCodeAt(W)]), V === void 0))
        switch (B[W]) {
          case "=":
            j = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (j) {
        case 0:
          ($ = V), (j = 1);
          break;
        case 1:
          (F[q++] = ($ << 2) | ((V & 48) >> 4)), ($ = V), (j = 2);
          break;
        case 2:
          (F[q++] = (($ & 15) << 4) | ((V & 60) >> 2)), ($ = V), (j = 3);
          break;
        case 3:
          (F[q++] = (($ & 3) << 6) | V), (j = 0);
          break;
      }
    }
    if (j == 1) throw Error("invalid base64 string.");
    return F.subarray(0, q);
  },
  enc(B) {
    let U = "",
      F = 0,
      q,
      j = 0;
    for (let V = 0; V < B.length; V++)
      switch (((q = B[V]), F)) {
        case 0:
          (U += encTable[q >> 2]), (j = (q & 3) << 4), (F = 1);
          break;
        case 1:
          (U += encTable[j | (q >> 4)]), (j = (q & 15) << 2), (F = 2);
          break;
        case 2:
          (U += encTable[j | (q >> 6)]), (U += encTable[q & 63]), (F = 0);
          break;
      }
    return F && ((U += encTable[j]), (U += "="), F == 1 && (U += "=")), U;
  },
};
function getExtension(B, U, F) {
  assertExtendee(U, B);
  const q = U.runtime.bin.makeReadOptions(F),
    j = filterUnknownFields(
      B.getType().runtime.bin.listUnknownFields(B),
      U.field
    ),
    [V, $] = createExtensionContainer(U);
  for (const W of j)
    U.runtime.bin.readField(V, q.readerFactory(W.data), U.field, W.wireType, q);
  return $();
}
function setExtension(B, U, F, q) {
  assertExtendee(U, B);
  const j = U.runtime.bin.makeReadOptions(q),
    V = U.runtime.bin.makeWriteOptions(q);
  if (hasExtension(B, U)) {
    const G = B.getType()
      .runtime.bin.listUnknownFields(B)
      .filter((H) => H.no != U.field.no);
    B.getType().runtime.bin.discardUnknownFields(B);
    for (const H of G)
      B.getType().runtime.bin.onUnknownField(B, H.no, H.wireType, H.data);
  }
  const $ = V.writerFactory();
  let W = U.field;
  !W.opt &&
    !W.repeated &&
    (W.kind == "enum" || W.kind == "scalar") &&
    (W = Object.assign(Object.assign({}, U.field), { opt: !0 })),
    U.runtime.bin.writeField(W, F, $, V);
  const K = j.readerFactory($.finish());
  for (; K.pos < K.len; ) {
    const [G, H] = K.tag(),
      Q = K.skip(H, G);
    B.getType().runtime.bin.onUnknownField(B, G, H, Q);
  }
}
function hasExtension(B, U) {
  const F = B.getType();
  return (
    U.extendee.typeName === F.typeName &&
    !!F.runtime.bin.listUnknownFields(B).find((q) => q.no == U.field.no)
  );
}
function assertExtendee(B, U) {
  assert(
    B.extendee.typeName == U.getType().typeName,
    "extension "
      .concat(B.typeName, " can only be applied to message ")
      .concat(B.extendee.typeName)
  );
}
function isFieldSet(B, U) {
  const F = B.localName;
  if (B.repeated) return U[F].length > 0;
  if (B.oneof) return U[B.oneof.localName].case === F;
  switch (B.kind) {
    case "enum":
    case "scalar":
      return B.opt || B.req
        ? U[F] !== void 0
        : B.kind == "enum"
        ? U[F] !== B.T.values[0].no
        : !isScalarZeroValue(B.T, U[F]);
    case "message":
      return U[F] !== void 0;
    case "map":
      return Object.keys(U[F]).length > 0;
  }
}
function clearField(B, U) {
  const F = B.localName,
    q = !B.opt && !B.req;
  if (B.repeated) U[F] = [];
  else if (B.oneof) U[B.oneof.localName] = { case: void 0 };
  else
    switch (B.kind) {
      case "map":
        U[F] = {};
        break;
      case "enum":
        U[F] = q ? B.T.values[0].no : void 0;
        break;
      case "scalar":
        U[F] = q ? scalarZeroValue(B.T, B.L) : void 0;
        break;
      case "message":
        U[F] = void 0;
        break;
    }
}
function isMessage(B, U) {
  if (
    B === null ||
    typeof B != "object" ||
    !Object.getOwnPropertyNames(Message.prototype).every(
      (q) => q in B && typeof B[q] == "function"
    )
  )
    return !1;
  const F = B.getType();
  return F === null ||
    typeof F != "function" ||
    !("typeName" in F) ||
    typeof F.typeName != "string"
    ? !1
    : U === void 0
    ? !0
    : F.typeName == U.typeName;
}
function wrapField(B, U) {
  return isMessage(U) || !B.fieldWrapper ? U : B.fieldWrapper.wrapField(U);
}
ScalarType.DOUBLE,
  ScalarType.FLOAT,
  ScalarType.INT64,
  ScalarType.UINT64,
  ScalarType.INT32,
  ScalarType.UINT32,
  ScalarType.BOOL,
  ScalarType.STRING,
  ScalarType.BYTES;
const jsonReadDefaults = { ignoreUnknownFields: !1 },
  jsonWriteDefaults = {
    emitDefaultValues: !1,
    enumAsInteger: !1,
    useProtoFieldName: !1,
    prettySpaces: 0,
  };
function makeReadOptions$1(B) {
  return B
    ? Object.assign(Object.assign({}, jsonReadDefaults), B)
    : jsonReadDefaults;
}
function makeWriteOptions$1(B) {
  return B
    ? Object.assign(Object.assign({}, jsonWriteDefaults), B)
    : jsonWriteDefaults;
}
const tokenNull = Symbol(),
  tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    readMessage(B, U, F, q) {
      if (U == null || Array.isArray(U) || typeof U != "object")
        throw new Error(
          "cannot decode message "
            .concat(B.typeName, " from JSON: ")
            .concat(debugJsonValue(U))
        );
      q = q ?? new B();
      const j = new Map(),
        V = F.typeRegistry;
      for (const [$, W] of Object.entries(U)) {
        const K = B.fields.findJsonName($);
        if (K) {
          if (K.oneof) {
            if (W === null && K.kind == "scalar") continue;
            const G = j.get(K.oneof);
            if (G !== void 0)
              throw new Error(
                "cannot decode message "
                  .concat(B.typeName, ' from JSON: multiple keys for oneof "')
                  .concat(K.oneof.name, '" present: "')
                  .concat(G, '", "')
                  .concat($, '"')
              );
            j.set(K.oneof, $);
          }
          readField$1(q, W, K, F, B);
        } else {
          let G = !1;
          if (
            V != null &&
            V.findExtension &&
            $.startsWith("[") &&
            $.endsWith("]")
          ) {
            const H = V.findExtension($.substring(1, $.length - 1));
            if (H && H.extendee.typeName == B.typeName) {
              G = !0;
              const [Q, z] = createExtensionContainer(H);
              readField$1(Q, W, H.field, F, H), setExtension(q, H, z(), F);
            }
          }
          if (!G && !F.ignoreUnknownFields)
            throw new Error(
              "cannot decode message "
                .concat(B.typeName, ' from JSON: key "')
                .concat($, '" is unknown')
            );
        }
      }
      return q;
    },
    writeMessage(B, U) {
      const F = B.getType(),
        q = {};
      let j;
      try {
        for (j of F.fields.byNumber()) {
          if (!isFieldSet(j, B)) {
            if (j.req) throw "required field not set";
            if (!U.emitDefaultValues || !canEmitFieldDefaultValue(j)) continue;
          }
          const $ = j.oneof ? B[j.oneof.localName].value : B[j.localName],
            W = writeField$1(j, $, U);
          W !== void 0 && (q[U.useProtoFieldName ? j.name : j.jsonName] = W);
        }
        const V = U.typeRegistry;
        if (V != null && V.findExtensionFor)
          for (const $ of F.runtime.bin.listUnknownFields(B)) {
            const W = V.findExtensionFor(F.typeName, $.no);
            if (W && hasExtension(B, W)) {
              const K = getExtension(B, W, U),
                G = writeField$1(W.field, K, U);
              G !== void 0 && (q[W.field.jsonName] = G);
            }
          }
      } catch (V) {
        const $ = j
            ? "cannot encode field "
                .concat(F.typeName, ".")
                .concat(j.name, " to JSON")
            : "cannot encode message ".concat(F.typeName, " to JSON"),
          W = V instanceof Error ? V.message : String(V);
        throw new Error($ + (W.length > 0 ? ": ".concat(W) : ""));
      }
      return q;
    },
    readScalar(B, U, F) {
      return readScalar$1(B, U, F ?? LongType.BIGINT, !0);
    },
    writeScalar(B, U, F) {
      if (U !== void 0 && (F || isScalarZeroValue(B, U)))
        return writeScalar$1(B, U);
    },
    debug: debugJsonValue,
  };
}
function debugJsonValue(B) {
  if (B === null) return "null";
  switch (typeof B) {
    case "object":
      return Array.isArray(B) ? "array" : "object";
    case "string":
      return B.length > 100
        ? "string"
        : '"'.concat(B.split('"').join('\\"'), '"');
    default:
      return String(B);
  }
}
function readField$1(B, U, F, q, j) {
  let V = F.localName;
  if (F.repeated) {
    if ((assert(F.kind != "map"), U === null)) return;
    if (!Array.isArray(U))
      throw new Error(
        "cannot decode field "
          .concat(j.typeName, ".")
          .concat(F.name, " from JSON: ")
          .concat(debugJsonValue(U))
      );
    const $ = B[V];
    for (const W of U) {
      if (W === null)
        throw new Error(
          "cannot decode field "
            .concat(j.typeName, ".")
            .concat(F.name, " from JSON: ")
            .concat(debugJsonValue(W))
        );
      switch (F.kind) {
        case "message":
          $.push(F.T.fromJson(W, q));
          break;
        case "enum":
          const K = readEnum(F.T, W, q.ignoreUnknownFields, !0);
          K !== tokenIgnoredUnknownEnum && $.push(K);
          break;
        case "scalar":
          try {
            $.push(readScalar$1(F.T, W, F.L, !0));
          } catch (G) {
            let H = "cannot decode field "
              .concat(j.typeName, ".")
              .concat(F.name, " from JSON: ")
              .concat(debugJsonValue(W));
            throw (
              (G instanceof Error &&
                G.message.length > 0 &&
                (H += ": ".concat(G.message)),
              new Error(H))
            );
          }
          break;
      }
    }
  } else if (F.kind == "map") {
    if (U === null) return;
    if (typeof U != "object" || Array.isArray(U))
      throw new Error(
        "cannot decode field "
          .concat(j.typeName, ".")
          .concat(F.name, " from JSON: ")
          .concat(debugJsonValue(U))
      );
    const $ = B[V];
    for (const [W, K] of Object.entries(U)) {
      if (K === null)
        throw new Error(
          "cannot decode field "
            .concat(j.typeName, ".")
            .concat(F.name, " from JSON: map value null")
        );
      let G;
      try {
        G = readMapKey(F.K, W);
      } catch (H) {
        let Q = "cannot decode map key for field "
          .concat(j.typeName, ".")
          .concat(F.name, " from JSON: ")
          .concat(debugJsonValue(U));
        throw (
          (H instanceof Error &&
            H.message.length > 0 &&
            (Q += ": ".concat(H.message)),
          new Error(Q))
        );
      }
      switch (F.V.kind) {
        case "message":
          $[G] = F.V.T.fromJson(K, q);
          break;
        case "enum":
          const H = readEnum(F.V.T, K, q.ignoreUnknownFields, !0);
          H !== tokenIgnoredUnknownEnum && ($[G] = H);
          break;
        case "scalar":
          try {
            $[G] = readScalar$1(F.V.T, K, LongType.BIGINT, !0);
          } catch (Q) {
            let z = "cannot decode map value for field "
              .concat(j.typeName, ".")
              .concat(F.name, " from JSON: ")
              .concat(debugJsonValue(U));
            throw (
              (Q instanceof Error &&
                Q.message.length > 0 &&
                (z += ": ".concat(Q.message)),
              new Error(z))
            );
          }
          break;
      }
    }
  } else
    switch (
      (F.oneof && ((B = B[F.oneof.localName] = { case: V }), (V = "value")),
      F.kind)
    ) {
      case "message":
        const $ = F.T;
        if (U === null && $.typeName != "google.protobuf.Value") return;
        let W = B[V];
        isMessage(W)
          ? W.fromJson(U, q)
          : ((B[V] = W = $.fromJson(U, q)),
            $.fieldWrapper &&
              !F.oneof &&
              (B[V] = $.fieldWrapper.unwrapField(W)));
        break;
      case "enum":
        const K = readEnum(F.T, U, q.ignoreUnknownFields, !1);
        switch (K) {
          case tokenNull:
            clearField(F, B);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            B[V] = K;
            break;
        }
        break;
      case "scalar":
        try {
          const G = readScalar$1(F.T, U, F.L, !1);
          switch (G) {
            case tokenNull:
              clearField(F, B);
              break;
            default:
              B[V] = G;
              break;
          }
        } catch (G) {
          let H = "cannot decode field "
            .concat(j.typeName, ".")
            .concat(F.name, " from JSON: ")
            .concat(debugJsonValue(U));
          throw (
            (G instanceof Error &&
              G.message.length > 0 &&
              (H += ": ".concat(G.message)),
            new Error(H))
          );
        }
        break;
    }
}
function readMapKey(B, U) {
  if (B === ScalarType.BOOL)
    switch (U) {
      case "true":
        U = !0;
        break;
      case "false":
        U = !1;
        break;
    }
  return readScalar$1(B, U, LongType.BIGINT, !0).toString();
}
function readScalar$1(B, U, F, q) {
  if (U === null) return q ? scalarZeroValue(B, F) : tokenNull;
  switch (B) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (U === "NaN") return Number.NaN;
      if (U === "Infinity") return Number.POSITIVE_INFINITY;
      if (U === "-Infinity") return Number.NEGATIVE_INFINITY;
      if (
        U === "" ||
        (typeof U == "string" && U.trim().length !== U.length) ||
        (typeof U != "string" && typeof U != "number")
      )
        break;
      const j = Number(U);
      if (Number.isNaN(j) || !Number.isFinite(j)) break;
      return B == ScalarType.FLOAT && assertFloat32(j), j;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let V;
      if (
        (typeof U == "number"
          ? (V = U)
          : typeof U == "string" &&
            U.length > 0 &&
            U.trim().length === U.length &&
            (V = Number(U)),
        V === void 0)
      )
        break;
      return (
        B == ScalarType.UINT32 || B == ScalarType.FIXED32
          ? assertUInt32(V)
          : assertInt32(V),
        V
      );
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof U != "number" && typeof U != "string") break;
      const $ = protoInt64.parse(U);
      return F ? $.toString() : $;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof U != "number" && typeof U != "string") break;
      const W = protoInt64.uParse(U);
      return F ? W.toString() : W;
    case ScalarType.BOOL:
      if (typeof U != "boolean") break;
      return U;
    case ScalarType.STRING:
      if (typeof U != "string") break;
      try {
        encodeURIComponent(U);
      } catch {
        throw new Error("invalid UTF8");
      }
      return U;
    case ScalarType.BYTES:
      if (U === "") return new Uint8Array(0);
      if (typeof U != "string") break;
      return protoBase64.dec(U);
  }
  throw new Error();
}
function readEnum(B, U, F, q) {
  if (U === null)
    return B.typeName == "google.protobuf.NullValue"
      ? 0
      : q
      ? B.values[0].no
      : tokenNull;
  switch (typeof U) {
    case "number":
      if (Number.isInteger(U)) return U;
      break;
    case "string":
      const j = B.findName(U);
      if (j !== void 0) return j.no;
      if (F) return tokenIgnoredUnknownEnum;
      break;
  }
  throw new Error(
    "cannot decode enum "
      .concat(B.typeName, " from JSON: ")
      .concat(debugJsonValue(U))
  );
}
function canEmitFieldDefaultValue(B) {
  return B.repeated || B.kind == "map"
    ? !0
    : !(B.oneof || B.kind == "message" || B.opt || B.req);
}
function writeField$1(B, U, F) {
  if (B.kind == "map") {
    assert(typeof U == "object" && U != null);
    const q = {},
      j = Object.entries(U);
    switch (B.V.kind) {
      case "scalar":
        for (const [$, W] of j) q[$.toString()] = writeScalar$1(B.V.T, W);
        break;
      case "message":
        for (const [$, W] of j) q[$.toString()] = W.toJson(F);
        break;
      case "enum":
        const V = B.V.T;
        for (const [$, W] of j)
          q[$.toString()] = writeEnum(V, W, F.enumAsInteger);
        break;
    }
    return F.emitDefaultValues || j.length > 0 ? q : void 0;
  }
  if (B.repeated) {
    assert(Array.isArray(U));
    const q = [];
    switch (B.kind) {
      case "scalar":
        for (let j = 0; j < U.length; j++) q.push(writeScalar$1(B.T, U[j]));
        break;
      case "enum":
        for (let j = 0; j < U.length; j++)
          q.push(writeEnum(B.T, U[j], F.enumAsInteger));
        break;
      case "message":
        for (let j = 0; j < U.length; j++) q.push(U[j].toJson(F));
        break;
    }
    return F.emitDefaultValues || q.length > 0 ? q : void 0;
  }
  switch (B.kind) {
    case "scalar":
      return writeScalar$1(B.T, U);
    case "enum":
      return writeEnum(B.T, U, F.enumAsInteger);
    case "message":
      return wrapField(B.T, U).toJson(F);
  }
}
function writeEnum(B, U, F) {
  var q;
  if ((assert(typeof U == "number"), B.typeName == "google.protobuf.NullValue"))
    return null;
  if (F) return U;
  const j = B.findNumber(U);
  return (q = j == null ? void 0 : j.name) !== null && q !== void 0 ? q : U;
}
function writeScalar$1(B, U) {
  switch (B) {
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      return assert(typeof U == "number"), U;
    case ScalarType.FLOAT:
    case ScalarType.DOUBLE:
      return (
        assert(typeof U == "number"),
        Number.isNaN(U)
          ? "NaN"
          : U === Number.POSITIVE_INFINITY
          ? "Infinity"
          : U === Number.NEGATIVE_INFINITY
          ? "-Infinity"
          : U
      );
    case ScalarType.STRING:
      return assert(typeof U == "string"), U;
    case ScalarType.BOOL:
      return assert(typeof U == "boolean"), U;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return (
        assert(
          typeof U == "bigint" || typeof U == "string" || typeof U == "number"
        ),
        U.toString()
      );
    case ScalarType.BYTES:
      return assert(U instanceof Uint8Array), protoBase64.enc(U);
  }
}
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"),
  readDefaults = {
    readUnknownFields: !0,
    readerFactory: (B) => new BinaryReader(B),
  },
  writeDefaults = {
    writeUnknownFields: !0,
    writerFactory: () => new BinaryWriter(),
  };
function makeReadOptions(B) {
  return B ? Object.assign(Object.assign({}, readDefaults), B) : readDefaults;
}
function makeWriteOptions(B) {
  return B ? Object.assign(Object.assign({}, writeDefaults), B) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    listUnknownFields(B) {
      var U;
      return (U = B[unknownFieldsSymbol]) !== null && U !== void 0 ? U : [];
    },
    discardUnknownFields(B) {
      delete B[unknownFieldsSymbol];
    },
    writeUnknownFields(B, U) {
      const q = B[unknownFieldsSymbol];
      if (q) for (const j of q) U.tag(j.no, j.wireType).raw(j.data);
    },
    onUnknownField(B, U, F, q) {
      const j = B;
      Array.isArray(j[unknownFieldsSymbol]) || (j[unknownFieldsSymbol] = []),
        j[unknownFieldsSymbol].push({ no: U, wireType: F, data: q });
    },
    readMessage(B, U, F, q, j) {
      const V = B.getType(),
        $ = j ? U.len : U.pos + F;
      let W, K;
      for (
        ;
        U.pos < $ &&
        (([W, K] = U.tag()), !(j === !0 && K == WireType.EndGroup));

      ) {
        const G = V.fields.find(W);
        if (!G) {
          const H = U.skip(K, W);
          q.readUnknownFields && this.onUnknownField(B, W, K, H);
          continue;
        }
        readField(B, U, G, K, q);
      }
      if (j && (K != WireType.EndGroup || W !== F))
        throw new Error("invalid end group tag");
    },
    readField,
    writeMessage(B, U, F) {
      const q = B.getType();
      for (const j of q.fields.byNumber()) {
        if (!isFieldSet(j, B)) {
          if (j.req)
            throw new Error(
              "cannot encode field "
                .concat(q.typeName, ".")
                .concat(j.name, " to binary: required field not set")
            );
          continue;
        }
        const V = j.oneof ? B[j.oneof.localName].value : B[j.localName];
        writeField(j, V, U, F);
      }
      return F.writeUnknownFields && this.writeUnknownFields(B, U), U;
    },
    writeField(B, U, F, q) {
      U !== void 0 && writeField(B, U, F, q);
    },
  };
}
function readField(B, U, F, q, j) {
  let { repeated: V, localName: $ } = F;
  switch (
    (F.oneof &&
      ((B = B[F.oneof.localName]),
      B.case != $ && delete B.value,
      (B.case = $),
      ($ = "value")),
    F.kind)
  ) {
    case "scalar":
    case "enum":
      const W = F.kind == "enum" ? ScalarType.INT32 : F.T;
      let K = readScalar;
      if ((F.kind == "scalar" && F.L > 0 && (K = readScalarLTString), V)) {
        let z = B[$];
        if (
          q == WireType.LengthDelimited &&
          W != ScalarType.STRING &&
          W != ScalarType.BYTES
        ) {
          let X = U.uint32() + U.pos;
          for (; U.pos < X; ) z.push(K(U, W));
        } else z.push(K(U, W));
      } else B[$] = K(U, W);
      break;
    case "message":
      const G = F.T;
      V
        ? B[$].push(readMessageField(U, new G(), j, F))
        : isMessage(B[$])
        ? readMessageField(U, B[$], j, F)
        : ((B[$] = readMessageField(U, new G(), j, F)),
          G.fieldWrapper &&
            !F.oneof &&
            !F.repeated &&
            (B[$] = G.fieldWrapper.unwrapField(B[$])));
      break;
    case "map":
      let [H, Q] = readMapEntry(F, U, j);
      B[$][H] = Q;
      break;
  }
}
function readMessageField(B, U, F, q) {
  const j = U.getType().runtime.bin,
    V = q == null ? void 0 : q.delimited;
  return j.readMessage(U, B, V ? q.no : B.uint32(), F, V), U;
}
function readMapEntry(B, U, F) {
  const q = U.uint32(),
    j = U.pos + q;
  let V, $;
  for (; U.pos < j; ) {
    const [W] = U.tag();
    switch (W) {
      case 1:
        V = readScalar(U, B.K);
        break;
      case 2:
        switch (B.V.kind) {
          case "scalar":
            $ = readScalar(U, B.V.T);
            break;
          case "enum":
            $ = U.int32();
            break;
          case "message":
            $ = readMessageField(U, new B.V.T(), F, void 0);
            break;
        }
        break;
    }
  }
  if (
    (V === void 0 && (V = scalarZeroValue(B.K, LongType.BIGINT)),
    typeof V != "string" && typeof V != "number" && (V = V.toString()),
    $ === void 0)
  )
    switch (B.V.kind) {
      case "scalar":
        $ = scalarZeroValue(B.V.T, LongType.BIGINT);
        break;
      case "enum":
        $ = B.V.T.values[0].no;
        break;
      case "message":
        $ = new B.V.T();
        break;
    }
  return [V, $];
}
function readScalarLTString(B, U) {
  const F = readScalar(B, U);
  return typeof F == "bigint" ? F.toString() : F;
}
function readScalar(B, U) {
  switch (U) {
    case ScalarType.STRING:
      return B.string();
    case ScalarType.BOOL:
      return B.bool();
    case ScalarType.DOUBLE:
      return B.double();
    case ScalarType.FLOAT:
      return B.float();
    case ScalarType.INT32:
      return B.int32();
    case ScalarType.INT64:
      return B.int64();
    case ScalarType.UINT64:
      return B.uint64();
    case ScalarType.FIXED64:
      return B.fixed64();
    case ScalarType.BYTES:
      return B.bytes();
    case ScalarType.FIXED32:
      return B.fixed32();
    case ScalarType.SFIXED32:
      return B.sfixed32();
    case ScalarType.SFIXED64:
      return B.sfixed64();
    case ScalarType.SINT64:
      return B.sint64();
    case ScalarType.UINT32:
      return B.uint32();
    case ScalarType.SINT32:
      return B.sint32();
  }
}
function writeField(B, U, F, q) {
  assert(U !== void 0);
  const j = B.repeated;
  switch (B.kind) {
    case "scalar":
    case "enum":
      let V = B.kind == "enum" ? ScalarType.INT32 : B.T;
      if (j)
        if ((assert(Array.isArray(U)), B.packed)) writePacked(F, V, B.no, U);
        else for (const $ of U) writeScalar(F, V, B.no, $);
      else writeScalar(F, V, B.no, U);
      break;
    case "message":
      if (j) {
        assert(Array.isArray(U));
        for (const $ of U) writeMessageField(F, q, B, $);
      } else writeMessageField(F, q, B, U);
      break;
    case "map":
      assert(typeof U == "object" && U != null);
      for (const [$, W] of Object.entries(U)) writeMapEntry(F, q, B, $, W);
      break;
  }
}
function writeMapEntry(B, U, F, q, j) {
  B.tag(F.no, WireType.LengthDelimited), B.fork();
  let V = q;
  switch (F.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      V = Number.parseInt(q);
      break;
    case ScalarType.BOOL:
      assert(q == "true" || q == "false"), (V = q == "true");
      break;
  }
  switch ((writeScalar(B, F.K, 1, V), F.V.kind)) {
    case "scalar":
      writeScalar(B, F.V.T, 2, j);
      break;
    case "enum":
      writeScalar(B, ScalarType.INT32, 2, j);
      break;
    case "message":
      assert(j !== void 0),
        B.tag(2, WireType.LengthDelimited).bytes(j.toBinary(U));
      break;
  }
  B.join();
}
function writeMessageField(B, U, F, q) {
  const j = wrapField(F.T, q);
  F.delimited
    ? B.tag(F.no, WireType.StartGroup)
        .raw(j.toBinary(U))
        .tag(F.no, WireType.EndGroup)
    : B.tag(F.no, WireType.LengthDelimited).bytes(j.toBinary(U));
}
function writeScalar(B, U, F, q) {
  assert(q !== void 0);
  let [j, V] = scalarTypeInfo(U);
  B.tag(F, j)[V](q);
}
function writePacked(B, U, F, q) {
  if (!q.length) return;
  B.tag(F, WireType.LengthDelimited).fork();
  let [, j] = scalarTypeInfo(U);
  for (let V = 0; V < q.length; V++) B[j](q[V]);
  B.join();
}
function scalarTypeInfo(B) {
  let U = WireType.Varint;
  switch (B) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      U = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      U = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      U = WireType.Bit32;
      break;
  }
  const F = ScalarType[B].toLowerCase();
  return [U, F];
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(B, U) {
      if (B === void 0) return;
      const F = U.getType();
      for (const q of F.fields.byMember()) {
        const j = q.localName,
          V = U,
          $ = B;
        if ($[j] != null)
          switch (q.kind) {
            case "oneof":
              const W = $[j].case;
              if (W === void 0) continue;
              const K = q.findField(W);
              let G = $[j].value;
              K && K.kind == "message" && !isMessage(G, K.T)
                ? (G = new K.T(G))
                : K &&
                  K.kind === "scalar" &&
                  K.T === ScalarType.BYTES &&
                  (G = toU8Arr(G)),
                (V[j] = { case: W, value: G });
              break;
            case "scalar":
            case "enum":
              let H = $[j];
              q.T === ScalarType.BYTES &&
                (H = q.repeated ? H.map(toU8Arr) : toU8Arr(H)),
                (V[j] = H);
              break;
            case "map":
              switch (q.V.kind) {
                case "scalar":
                case "enum":
                  if (q.V.T === ScalarType.BYTES)
                    for (const [Y, X] of Object.entries($[j]))
                      V[j][Y] = toU8Arr(X);
                  else Object.assign(V[j], $[j]);
                  break;
                case "message":
                  const z = q.V.T;
                  for (const Y of Object.keys($[j])) {
                    let X = $[j][Y];
                    z.fieldWrapper || (X = new z(X)), (V[j][Y] = X);
                  }
                  break;
              }
              break;
            case "message":
              const Q = q.T;
              if (q.repeated)
                V[j] = $[j].map((z) => (isMessage(z, Q) ? z : new Q(z)));
              else {
                const z = $[j];
                Q.fieldWrapper
                  ? Q.typeName === "google.protobuf.BytesValue"
                    ? (V[j] = toU8Arr(z))
                    : (V[j] = z)
                  : (V[j] = isMessage(z, Q) ? z : new Q(z));
              }
              break;
          }
      }
    },
    equals(B, U, F) {
      return U === F
        ? !0
        : !U || !F
        ? !1
        : B.fields.byMember().every((q) => {
            const j = U[q.localName],
              V = F[q.localName];
            if (q.repeated) {
              if (j.length !== V.length) return !1;
              switch (q.kind) {
                case "message":
                  return j.every(($, W) => q.T.equals($, V[W]));
                case "scalar":
                  return j.every(($, W) => scalarEquals(q.T, $, V[W]));
                case "enum":
                  return j.every(($, W) =>
                    scalarEquals(ScalarType.INT32, $, V[W])
                  );
              }
              throw new Error("repeated cannot contain ".concat(q.kind));
            }
            switch (q.kind) {
              case "message":
                return q.T.equals(j, V);
              case "enum":
                return scalarEquals(ScalarType.INT32, j, V);
              case "scalar":
                return scalarEquals(q.T, j, V);
              case "oneof":
                if (j.case !== V.case) return !1;
                const $ = q.findField(j.case);
                if ($ === void 0) return !0;
                switch ($.kind) {
                  case "message":
                    return $.T.equals(j.value, V.value);
                  case "enum":
                    return scalarEquals(ScalarType.INT32, j.value, V.value);
                  case "scalar":
                    return scalarEquals($.T, j.value, V.value);
                }
                throw new Error("oneof cannot contain ".concat($.kind));
              case "map":
                const W = Object.keys(j).concat(Object.keys(V));
                switch (q.V.kind) {
                  case "message":
                    const K = q.V.T;
                    return W.every((H) => K.equals(j[H], V[H]));
                  case "enum":
                    return W.every((H) =>
                      scalarEquals(ScalarType.INT32, j[H], V[H])
                    );
                  case "scalar":
                    const G = q.V.T;
                    return W.every((H) => scalarEquals(G, j[H], V[H]));
                }
                break;
            }
          });
    },
    clone(B) {
      const U = B.getType(),
        F = new U(),
        q = F;
      for (const j of U.fields.byMember()) {
        const V = B[j.localName];
        let $;
        if (j.repeated) $ = V.map(cloneSingularField);
        else if (j.kind == "map") {
          $ = q[j.localName];
          for (const [W, K] of Object.entries(V)) $[W] = cloneSingularField(K);
        } else
          j.kind == "oneof"
            ? ($ = j.findField(V.case)
                ? { case: V.case, value: cloneSingularField(V.value) }
                : { case: void 0 })
            : ($ = cloneSingularField(V));
        q[j.localName] = $;
      }
      for (const j of U.runtime.bin.listUnknownFields(B))
        U.runtime.bin.onUnknownField(q, j.no, j.wireType, j.data);
      return F;
    },
  };
}
function cloneSingularField(B) {
  if (B === void 0) return B;
  if (isMessage(B)) return B.clone();
  if (B instanceof Uint8Array) {
    const U = new Uint8Array(B.byteLength);
    return U.set(B), U;
  }
  return B;
}
function toU8Arr(B) {
  return B instanceof Uint8Array ? B : new Uint8Array(B);
}
function makeProtoRuntime(B, U, F) {
  return {
    syntax: B,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList: U,
      initFields: F,
    }),
    makeMessageType(q, j, V) {
      return makeMessageType(this, q, j, V);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(q, j, V) {
      return makeExtension(this, q, j, V);
    },
  };
}
class InternalFieldList {
  constructor(U, F) {
    (this._fields = U), (this._normalizer = F);
  }
  findJsonName(U) {
    if (!this.jsonNames) {
      const F = {};
      for (const q of this.list()) F[q.jsonName] = F[q.name] = q;
      this.jsonNames = F;
    }
    return this.jsonNames[U];
  }
  find(U) {
    if (!this.numbers) {
      const F = {};
      for (const q of this.list()) F[q.no] = q;
      this.numbers = F;
    }
    return this.numbers[U];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return (
      this.numbersAsc ||
        (this.numbersAsc = this.list()
          .concat()
          .sort((U, F) => U.no - F.no)),
      this.numbersAsc
    );
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const U = this.members;
      let F;
      for (const q of this.list())
        q.oneof ? q.oneof !== F && ((F = q.oneof), U.push(F)) : U.push(q);
    }
    return this.members;
  }
}
function localFieldName(B, U) {
  const F = protoCamelCase(B);
  return U ? F : safeObjectProperty(safeMessageProperty(F));
}
function localOneofName(B) {
  return localFieldName(B, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(B) {
  let U = !1;
  const F = [];
  for (let q = 0; q < B.length; q++) {
    let j = B.charAt(q);
    switch (j) {
      case "_":
        U = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        F.push(j), (U = !1);
        break;
      default:
        U && ((U = !1), (j = j.toUpperCase())), F.push(j);
        break;
    }
  }
  return F.join("");
}
const reservedObjectProperties = new Set([
    "constructor",
    "toString",
    "toJSON",
    "valueOf",
  ]),
  reservedMessageProperties = new Set([
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    "toObject",
  ]),
  fallback = (B) => "".concat(B, "$"),
  safeMessageProperty = (B) =>
    reservedMessageProperties.has(B) ? fallback(B) : B,
  safeObjectProperty = (B) =>
    reservedObjectProperties.has(B) ? fallback(B) : B;
class InternalOneofInfo {
  constructor(U) {
    (this.kind = "oneof"),
      (this.repeated = !1),
      (this.packed = !1),
      (this.opt = !1),
      (this.req = !1),
      (this.default = void 0),
      (this.fields = []),
      (this.name = U),
      (this.localName = localOneofName(U));
  }
  addField(U) {
    assert(
      U.oneof === this,
      "field ".concat(U.name, " not one of ").concat(this.name)
    ),
      this.fields.push(U);
  }
  findField(U) {
    if (!this._lookup) {
      this._lookup = Object.create(null);
      for (let F = 0; F < this.fields.length; F++)
        this._lookup[this.fields[F].localName] = this.fields[F];
    }
    return this._lookup[U];
  }
}
function normalizeFieldInfos(B, U) {
  var F, q, j, V, $, W;
  const K = [];
  let G;
  for (const H of typeof B == "function" ? B() : B) {
    const Q = H;
    if (
      ((Q.localName = localFieldName(H.name, H.oneof !== void 0)),
      (Q.jsonName =
        (F = H.jsonName) !== null && F !== void 0 ? F : fieldJsonName(H.name)),
      (Q.repeated = (q = H.repeated) !== null && q !== void 0 ? q : !1),
      H.kind == "scalar" &&
        (Q.L = (j = H.L) !== null && j !== void 0 ? j : LongType.BIGINT),
      (Q.delimited = (V = H.delimited) !== null && V !== void 0 ? V : !1),
      (Q.req = ($ = H.req) !== null && $ !== void 0 ? $ : !1),
      (Q.opt = (W = H.opt) !== null && W !== void 0 ? W : !1),
      H.packed === void 0 &&
        (Q.packed =
          H.kind == "enum" ||
          (H.kind == "scalar" &&
            H.T != ScalarType.BYTES &&
            H.T != ScalarType.STRING)),
      H.oneof !== void 0)
    ) {
      const z = typeof H.oneof == "string" ? H.oneof : H.oneof.name;
      (!G || G.name != z) && (G = new InternalOneofInfo(z)),
        (Q.oneof = G),
        G.addField(Q);
    }
    K.push(Q);
  }
  return K;
}
const proto3 = makeProtoRuntime(
  "proto3",
  (B) => new InternalFieldList(B, (U) => normalizeFieldInfos(U)),
  (B) => {
    for (const U of B.getType().fields.byMember()) {
      if (U.opt) continue;
      const F = U.localName,
        q = B;
      if (U.repeated) {
        q[F] = [];
        continue;
      }
      switch (U.kind) {
        case "oneof":
          q[F] = { case: void 0 };
          break;
        case "enum":
          q[F] = 0;
          break;
        case "map":
          q[F] = {};
          break;
        case "scalar":
          q[F] = scalarZeroValue(U.T, U.L);
          break;
      }
    }
  }
);
class Timestamp extends Message {
  constructor(U) {
    super(),
      (this.seconds = protoInt64.zero),
      (this.nanos = 0),
      proto3.util.initPartial(U, this);
  }
  fromJson(U, F) {
    if (typeof U != "string")
      throw new Error(
        "cannot decode google.protobuf.Timestamp from JSON: ".concat(
          proto3.json.debug(U)
        )
      );
    const q = U.match(
      /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/
    );
    if (!q)
      throw new Error(
        "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string"
      );
    const j = Date.parse(
      q[1] +
        "-" +
        q[2] +
        "-" +
        q[3] +
        "T" +
        q[4] +
        ":" +
        q[5] +
        ":" +
        q[6] +
        (q[8] ? q[8] : "Z")
    );
    if (Number.isNaN(j))
      throw new Error(
        "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string"
      );
    if (
      j < Date.parse("0001-01-01T00:00:00Z") ||
      j > Date.parse("9999-12-31T23:59:59Z")
    )
      throw new Error(
        "cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive"
      );
    return (
      (this.seconds = protoInt64.parse(j / 1e3)),
      (this.nanos = 0),
      q[7] &&
        (this.nanos = parseInt("1" + q[7] + "0".repeat(9 - q[7].length)) - 1e9),
      this
    );
  }
  toJson(U) {
    const F = Number(this.seconds) * 1e3;
    if (
      F < Date.parse("0001-01-01T00:00:00Z") ||
      F > Date.parse("9999-12-31T23:59:59Z")
    )
      throw new Error(
        "cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive"
      );
    if (this.nanos < 0)
      throw new Error(
        "cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative"
      );
    let q = "Z";
    if (this.nanos > 0) {
      const j = (this.nanos + 1e9).toString().substring(1);
      j.substring(3) === "000000"
        ? (q = "." + j.substring(0, 3) + "Z")
        : j.substring(6) === "000"
        ? (q = "." + j.substring(0, 6) + "Z")
        : (q = "." + j + "Z");
    }
    return new Date(F).toISOString().replace(".000Z", q);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(new Date());
  }
  static fromDate(U) {
    const F = U.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(F / 1e3)),
      nanos: (F % 1e3) * 1e6,
    });
  }
  static fromBinary(U, F) {
    return new Timestamp().fromBinary(U, F);
  }
  static fromJson(U, F) {
    return new Timestamp().fromJson(U, F);
  }
  static fromJsonString(U, F) {
    return new Timestamp().fromJsonString(U, F);
  }
  static equals(U, F) {
    return proto3.util.equals(Timestamp, U, F);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [
  { no: 1, name: "seconds", kind: "scalar", T: 3 },
  { no: 2, name: "nanos", kind: "scalar", T: 5 },
]);
const MetricsBatch = proto3.makeMessageType("livekit.MetricsBatch", () => [
    { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "str_data", kind: "scalar", T: 9, repeated: !0 },
    {
      no: 4,
      name: "time_series",
      kind: "message",
      T: TimeSeriesMetric,
      repeated: !0,
    },
    { no: 5, name: "events", kind: "message", T: EventMetric, repeated: !0 },
  ]),
  TimeSeriesMetric = proto3.makeMessageType("livekit.TimeSeriesMetric", () => [
    { no: 1, name: "label", kind: "scalar", T: 13 },
    { no: 2, name: "participant_identity", kind: "scalar", T: 13 },
    { no: 3, name: "track_sid", kind: "scalar", T: 13 },
    { no: 4, name: "samples", kind: "message", T: MetricSample, repeated: !0 },
    { no: 5, name: "rid", kind: "scalar", T: 13 },
  ]),
  MetricSample = proto3.makeMessageType("livekit.MetricSample", () => [
    { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 },
    { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "value", kind: "scalar", T: 2 },
  ]),
  EventMetric = proto3.makeMessageType("livekit.EventMetric", () => [
    { no: 1, name: "label", kind: "scalar", T: 13 },
    { no: 2, name: "participant_identity", kind: "scalar", T: 13 },
    { no: 3, name: "track_sid", kind: "scalar", T: 13 },
    { no: 4, name: "start_timestamp_ms", kind: "scalar", T: 3 },
    { no: 5, name: "end_timestamp_ms", kind: "scalar", T: 3, opt: !0 },
    {
      no: 6,
      name: "normalized_start_timestamp",
      kind: "message",
      T: Timestamp,
    },
    {
      no: 7,
      name: "normalized_end_timestamp",
      kind: "message",
      T: Timestamp,
      opt: !0,
    },
    { no: 8, name: "metadata", kind: "scalar", T: 9 },
    { no: 9, name: "rid", kind: "scalar", T: 13 },
  ]),
  BackupCodecPolicy$1 = proto3.makeEnum("livekit.BackupCodecPolicy", [
    { no: 0, name: "PREFER_REGRESSION" },
    { no: 1, name: "SIMULCAST" },
    { no: 2, name: "REGRESSION" },
  ]),
  TrackType = proto3.makeEnum("livekit.TrackType", [
    { no: 0, name: "AUDIO" },
    { no: 1, name: "VIDEO" },
    { no: 2, name: "DATA" },
  ]),
  TrackSource = proto3.makeEnum("livekit.TrackSource", [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "CAMERA" },
    { no: 2, name: "MICROPHONE" },
    { no: 3, name: "SCREEN_SHARE" },
    { no: 4, name: "SCREEN_SHARE_AUDIO" },
  ]),
  VideoQuality$1 = proto3.makeEnum("livekit.VideoQuality", [
    { no: 0, name: "LOW" },
    { no: 1, name: "MEDIUM" },
    { no: 2, name: "HIGH" },
    { no: 3, name: "OFF" },
  ]),
  ConnectionQuality$1 = proto3.makeEnum("livekit.ConnectionQuality", [
    { no: 0, name: "POOR" },
    { no: 1, name: "GOOD" },
    { no: 2, name: "EXCELLENT" },
    { no: 3, name: "LOST" },
  ]),
  ClientConfigSetting = proto3.makeEnum("livekit.ClientConfigSetting", [
    { no: 0, name: "UNSET" },
    { no: 1, name: "DISABLED" },
    { no: 2, name: "ENABLED" },
  ]),
  DisconnectReason = proto3.makeEnum("livekit.DisconnectReason", [
    { no: 0, name: "UNKNOWN_REASON" },
    { no: 1, name: "CLIENT_INITIATED" },
    { no: 2, name: "DUPLICATE_IDENTITY" },
    { no: 3, name: "SERVER_SHUTDOWN" },
    { no: 4, name: "PARTICIPANT_REMOVED" },
    { no: 5, name: "ROOM_DELETED" },
    { no: 6, name: "STATE_MISMATCH" },
    { no: 7, name: "JOIN_FAILURE" },
    { no: 8, name: "MIGRATION" },
    { no: 9, name: "SIGNAL_CLOSE" },
    { no: 10, name: "ROOM_CLOSED" },
    { no: 11, name: "USER_UNAVAILABLE" },
    { no: 12, name: "USER_REJECTED" },
    { no: 13, name: "SIP_TRUNK_FAILURE" },
  ]),
  ReconnectReason = proto3.makeEnum("livekit.ReconnectReason", [
    { no: 0, name: "RR_UNKNOWN" },
    { no: 1, name: "RR_SIGNAL_DISCONNECTED" },
    { no: 2, name: "RR_PUBLISHER_FAILED" },
    { no: 3, name: "RR_SUBSCRIBER_FAILED" },
    { no: 4, name: "RR_SWITCH_CANDIDATE" },
  ]),
  SubscriptionError = proto3.makeEnum("livekit.SubscriptionError", [
    { no: 0, name: "SE_UNKNOWN" },
    { no: 1, name: "SE_CODEC_UNSUPPORTED" },
    { no: 2, name: "SE_TRACK_NOTFOUND" },
  ]),
  AudioTrackFeature = proto3.makeEnum("livekit.AudioTrackFeature", [
    { no: 0, name: "TF_STEREO" },
    { no: 1, name: "TF_NO_DTX" },
    { no: 2, name: "TF_AUTO_GAIN_CONTROL" },
    { no: 3, name: "TF_ECHO_CANCELLATION" },
    { no: 4, name: "TF_NOISE_SUPPRESSION" },
    { no: 5, name: "TF_ENHANCED_NOISE_CANCELLATION" },
  ]),
  Room$1 = proto3.makeMessageType("livekit.Room", () => [
    { no: 1, name: "sid", kind: "scalar", T: 9 },
    { no: 2, name: "name", kind: "scalar", T: 9 },
    { no: 3, name: "empty_timeout", kind: "scalar", T: 13 },
    { no: 14, name: "departure_timeout", kind: "scalar", T: 13 },
    { no: 4, name: "max_participants", kind: "scalar", T: 13 },
    { no: 5, name: "creation_time", kind: "scalar", T: 3 },
    { no: 15, name: "creation_time_ms", kind: "scalar", T: 3 },
    { no: 6, name: "turn_password", kind: "scalar", T: 9 },
    { no: 7, name: "enabled_codecs", kind: "message", T: Codec, repeated: !0 },
    { no: 8, name: "metadata", kind: "scalar", T: 9 },
    { no: 9, name: "num_participants", kind: "scalar", T: 13 },
    { no: 11, name: "num_publishers", kind: "scalar", T: 13 },
    { no: 10, name: "active_recording", kind: "scalar", T: 8 },
    { no: 13, name: "version", kind: "message", T: TimedVersion },
  ]),
  Codec = proto3.makeMessageType("livekit.Codec", () => [
    { no: 1, name: "mime", kind: "scalar", T: 9 },
    { no: 2, name: "fmtp_line", kind: "scalar", T: 9 },
  ]),
  ParticipantPermission = proto3.makeMessageType(
    "livekit.ParticipantPermission",
    () => [
      { no: 1, name: "can_subscribe", kind: "scalar", T: 8 },
      { no: 2, name: "can_publish", kind: "scalar", T: 8 },
      { no: 3, name: "can_publish_data", kind: "scalar", T: 8 },
      {
        no: 9,
        name: "can_publish_sources",
        kind: "enum",
        T: proto3.getEnumType(TrackSource),
        repeated: !0,
      },
      { no: 7, name: "hidden", kind: "scalar", T: 8 },
      { no: 8, name: "recorder", kind: "scalar", T: 8 },
      { no: 10, name: "can_update_metadata", kind: "scalar", T: 8 },
      { no: 11, name: "agent", kind: "scalar", T: 8 },
      { no: 12, name: "can_subscribe_metrics", kind: "scalar", T: 8 },
    ]
  ),
  ParticipantInfo = proto3.makeMessageType("livekit.ParticipantInfo", () => [
    { no: 1, name: "sid", kind: "scalar", T: 9 },
    { no: 2, name: "identity", kind: "scalar", T: 9 },
    {
      no: 3,
      name: "state",
      kind: "enum",
      T: proto3.getEnumType(ParticipantInfo_State),
    },
    { no: 4, name: "tracks", kind: "message", T: TrackInfo, repeated: !0 },
    { no: 5, name: "metadata", kind: "scalar", T: 9 },
    { no: 6, name: "joined_at", kind: "scalar", T: 3 },
    { no: 17, name: "joined_at_ms", kind: "scalar", T: 3 },
    { no: 9, name: "name", kind: "scalar", T: 9 },
    { no: 10, name: "version", kind: "scalar", T: 13 },
    { no: 11, name: "permission", kind: "message", T: ParticipantPermission },
    { no: 12, name: "region", kind: "scalar", T: 9 },
    { no: 13, name: "is_publisher", kind: "scalar", T: 8 },
    {
      no: 14,
      name: "kind",
      kind: "enum",
      T: proto3.getEnumType(ParticipantInfo_Kind),
    },
    {
      no: 15,
      name: "attributes",
      kind: "map",
      K: 9,
      V: { kind: "scalar", T: 9 },
    },
    {
      no: 16,
      name: "disconnect_reason",
      kind: "enum",
      T: proto3.getEnumType(DisconnectReason),
    },
    {
      no: 18,
      name: "kind_details",
      kind: "enum",
      T: proto3.getEnumType(ParticipantInfo_KindDetail),
      repeated: !0,
    },
  ]),
  ParticipantInfo_State = proto3.makeEnum("livekit.ParticipantInfo.State", [
    { no: 0, name: "JOINING" },
    { no: 1, name: "JOINED" },
    { no: 2, name: "ACTIVE" },
    { no: 3, name: "DISCONNECTED" },
  ]),
  ParticipantInfo_Kind = proto3.makeEnum("livekit.ParticipantInfo.Kind", [
    { no: 0, name: "STANDARD" },
    { no: 1, name: "INGRESS" },
    { no: 2, name: "EGRESS" },
    { no: 3, name: "SIP" },
    { no: 4, name: "AGENT" },
  ]),
  ParticipantInfo_KindDetail = proto3.makeEnum(
    "livekit.ParticipantInfo.KindDetail",
    [
      { no: 0, name: "CLOUD_AGENT" },
      { no: 1, name: "FORWARDED" },
    ]
  ),
  Encryption_Type = proto3.makeEnum("livekit.Encryption.Type", [
    { no: 0, name: "NONE" },
    { no: 1, name: "GCM" },
    { no: 2, name: "CUSTOM" },
  ]),
  SimulcastCodecInfo = proto3.makeMessageType(
    "livekit.SimulcastCodecInfo",
    () => [
      { no: 1, name: "mime_type", kind: "scalar", T: 9 },
      { no: 2, name: "mid", kind: "scalar", T: 9 },
      { no: 3, name: "cid", kind: "scalar", T: 9 },
      { no: 4, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
    ]
  ),
  TrackInfo = proto3.makeMessageType("livekit.TrackInfo", () => [
    { no: 1, name: "sid", kind: "scalar", T: 9 },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
    { no: 3, name: "name", kind: "scalar", T: 9 },
    { no: 4, name: "muted", kind: "scalar", T: 8 },
    { no: 5, name: "width", kind: "scalar", T: 13 },
    { no: 6, name: "height", kind: "scalar", T: 13 },
    { no: 7, name: "simulcast", kind: "scalar", T: 8 },
    { no: 8, name: "disable_dtx", kind: "scalar", T: 8 },
    { no: 9, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 10, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
    { no: 11, name: "mime_type", kind: "scalar", T: 9 },
    { no: 12, name: "mid", kind: "scalar", T: 9 },
    {
      no: 13,
      name: "codecs",
      kind: "message",
      T: SimulcastCodecInfo,
      repeated: !0,
    },
    { no: 14, name: "stereo", kind: "scalar", T: 8 },
    { no: 15, name: "disable_red", kind: "scalar", T: 8 },
    {
      no: 16,
      name: "encryption",
      kind: "enum",
      T: proto3.getEnumType(Encryption_Type),
    },
    { no: 17, name: "stream", kind: "scalar", T: 9 },
    { no: 18, name: "version", kind: "message", T: TimedVersion },
    {
      no: 19,
      name: "audio_features",
      kind: "enum",
      T: proto3.getEnumType(AudioTrackFeature),
      repeated: !0,
    },
    {
      no: 20,
      name: "backup_codec_policy",
      kind: "enum",
      T: proto3.getEnumType(BackupCodecPolicy$1),
    },
  ]),
  VideoLayer = proto3.makeMessageType("livekit.VideoLayer", () => [
    {
      no: 1,
      name: "quality",
      kind: "enum",
      T: proto3.getEnumType(VideoQuality$1),
    },
    { no: 2, name: "width", kind: "scalar", T: 13 },
    { no: 3, name: "height", kind: "scalar", T: 13 },
    { no: 4, name: "bitrate", kind: "scalar", T: 13 },
    { no: 5, name: "ssrc", kind: "scalar", T: 13 },
  ]),
  DataPacket = proto3.makeMessageType("livekit.DataPacket", () => [
    {
      no: 1,
      name: "kind",
      kind: "enum",
      T: proto3.getEnumType(DataPacket_Kind),
    },
    { no: 4, name: "participant_identity", kind: "scalar", T: 9 },
    {
      no: 5,
      name: "destination_identities",
      kind: "scalar",
      T: 9,
      repeated: !0,
    },
    { no: 2, name: "user", kind: "message", T: UserPacket, oneof: "value" },
    {
      no: 3,
      name: "speaker",
      kind: "message",
      T: ActiveSpeakerUpdate,
      oneof: "value",
    },
    { no: 6, name: "sip_dtmf", kind: "message", T: SipDTMF, oneof: "value" },
    {
      no: 7,
      name: "transcription",
      kind: "message",
      T: Transcription,
      oneof: "value",
    },
    {
      no: 8,
      name: "metrics",
      kind: "message",
      T: MetricsBatch,
      oneof: "value",
    },
    {
      no: 9,
      name: "chat_message",
      kind: "message",
      T: ChatMessage,
      oneof: "value",
    },
    {
      no: 10,
      name: "rpc_request",
      kind: "message",
      T: RpcRequest,
      oneof: "value",
    },
    { no: 11, name: "rpc_ack", kind: "message", T: RpcAck, oneof: "value" },
    {
      no: 12,
      name: "rpc_response",
      kind: "message",
      T: RpcResponse,
      oneof: "value",
    },
    {
      no: 13,
      name: "stream_header",
      kind: "message",
      T: DataStream_Header,
      oneof: "value",
    },
    {
      no: 14,
      name: "stream_chunk",
      kind: "message",
      T: DataStream_Chunk,
      oneof: "value",
    },
    {
      no: 15,
      name: "stream_trailer",
      kind: "message",
      T: DataStream_Trailer,
      oneof: "value",
    },
  ]),
  DataPacket_Kind = proto3.makeEnum("livekit.DataPacket.Kind", [
    { no: 0, name: "RELIABLE" },
    { no: 1, name: "LOSSY" },
  ]),
  ActiveSpeakerUpdate = proto3.makeMessageType(
    "livekit.ActiveSpeakerUpdate",
    () => [
      {
        no: 1,
        name: "speakers",
        kind: "message",
        T: SpeakerInfo,
        repeated: !0,
      },
    ]
  ),
  SpeakerInfo = proto3.makeMessageType("livekit.SpeakerInfo", () => [
    { no: 1, name: "sid", kind: "scalar", T: 9 },
    { no: 2, name: "level", kind: "scalar", T: 2 },
    { no: 3, name: "active", kind: "scalar", T: 8 },
  ]),
  UserPacket = proto3.makeMessageType("livekit.UserPacket", () => [
    { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
    { no: 5, name: "participant_identity", kind: "scalar", T: 9 },
    { no: 2, name: "payload", kind: "scalar", T: 12 },
    { no: 3, name: "destination_sids", kind: "scalar", T: 9, repeated: !0 },
    {
      no: 6,
      name: "destination_identities",
      kind: "scalar",
      T: 9,
      repeated: !0,
    },
    { no: 4, name: "topic", kind: "scalar", T: 9, opt: !0 },
    { no: 8, name: "id", kind: "scalar", T: 9, opt: !0 },
    { no: 9, name: "start_time", kind: "scalar", T: 4, opt: !0 },
    { no: 10, name: "end_time", kind: "scalar", T: 4, opt: !0 },
    { no: 11, name: "nonce", kind: "scalar", T: 12 },
  ]),
  SipDTMF = proto3.makeMessageType("livekit.SipDTMF", () => [
    { no: 3, name: "code", kind: "scalar", T: 13 },
    { no: 4, name: "digit", kind: "scalar", T: 9 },
  ]),
  Transcription = proto3.makeMessageType("livekit.Transcription", () => [
    { no: 2, name: "transcribed_participant_identity", kind: "scalar", T: 9 },
    { no: 3, name: "track_id", kind: "scalar", T: 9 },
    {
      no: 4,
      name: "segments",
      kind: "message",
      T: TranscriptionSegment,
      repeated: !0,
    },
  ]),
  TranscriptionSegment = proto3.makeMessageType(
    "livekit.TranscriptionSegment",
    () => [
      { no: 1, name: "id", kind: "scalar", T: 9 },
      { no: 2, name: "text", kind: "scalar", T: 9 },
      { no: 3, name: "start_time", kind: "scalar", T: 4 },
      { no: 4, name: "end_time", kind: "scalar", T: 4 },
      { no: 5, name: "final", kind: "scalar", T: 8 },
      { no: 6, name: "language", kind: "scalar", T: 9 },
    ]
  ),
  ChatMessage = proto3.makeMessageType("livekit.ChatMessage", () => [
    { no: 1, name: "id", kind: "scalar", T: 9 },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 },
    { no: 3, name: "edit_timestamp", kind: "scalar", T: 3, opt: !0 },
    { no: 4, name: "message", kind: "scalar", T: 9 },
    { no: 5, name: "deleted", kind: "scalar", T: 8 },
    { no: 6, name: "generated", kind: "scalar", T: 8 },
  ]),
  RpcRequest = proto3.makeMessageType("livekit.RpcRequest", () => [
    { no: 1, name: "id", kind: "scalar", T: 9 },
    { no: 2, name: "method", kind: "scalar", T: 9 },
    { no: 3, name: "payload", kind: "scalar", T: 9 },
    { no: 4, name: "response_timeout_ms", kind: "scalar", T: 13 },
    { no: 5, name: "version", kind: "scalar", T: 13 },
  ]),
  RpcAck = proto3.makeMessageType("livekit.RpcAck", () => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 },
  ]),
  RpcResponse = proto3.makeMessageType("livekit.RpcResponse", () => [
    { no: 1, name: "request_id", kind: "scalar", T: 9 },
    { no: 2, name: "payload", kind: "scalar", T: 9, oneof: "value" },
    { no: 3, name: "error", kind: "message", T: RpcError$1, oneof: "value" },
  ]),
  RpcError$1 = proto3.makeMessageType("livekit.RpcError", () => [
    { no: 1, name: "code", kind: "scalar", T: 13 },
    { no: 2, name: "message", kind: "scalar", T: 9 },
    { no: 3, name: "data", kind: "scalar", T: 9 },
  ]),
  ParticipantTracks = proto3.makeMessageType(
    "livekit.ParticipantTracks",
    () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      { no: 2, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
    ]
  ),
  ServerInfo = proto3.makeMessageType("livekit.ServerInfo", () => [
    {
      no: 1,
      name: "edition",
      kind: "enum",
      T: proto3.getEnumType(ServerInfo_Edition),
    },
    { no: 2, name: "version", kind: "scalar", T: 9 },
    { no: 3, name: "protocol", kind: "scalar", T: 5 },
    { no: 4, name: "region", kind: "scalar", T: 9 },
    { no: 5, name: "node_id", kind: "scalar", T: 9 },
    { no: 6, name: "debug_info", kind: "scalar", T: 9 },
    { no: 7, name: "agent_protocol", kind: "scalar", T: 5 },
  ]),
  ServerInfo_Edition = proto3.makeEnum("livekit.ServerInfo.Edition", [
    { no: 0, name: "Standard" },
    { no: 1, name: "Cloud" },
  ]),
  ClientInfo = proto3.makeMessageType("livekit.ClientInfo", () => [
    { no: 1, name: "sdk", kind: "enum", T: proto3.getEnumType(ClientInfo_SDK) },
    { no: 2, name: "version", kind: "scalar", T: 9 },
    { no: 3, name: "protocol", kind: "scalar", T: 5 },
    { no: 4, name: "os", kind: "scalar", T: 9 },
    { no: 5, name: "os_version", kind: "scalar", T: 9 },
    { no: 6, name: "device_model", kind: "scalar", T: 9 },
    { no: 7, name: "browser", kind: "scalar", T: 9 },
    { no: 8, name: "browser_version", kind: "scalar", T: 9 },
    { no: 9, name: "address", kind: "scalar", T: 9 },
    { no: 10, name: "network", kind: "scalar", T: 9 },
    { no: 11, name: "other_sdks", kind: "scalar", T: 9 },
  ]),
  ClientInfo_SDK = proto3.makeEnum("livekit.ClientInfo.SDK", [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "JS" },
    { no: 2, name: "SWIFT" },
    { no: 3, name: "ANDROID" },
    { no: 4, name: "FLUTTER" },
    { no: 5, name: "GO" },
    { no: 6, name: "UNITY" },
    { no: 7, name: "REACT_NATIVE" },
    { no: 8, name: "RUST" },
    { no: 9, name: "PYTHON" },
    { no: 10, name: "CPP" },
    { no: 11, name: "UNITY_WEB" },
    { no: 12, name: "NODE" },
  ]),
  ClientConfiguration = proto3.makeMessageType(
    "livekit.ClientConfiguration",
    () => [
      { no: 1, name: "video", kind: "message", T: VideoConfiguration },
      { no: 2, name: "screen", kind: "message", T: VideoConfiguration },
      {
        no: 3,
        name: "resume_connection",
        kind: "enum",
        T: proto3.getEnumType(ClientConfigSetting),
      },
      { no: 4, name: "disabled_codecs", kind: "message", T: DisabledCodecs },
      {
        no: 5,
        name: "force_relay",
        kind: "enum",
        T: proto3.getEnumType(ClientConfigSetting),
      },
    ]
  ),
  VideoConfiguration = proto3.makeMessageType(
    "livekit.VideoConfiguration",
    () => [
      {
        no: 1,
        name: "hardware_encoder",
        kind: "enum",
        T: proto3.getEnumType(ClientConfigSetting),
      },
    ]
  ),
  DisabledCodecs = proto3.makeMessageType("livekit.DisabledCodecs", () => [
    { no: 1, name: "codecs", kind: "message", T: Codec, repeated: !0 },
    { no: 2, name: "publish", kind: "message", T: Codec, repeated: !0 },
  ]),
  TimedVersion = proto3.makeMessageType("livekit.TimedVersion", () => [
    { no: 1, name: "unix_micro", kind: "scalar", T: 3 },
    { no: 2, name: "ticks", kind: "scalar", T: 5 },
  ]),
  DataStream_OperationType = proto3.makeEnum(
    "livekit.DataStream.OperationType",
    [
      { no: 0, name: "CREATE" },
      { no: 1, name: "UPDATE" },
      { no: 2, name: "DELETE" },
      { no: 3, name: "REACTION" },
    ]
  ),
  DataStream_TextHeader = proto3.makeMessageType(
    "livekit.DataStream.TextHeader",
    () => [
      {
        no: 1,
        name: "operation_type",
        kind: "enum",
        T: proto3.getEnumType(DataStream_OperationType),
      },
      { no: 2, name: "version", kind: "scalar", T: 5 },
      { no: 3, name: "reply_to_stream_id", kind: "scalar", T: 9 },
      {
        no: 4,
        name: "attached_stream_ids",
        kind: "scalar",
        T: 9,
        repeated: !0,
      },
      { no: 5, name: "generated", kind: "scalar", T: 8 },
    ],
    { localName: "DataStream_TextHeader" }
  ),
  DataStream_ByteHeader = proto3.makeMessageType(
    "livekit.DataStream.ByteHeader",
    () => [{ no: 1, name: "name", kind: "scalar", T: 9 }],
    { localName: "DataStream_ByteHeader" }
  ),
  DataStream_Header = proto3.makeMessageType(
    "livekit.DataStream.Header",
    () => [
      { no: 1, name: "stream_id", kind: "scalar", T: 9 },
      { no: 2, name: "timestamp", kind: "scalar", T: 3 },
      { no: 3, name: "topic", kind: "scalar", T: 9 },
      { no: 4, name: "mime_type", kind: "scalar", T: 9 },
      { no: 5, name: "total_length", kind: "scalar", T: 4, opt: !0 },
      {
        no: 7,
        name: "encryption_type",
        kind: "enum",
        T: proto3.getEnumType(Encryption_Type),
      },
      {
        no: 8,
        name: "attributes",
        kind: "map",
        K: 9,
        V: { kind: "scalar", T: 9 },
      },
      {
        no: 9,
        name: "text_header",
        kind: "message",
        T: DataStream_TextHeader,
        oneof: "content_header",
      },
      {
        no: 10,
        name: "byte_header",
        kind: "message",
        T: DataStream_ByteHeader,
        oneof: "content_header",
      },
    ],
    { localName: "DataStream_Header" }
  ),
  DataStream_Chunk = proto3.makeMessageType(
    "livekit.DataStream.Chunk",
    () => [
      { no: 1, name: "stream_id", kind: "scalar", T: 9 },
      { no: 2, name: "chunk_index", kind: "scalar", T: 4 },
      { no: 3, name: "content", kind: "scalar", T: 12 },
      { no: 4, name: "version", kind: "scalar", T: 5 },
      { no: 5, name: "iv", kind: "scalar", T: 12, opt: !0 },
    ],
    { localName: "DataStream_Chunk" }
  ),
  DataStream_Trailer = proto3.makeMessageType(
    "livekit.DataStream.Trailer",
    () => [
      { no: 1, name: "stream_id", kind: "scalar", T: 9 },
      { no: 2, name: "reason", kind: "scalar", T: 9 },
      {
        no: 3,
        name: "attributes",
        kind: "map",
        K: 9,
        V: { kind: "scalar", T: 9 },
      },
    ],
    { localName: "DataStream_Trailer" }
  ),
  SignalTarget = proto3.makeEnum("livekit.SignalTarget", [
    { no: 0, name: "PUBLISHER" },
    { no: 1, name: "SUBSCRIBER" },
  ]),
  StreamState = proto3.makeEnum("livekit.StreamState", [
    { no: 0, name: "ACTIVE" },
    { no: 1, name: "PAUSED" },
  ]),
  CandidateProtocol = proto3.makeEnum("livekit.CandidateProtocol", [
    { no: 0, name: "UDP" },
    { no: 1, name: "TCP" },
    { no: 2, name: "TLS" },
  ]),
  SignalRequest = proto3.makeMessageType("livekit.SignalRequest", () => [
    {
      no: 1,
      name: "offer",
      kind: "message",
      T: SessionDescription,
      oneof: "message",
    },
    {
      no: 2,
      name: "answer",
      kind: "message",
      T: SessionDescription,
      oneof: "message",
    },
    {
      no: 3,
      name: "trickle",
      kind: "message",
      T: TrickleRequest,
      oneof: "message",
    },
    {
      no: 4,
      name: "add_track",
      kind: "message",
      T: AddTrackRequest,
      oneof: "message",
    },
    {
      no: 5,
      name: "mute",
      kind: "message",
      T: MuteTrackRequest,
      oneof: "message",
    },
    {
      no: 6,
      name: "subscription",
      kind: "message",
      T: UpdateSubscription,
      oneof: "message",
    },
    {
      no: 7,
      name: "track_setting",
      kind: "message",
      T: UpdateTrackSettings,
      oneof: "message",
    },
    {
      no: 8,
      name: "leave",
      kind: "message",
      T: LeaveRequest,
      oneof: "message",
    },
    {
      no: 10,
      name: "update_layers",
      kind: "message",
      T: UpdateVideoLayers,
      oneof: "message",
    },
    {
      no: 11,
      name: "subscription_permission",
      kind: "message",
      T: SubscriptionPermission,
      oneof: "message",
    },
    {
      no: 12,
      name: "sync_state",
      kind: "message",
      T: SyncState,
      oneof: "message",
    },
    {
      no: 13,
      name: "simulate",
      kind: "message",
      T: SimulateScenario,
      oneof: "message",
    },
    { no: 14, name: "ping", kind: "scalar", T: 3, oneof: "message" },
    {
      no: 15,
      name: "update_metadata",
      kind: "message",
      T: UpdateParticipantMetadata,
      oneof: "message",
    },
    { no: 16, name: "ping_req", kind: "message", T: Ping, oneof: "message" },
    {
      no: 17,
      name: "update_audio_track",
      kind: "message",
      T: UpdateLocalAudioTrack,
      oneof: "message",
    },
    {
      no: 18,
      name: "update_video_track",
      kind: "message",
      T: UpdateLocalVideoTrack,
      oneof: "message",
    },
  ]),
  SignalResponse = proto3.makeMessageType("livekit.SignalResponse", () => [
    { no: 1, name: "join", kind: "message", T: JoinResponse, oneof: "message" },
    {
      no: 2,
      name: "answer",
      kind: "message",
      T: SessionDescription,
      oneof: "message",
    },
    {
      no: 3,
      name: "offer",
      kind: "message",
      T: SessionDescription,
      oneof: "message",
    },
    {
      no: 4,
      name: "trickle",
      kind: "message",
      T: TrickleRequest,
      oneof: "message",
    },
    {
      no: 5,
      name: "update",
      kind: "message",
      T: ParticipantUpdate,
      oneof: "message",
    },
    {
      no: 6,
      name: "track_published",
      kind: "message",
      T: TrackPublishedResponse,
      oneof: "message",
    },
    {
      no: 8,
      name: "leave",
      kind: "message",
      T: LeaveRequest,
      oneof: "message",
    },
    {
      no: 9,
      name: "mute",
      kind: "message",
      T: MuteTrackRequest,
      oneof: "message",
    },
    {
      no: 10,
      name: "speakers_changed",
      kind: "message",
      T: SpeakersChanged,
      oneof: "message",
    },
    {
      no: 11,
      name: "room_update",
      kind: "message",
      T: RoomUpdate,
      oneof: "message",
    },
    {
      no: 12,
      name: "connection_quality",
      kind: "message",
      T: ConnectionQualityUpdate,
      oneof: "message",
    },
    {
      no: 13,
      name: "stream_state_update",
      kind: "message",
      T: StreamStateUpdate,
      oneof: "message",
    },
    {
      no: 14,
      name: "subscribed_quality_update",
      kind: "message",
      T: SubscribedQualityUpdate,
      oneof: "message",
    },
    {
      no: 15,
      name: "subscription_permission_update",
      kind: "message",
      T: SubscriptionPermissionUpdate,
      oneof: "message",
    },
    { no: 16, name: "refresh_token", kind: "scalar", T: 9, oneof: "message" },
    {
      no: 17,
      name: "track_unpublished",
      kind: "message",
      T: TrackUnpublishedResponse,
      oneof: "message",
    },
    { no: 18, name: "pong", kind: "scalar", T: 3, oneof: "message" },
    {
      no: 19,
      name: "reconnect",
      kind: "message",
      T: ReconnectResponse,
      oneof: "message",
    },
    { no: 20, name: "pong_resp", kind: "message", T: Pong, oneof: "message" },
    {
      no: 21,
      name: "subscription_response",
      kind: "message",
      T: SubscriptionResponse,
      oneof: "message",
    },
    {
      no: 22,
      name: "request_response",
      kind: "message",
      T: RequestResponse,
      oneof: "message",
    },
    {
      no: 23,
      name: "track_subscribed",
      kind: "message",
      T: TrackSubscribed,
      oneof: "message",
    },
  ]),
  SimulcastCodec = proto3.makeMessageType("livekit.SimulcastCodec", () => [
    { no: 1, name: "codec", kind: "scalar", T: 9 },
    { no: 2, name: "cid", kind: "scalar", T: 9 },
  ]),
  AddTrackRequest = proto3.makeMessageType("livekit.AddTrackRequest", () => [
    { no: 1, name: "cid", kind: "scalar", T: 9 },
    { no: 2, name: "name", kind: "scalar", T: 9 },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
    { no: 4, name: "width", kind: "scalar", T: 13 },
    { no: 5, name: "height", kind: "scalar", T: 13 },
    { no: 6, name: "muted", kind: "scalar", T: 8 },
    { no: 7, name: "disable_dtx", kind: "scalar", T: 8 },
    { no: 8, name: "source", kind: "enum", T: proto3.getEnumType(TrackSource) },
    { no: 9, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
    {
      no: 10,
      name: "simulcast_codecs",
      kind: "message",
      T: SimulcastCodec,
      repeated: !0,
    },
    { no: 11, name: "sid", kind: "scalar", T: 9 },
    { no: 12, name: "stereo", kind: "scalar", T: 8 },
    { no: 13, name: "disable_red", kind: "scalar", T: 8 },
    {
      no: 14,
      name: "encryption",
      kind: "enum",
      T: proto3.getEnumType(Encryption_Type),
    },
    { no: 15, name: "stream", kind: "scalar", T: 9 },
    {
      no: 16,
      name: "backup_codec_policy",
      kind: "enum",
      T: proto3.getEnumType(BackupCodecPolicy$1),
    },
  ]),
  TrickleRequest = proto3.makeMessageType("livekit.TrickleRequest", () => [
    { no: 1, name: "candidateInit", kind: "scalar", T: 9 },
    {
      no: 2,
      name: "target",
      kind: "enum",
      T: proto3.getEnumType(SignalTarget),
    },
    { no: 3, name: "final", kind: "scalar", T: 8 },
  ]),
  MuteTrackRequest = proto3.makeMessageType("livekit.MuteTrackRequest", () => [
    { no: 1, name: "sid", kind: "scalar", T: 9 },
    { no: 2, name: "muted", kind: "scalar", T: 8 },
  ]),
  JoinResponse = proto3.makeMessageType("livekit.JoinResponse", () => [
    { no: 1, name: "room", kind: "message", T: Room$1 },
    { no: 2, name: "participant", kind: "message", T: ParticipantInfo },
    {
      no: 3,
      name: "other_participants",
      kind: "message",
      T: ParticipantInfo,
      repeated: !0,
    },
    { no: 4, name: "server_version", kind: "scalar", T: 9 },
    { no: 5, name: "ice_servers", kind: "message", T: ICEServer, repeated: !0 },
    { no: 6, name: "subscriber_primary", kind: "scalar", T: 8 },
    { no: 7, name: "alternative_url", kind: "scalar", T: 9 },
    {
      no: 8,
      name: "client_configuration",
      kind: "message",
      T: ClientConfiguration,
    },
    { no: 9, name: "server_region", kind: "scalar", T: 9 },
    { no: 10, name: "ping_timeout", kind: "scalar", T: 5 },
    { no: 11, name: "ping_interval", kind: "scalar", T: 5 },
    { no: 12, name: "server_info", kind: "message", T: ServerInfo },
    { no: 13, name: "sif_trailer", kind: "scalar", T: 12 },
    {
      no: 14,
      name: "enabled_publish_codecs",
      kind: "message",
      T: Codec,
      repeated: !0,
    },
    { no: 15, name: "fast_publish", kind: "scalar", T: 8 },
  ]),
  ReconnectResponse = proto3.makeMessageType(
    "livekit.ReconnectResponse",
    () => [
      {
        no: 1,
        name: "ice_servers",
        kind: "message",
        T: ICEServer,
        repeated: !0,
      },
      {
        no: 2,
        name: "client_configuration",
        kind: "message",
        T: ClientConfiguration,
      },
    ]
  ),
  TrackPublishedResponse = proto3.makeMessageType(
    "livekit.TrackPublishedResponse",
    () => [
      { no: 1, name: "cid", kind: "scalar", T: 9 },
      { no: 2, name: "track", kind: "message", T: TrackInfo },
    ]
  ),
  TrackUnpublishedResponse = proto3.makeMessageType(
    "livekit.TrackUnpublishedResponse",
    () => [{ no: 1, name: "track_sid", kind: "scalar", T: 9 }]
  ),
  SessionDescription = proto3.makeMessageType(
    "livekit.SessionDescription",
    () => [
      { no: 1, name: "type", kind: "scalar", T: 9 },
      { no: 2, name: "sdp", kind: "scalar", T: 9 },
    ]
  ),
  ParticipantUpdate = proto3.makeMessageType(
    "livekit.ParticipantUpdate",
    () => [
      {
        no: 1,
        name: "participants",
        kind: "message",
        T: ParticipantInfo,
        repeated: !0,
      },
    ]
  ),
  UpdateSubscription = proto3.makeMessageType(
    "livekit.UpdateSubscription",
    () => [
      { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
      { no: 2, name: "subscribe", kind: "scalar", T: 8 },
      {
        no: 3,
        name: "participant_tracks",
        kind: "message",
        T: ParticipantTracks,
        repeated: !0,
      },
    ]
  ),
  UpdateTrackSettings = proto3.makeMessageType(
    "livekit.UpdateTrackSettings",
    () => [
      { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
      { no: 3, name: "disabled", kind: "scalar", T: 8 },
      {
        no: 4,
        name: "quality",
        kind: "enum",
        T: proto3.getEnumType(VideoQuality$1),
      },
      { no: 5, name: "width", kind: "scalar", T: 13 },
      { no: 6, name: "height", kind: "scalar", T: 13 },
      { no: 7, name: "fps", kind: "scalar", T: 13 },
      { no: 8, name: "priority", kind: "scalar", T: 13 },
    ]
  ),
  UpdateLocalAudioTrack = proto3.makeMessageType(
    "livekit.UpdateLocalAudioTrack",
    () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "features",
        kind: "enum",
        T: proto3.getEnumType(AudioTrackFeature),
        repeated: !0,
      },
    ]
  ),
  UpdateLocalVideoTrack = proto3.makeMessageType(
    "livekit.UpdateLocalVideoTrack",
    () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
      { no: 2, name: "width", kind: "scalar", T: 13 },
      { no: 3, name: "height", kind: "scalar", T: 13 },
    ]
  ),
  LeaveRequest = proto3.makeMessageType("livekit.LeaveRequest", () => [
    { no: 1, name: "can_reconnect", kind: "scalar", T: 8 },
    {
      no: 2,
      name: "reason",
      kind: "enum",
      T: proto3.getEnumType(DisconnectReason),
    },
    {
      no: 3,
      name: "action",
      kind: "enum",
      T: proto3.getEnumType(LeaveRequest_Action),
    },
    { no: 4, name: "regions", kind: "message", T: RegionSettings },
  ]),
  LeaveRequest_Action = proto3.makeEnum("livekit.LeaveRequest.Action", [
    { no: 0, name: "DISCONNECT" },
    { no: 1, name: "RESUME" },
    { no: 2, name: "RECONNECT" },
  ]),
  UpdateVideoLayers = proto3.makeMessageType(
    "livekit.UpdateVideoLayers",
    () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
      { no: 2, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
    ]
  ),
  UpdateParticipantMetadata = proto3.makeMessageType(
    "livekit.UpdateParticipantMetadata",
    () => [
      { no: 1, name: "metadata", kind: "scalar", T: 9 },
      { no: 2, name: "name", kind: "scalar", T: 9 },
      {
        no: 3,
        name: "attributes",
        kind: "map",
        K: 9,
        V: { kind: "scalar", T: 9 },
      },
      { no: 4, name: "request_id", kind: "scalar", T: 13 },
    ]
  ),
  ICEServer = proto3.makeMessageType("livekit.ICEServer", () => [
    { no: 1, name: "urls", kind: "scalar", T: 9, repeated: !0 },
    { no: 2, name: "username", kind: "scalar", T: 9 },
    { no: 3, name: "credential", kind: "scalar", T: 9 },
  ]),
  SpeakersChanged = proto3.makeMessageType("livekit.SpeakersChanged", () => [
    { no: 1, name: "speakers", kind: "message", T: SpeakerInfo, repeated: !0 },
  ]),
  RoomUpdate = proto3.makeMessageType("livekit.RoomUpdate", () => [
    { no: 1, name: "room", kind: "message", T: Room$1 },
  ]),
  ConnectionQualityInfo = proto3.makeMessageType(
    "livekit.ConnectionQualityInfo",
    () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "quality",
        kind: "enum",
        T: proto3.getEnumType(ConnectionQuality$1),
      },
      { no: 3, name: "score", kind: "scalar", T: 2 },
    ]
  ),
  ConnectionQualityUpdate = proto3.makeMessageType(
    "livekit.ConnectionQualityUpdate",
    () => [
      {
        no: 1,
        name: "updates",
        kind: "message",
        T: ConnectionQualityInfo,
        repeated: !0,
      },
    ]
  ),
  StreamStateInfo = proto3.makeMessageType("livekit.StreamStateInfo", () => [
    { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
    { no: 2, name: "track_sid", kind: "scalar", T: 9 },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(StreamState) },
  ]),
  StreamStateUpdate = proto3.makeMessageType(
    "livekit.StreamStateUpdate",
    () => [
      {
        no: 1,
        name: "stream_states",
        kind: "message",
        T: StreamStateInfo,
        repeated: !0,
      },
    ]
  ),
  SubscribedQuality = proto3.makeMessageType(
    "livekit.SubscribedQuality",
    () => [
      {
        no: 1,
        name: "quality",
        kind: "enum",
        T: proto3.getEnumType(VideoQuality$1),
      },
      { no: 2, name: "enabled", kind: "scalar", T: 8 },
    ]
  ),
  SubscribedCodec = proto3.makeMessageType("livekit.SubscribedCodec", () => [
    { no: 1, name: "codec", kind: "scalar", T: 9 },
    {
      no: 2,
      name: "qualities",
      kind: "message",
      T: SubscribedQuality,
      repeated: !0,
    },
  ]),
  SubscribedQualityUpdate = proto3.makeMessageType(
    "livekit.SubscribedQualityUpdate",
    () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "subscribed_qualities",
        kind: "message",
        T: SubscribedQuality,
        repeated: !0,
      },
      {
        no: 3,
        name: "subscribed_codecs",
        kind: "message",
        T: SubscribedCodec,
        repeated: !0,
      },
    ]
  ),
  TrackPermission = proto3.makeMessageType("livekit.TrackPermission", () => [
    { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
    { no: 2, name: "all_tracks", kind: "scalar", T: 8 },
    { no: 3, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
    { no: 4, name: "participant_identity", kind: "scalar", T: 9 },
  ]),
  SubscriptionPermission = proto3.makeMessageType(
    "livekit.SubscriptionPermission",
    () => [
      { no: 1, name: "all_participants", kind: "scalar", T: 8 },
      {
        no: 2,
        name: "track_permissions",
        kind: "message",
        T: TrackPermission,
        repeated: !0,
      },
    ]
  ),
  SubscriptionPermissionUpdate = proto3.makeMessageType(
    "livekit.SubscriptionPermissionUpdate",
    () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      { no: 2, name: "track_sid", kind: "scalar", T: 9 },
      { no: 3, name: "allowed", kind: "scalar", T: 8 },
    ]
  ),
  SyncState = proto3.makeMessageType("livekit.SyncState", () => [
    { no: 1, name: "answer", kind: "message", T: SessionDescription },
    { no: 2, name: "subscription", kind: "message", T: UpdateSubscription },
    {
      no: 3,
      name: "publish_tracks",
      kind: "message",
      T: TrackPublishedResponse,
      repeated: !0,
    },
    {
      no: 4,
      name: "data_channels",
      kind: "message",
      T: DataChannelInfo,
      repeated: !0,
    },
    { no: 5, name: "offer", kind: "message", T: SessionDescription },
    { no: 6, name: "track_sids_disabled", kind: "scalar", T: 9, repeated: !0 },
  ]),
  DataChannelInfo = proto3.makeMessageType("livekit.DataChannelInfo", () => [
    { no: 1, name: "label", kind: "scalar", T: 9 },
    { no: 2, name: "id", kind: "scalar", T: 13 },
    {
      no: 3,
      name: "target",
      kind: "enum",
      T: proto3.getEnumType(SignalTarget),
    },
  ]),
  SimulateScenario = proto3.makeMessageType("livekit.SimulateScenario", () => [
    { no: 1, name: "speaker_update", kind: "scalar", T: 5, oneof: "scenario" },
    { no: 2, name: "node_failure", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 3, name: "migration", kind: "scalar", T: 8, oneof: "scenario" },
    { no: 4, name: "server_leave", kind: "scalar", T: 8, oneof: "scenario" },
    {
      no: 5,
      name: "switch_candidate_protocol",
      kind: "enum",
      T: proto3.getEnumType(CandidateProtocol),
      oneof: "scenario",
    },
    {
      no: 6,
      name: "subscriber_bandwidth",
      kind: "scalar",
      T: 3,
      oneof: "scenario",
    },
    {
      no: 7,
      name: "disconnect_signal_on_resume",
      kind: "scalar",
      T: 8,
      oneof: "scenario",
    },
    {
      no: 8,
      name: "disconnect_signal_on_resume_no_messages",
      kind: "scalar",
      T: 8,
      oneof: "scenario",
    },
    {
      no: 9,
      name: "leave_request_full_reconnect",
      kind: "scalar",
      T: 8,
      oneof: "scenario",
    },
  ]),
  Ping = proto3.makeMessageType("livekit.Ping", () => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 },
    { no: 2, name: "rtt", kind: "scalar", T: 3 },
  ]),
  Pong = proto3.makeMessageType("livekit.Pong", () => [
    { no: 1, name: "last_ping_timestamp", kind: "scalar", T: 3 },
    { no: 2, name: "timestamp", kind: "scalar", T: 3 },
  ]),
  RegionSettings = proto3.makeMessageType("livekit.RegionSettings", () => [
    { no: 1, name: "regions", kind: "message", T: RegionInfo, repeated: !0 },
  ]),
  RegionInfo = proto3.makeMessageType("livekit.RegionInfo", () => [
    { no: 1, name: "region", kind: "scalar", T: 9 },
    { no: 2, name: "url", kind: "scalar", T: 9 },
    { no: 3, name: "distance", kind: "scalar", T: 3 },
  ]),
  SubscriptionResponse = proto3.makeMessageType(
    "livekit.SubscriptionResponse",
    () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "err",
        kind: "enum",
        T: proto3.getEnumType(SubscriptionError),
      },
    ]
  ),
  RequestResponse = proto3.makeMessageType("livekit.RequestResponse", () => [
    { no: 1, name: "request_id", kind: "scalar", T: 13 },
    {
      no: 2,
      name: "reason",
      kind: "enum",
      T: proto3.getEnumType(RequestResponse_Reason),
    },
    { no: 3, name: "message", kind: "scalar", T: 9 },
  ]),
  RequestResponse_Reason = proto3.makeEnum("livekit.RequestResponse.Reason", [
    { no: 0, name: "OK" },
    { no: 1, name: "NOT_FOUND" },
    { no: 2, name: "NOT_ALLOWED" },
    { no: 3, name: "LIMIT_EXCEEDED" },
  ]),
  TrackSubscribed = proto3.makeMessageType("livekit.TrackSubscribed", () => [
    { no: 1, name: "track_sid", kind: "scalar", T: 9 },
  ]);
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default")
    ? B.default
    : B;
}
var loglevel$1 = { exports: {} },
  loglevel = loglevel$1.exports,
  hasRequiredLoglevel;
function requireLoglevel() {
  return (
    hasRequiredLoglevel ||
      ((hasRequiredLoglevel = 1),
      (function (B) {
        (function (U, F) {
          B.exports ? (B.exports = F()) : (U.log = F());
        })(loglevel, function () {
          var U = function () {},
            F = "undefined",
            q =
              typeof window !== F &&
              typeof window.navigator !== F &&
              /Trident\/|MSIE /.test(window.navigator.userAgent),
            j = ["trace", "debug", "info", "warn", "error"],
            V = {},
            $ = null;
          function W(Z, se) {
            var ee = Z[se];
            if (typeof ee.bind == "function") return ee.bind(Z);
            try {
              return Function.prototype.bind.call(ee, Z);
            } catch {
              return function () {
                return Function.prototype.apply.apply(ee, [Z, arguments]);
              };
            }
          }
          function K() {
            console.log &&
              (console.log.apply
                ? console.log.apply(console, arguments)
                : Function.prototype.apply.apply(console.log, [
                    console,
                    arguments,
                  ])),
              console.trace && console.trace();
          }
          function G(Z) {
            return (
              Z === "debug" && (Z = "log"),
              typeof console === F
                ? !1
                : Z === "trace" && q
                ? K
                : console[Z] !== void 0
                ? W(console, Z)
                : console.log !== void 0
                ? W(console, "log")
                : U
            );
          }
          function H() {
            for (var Z = this.getLevel(), se = 0; se < j.length; se++) {
              var ee = j[se];
              this[ee] = se < Z ? U : this.methodFactory(ee, Z, this.name);
            }
            if (
              ((this.log = this.debug),
              typeof console === F && Z < this.levels.SILENT)
            )
              return "No console available for logging";
          }
          function Q(Z) {
            return function () {
              typeof console !== F &&
                (H.call(this), this[Z].apply(this, arguments));
            };
          }
          function z(Z, se, ee) {
            return G(Z) || Q.apply(this, arguments);
          }
          function Y(Z, se) {
            var ee = this,
              ie,
              re,
              te,
              ne = "loglevel";
            typeof Z == "string"
              ? (ne += ":" + Z)
              : typeof Z == "symbol" && (ne = void 0);
            function oe(pe) {
              var Te = (j[pe] || "silent").toUpperCase();
              if (!(typeof window === F || !ne)) {
                try {
                  window.localStorage[ne] = Te;
                  return;
                } catch {}
                try {
                  window.document.cookie =
                    encodeURIComponent(ne) + "=" + Te + ";";
                } catch {}
              }
            }
            function ce() {
              var pe;
              if (!(typeof window === F || !ne)) {
                try {
                  pe = window.localStorage[ne];
                } catch {}
                if (typeof pe === F)
                  try {
                    var Te = window.document.cookie,
                      Pe = encodeURIComponent(ne),
                      ye = Te.indexOf(Pe + "=");
                    ye !== -1 &&
                      (pe = /^([^;]+)/.exec(Te.slice(ye + Pe.length + 1))[1]);
                  } catch {}
                return ee.levels[pe] === void 0 && (pe = void 0), pe;
              }
            }
            function le() {
              if (!(typeof window === F || !ne)) {
                try {
                  window.localStorage.removeItem(ne);
                } catch {}
                try {
                  window.document.cookie =
                    encodeURIComponent(ne) +
                    "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
                } catch {}
              }
            }
            function he(pe) {
              var Te = pe;
              if (
                (typeof Te == "string" &&
                  ee.levels[Te.toUpperCase()] !== void 0 &&
                  (Te = ee.levels[Te.toUpperCase()]),
                typeof Te == "number" && Te >= 0 && Te <= ee.levels.SILENT)
              )
                return Te;
              throw new TypeError(
                "log.setLevel() called with invalid level: " + pe
              );
            }
            (ee.name = Z),
              (ee.levels = {
                TRACE: 0,
                DEBUG: 1,
                INFO: 2,
                WARN: 3,
                ERROR: 4,
                SILENT: 5,
              }),
              (ee.methodFactory = se || z),
              (ee.getLevel = function () {
                return te ?? re ?? ie;
              }),
              (ee.setLevel = function (pe, Te) {
                return (te = he(pe)), Te !== !1 && oe(te), H.call(ee);
              }),
              (ee.setDefaultLevel = function (pe) {
                (re = he(pe)), ce() || ee.setLevel(pe, !1);
              }),
              (ee.resetLevel = function () {
                (te = null), le(), H.call(ee);
              }),
              (ee.enableAll = function (pe) {
                ee.setLevel(ee.levels.TRACE, pe);
              }),
              (ee.disableAll = function (pe) {
                ee.setLevel(ee.levels.SILENT, pe);
              }),
              (ee.rebuild = function () {
                if (($ !== ee && (ie = he($.getLevel())), H.call(ee), $ === ee))
                  for (var pe in V) V[pe].rebuild();
              }),
              (ie = he($ ? $.getLevel() : "WARN"));
            var de = ce();
            de != null && (te = he(de)), H.call(ee);
          }
          ($ = new Y()),
            ($.getLogger = function (se) {
              if ((typeof se != "symbol" && typeof se != "string") || se === "")
                throw new TypeError(
                  "You must supply a name when creating a logger."
                );
              var ee = V[se];
              return ee || (ee = V[se] = new Y(se, $.methodFactory)), ee;
            });
          var X = typeof window !== F ? window.log : void 0;
          return (
            ($.noConflict = function () {
              return (
                typeof window !== F && window.log === $ && (window.log = X), $
              );
            }),
            ($.getLoggers = function () {
              return V;
            }),
            ($.default = $),
            $
          );
        });
      })(loglevel$1)),
    loglevel$1.exports
  );
}
var loglevelExports = requireLoglevel(),
  LogLevel;
(function (B) {
  (B[(B.trace = 0)] = "trace"),
    (B[(B.debug = 1)] = "debug"),
    (B[(B.info = 2)] = "info"),
    (B[(B.warn = 3)] = "warn"),
    (B[(B.error = 4)] = "error"),
    (B[(B.silent = 5)] = "silent");
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function (B) {
  (B.Default = "livekit"),
    (B.Room = "livekit-room"),
    (B.Participant = "livekit-participant"),
    (B.Track = "livekit-track"),
    (B.Publication = "livekit-track-publication"),
    (B.Engine = "livekit-engine"),
    (B.Signal = "livekit-signal"),
    (B.PCManager = "livekit-pc-manager"),
    (B.PCTransport = "livekit-pc-transport"),
    (B.E2EE = "lk-e2ee");
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports.getLogger("livekit");
Object.values(LoggerNames).map((B) => loglevelExports.getLogger(B));
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(B) {
  const U = loglevelExports.getLogger(B);
  return U.setDefaultLevel(livekitLogger.getLevel()), U;
}
const workerLogger = loglevelExports.getLogger("lk-e2ee"),
  maxRetryDelay = 7e3,
  DEFAULT_RETRY_DELAYS_IN_MS = [
    0,
    300,
    2 * 2 * 300,
    3 * 3 * 300,
    4 * 4 * 300,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
    maxRetryDelay,
  ];
class DefaultReconnectPolicy {
  constructor(U) {
    this._retryDelays = U !== void 0 ? [...U] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(U) {
    if (U.retryCount >= this._retryDelays.length) return null;
    const F = this._retryDelays[U.retryCount];
    return U.retryCount <= 1 ? F : F + Math.random() * 1e3;
  }
}
function __rest(B, U) {
  var F = {};
  for (var q in B)
    Object.prototype.hasOwnProperty.call(B, q) &&
      U.indexOf(q) < 0 &&
      (F[q] = B[q]);
  if (B != null && typeof Object.getOwnPropertySymbols == "function")
    for (var j = 0, q = Object.getOwnPropertySymbols(B); j < q.length; j++)
      U.indexOf(q[j]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(B, q[j]) &&
        (F[q[j]] = B[q[j]]);
  return F;
}
function __awaiter$b(B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
}
function __values(B) {
  var U = typeof Symbol == "function" && Symbol.iterator,
    F = U && B[U],
    q = 0;
  if (F) return F.call(B);
  if (B && typeof B.length == "number")
    return {
      next: function () {
        return (
          B && q >= B.length && (B = void 0), { value: B && B[q++], done: !B }
        );
      },
    };
  throw new TypeError(
    U ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function __asyncValues(B) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var U = B[Symbol.asyncIterator],
    F;
  return U
    ? U.call(B)
    : ((B = typeof __values == "function" ? __values(B) : B[Symbol.iterator]()),
      (F = {}),
      q("next"),
      q("throw"),
      q("return"),
      (F[Symbol.asyncIterator] = function () {
        return this;
      }),
      F);
  function q(V) {
    F[V] =
      B[V] &&
      function ($) {
        return new Promise(function (W, K) {
          ($ = B[V]($)), j(W, K, $.done, $.value);
        });
      };
  }
  function j(V, $, W, K) {
    Promise.resolve(K).then(function (G) {
      V({ value: G, done: W });
    }, $);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events$1 = { exports: {} },
  hasRequiredEvents$1;
function requireEvents$1() {
  if (hasRequiredEvents$1) return events$1.exports;
  hasRequiredEvents$1 = 1;
  var B = typeof Reflect == "object" ? Reflect : null,
    U =
      B && typeof B.apply == "function"
        ? B.apply
        : function (ne, oe, ce) {
            return Function.prototype.apply.call(ne, oe, ce);
          },
    F;
  B && typeof B.ownKeys == "function"
    ? (F = B.ownKeys)
    : Object.getOwnPropertySymbols
    ? (F = function (ne) {
        return Object.getOwnPropertyNames(ne).concat(
          Object.getOwnPropertySymbols(ne)
        );
      })
    : (F = function (ne) {
        return Object.getOwnPropertyNames(ne);
      });
  function q(te) {
    console && console.warn && console.warn(te);
  }
  var j =
    Number.isNaN ||
    function (ne) {
      return ne !== ne;
    };
  function V() {
    V.init.call(this);
  }
  (events$1.exports = V),
    (events$1.exports.once = ee),
    (V.EventEmitter = V),
    (V.prototype._events = void 0),
    (V.prototype._eventsCount = 0),
    (V.prototype._maxListeners = void 0);
  var $ = 10;
  function W(te) {
    if (typeof te != "function")
      throw new TypeError(
        'The "listener" argument must be of type Function. Received type ' +
          typeof te
      );
  }
  Object.defineProperty(V, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
      return $;
    },
    set: function (te) {
      if (typeof te != "number" || te < 0 || j(te))
        throw new RangeError(
          'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
            te +
            "."
        );
      $ = te;
    },
  }),
    (V.init = function () {
      (this._events === void 0 ||
        this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0);
    }),
    (V.prototype.setMaxListeners = function (ne) {
      if (typeof ne != "number" || ne < 0 || j(ne))
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            ne +
            "."
        );
      return (this._maxListeners = ne), this;
    });
  function K(te) {
    return te._maxListeners === void 0
      ? V.defaultMaxListeners
      : te._maxListeners;
  }
  (V.prototype.getMaxListeners = function () {
    return K(this);
  }),
    (V.prototype.emit = function (ne) {
      for (var oe = [], ce = 1; ce < arguments.length; ce++)
        oe.push(arguments[ce]);
      var le = ne === "error",
        he = this._events;
      if (he !== void 0) le = le && he.error === void 0;
      else if (!le) return !1;
      if (le) {
        var de;
        if ((oe.length > 0 && (de = oe[0]), de instanceof Error)) throw de;
        var pe = new Error(
          "Unhandled error." + (de ? " (" + de.message + ")" : "")
        );
        throw ((pe.context = de), pe);
      }
      var Te = he[ne];
      if (Te === void 0) return !1;
      if (typeof Te == "function") U(Te, this, oe);
      else
        for (var Pe = Te.length, ye = X(Te, Pe), ce = 0; ce < Pe; ++ce)
          U(ye[ce], this, oe);
      return !0;
    });
  function G(te, ne, oe, ce) {
    var le, he, de;
    if (
      (W(oe),
      (he = te._events),
      he === void 0
        ? ((he = te._events = Object.create(null)), (te._eventsCount = 0))
        : (he.newListener !== void 0 &&
            (te.emit("newListener", ne, oe.listener ? oe.listener : oe),
            (he = te._events)),
          (de = he[ne])),
      de === void 0)
    )
      (de = he[ne] = oe), ++te._eventsCount;
    else if (
      (typeof de == "function"
        ? (de = he[ne] = ce ? [oe, de] : [de, oe])
        : ce
        ? de.unshift(oe)
        : de.push(oe),
      (le = K(te)),
      le > 0 && de.length > le && !de.warned)
    ) {
      de.warned = !0;
      var pe = new Error(
        "Possible EventEmitter memory leak detected. " +
          de.length +
          " " +
          String(ne) +
          " listeners added. Use emitter.setMaxListeners() to increase limit"
      );
      (pe.name = "MaxListenersExceededWarning"),
        (pe.emitter = te),
        (pe.type = ne),
        (pe.count = de.length),
        q(pe);
    }
    return te;
  }
  (V.prototype.addListener = function (ne, oe) {
    return G(this, ne, oe, !1);
  }),
    (V.prototype.on = V.prototype.addListener),
    (V.prototype.prependListener = function (ne, oe) {
      return G(this, ne, oe, !0);
    });
  function H() {
    if (!this.fired)
      return (
        this.target.removeListener(this.type, this.wrapFn),
        (this.fired = !0),
        arguments.length === 0
          ? this.listener.call(this.target)
          : this.listener.apply(this.target, arguments)
      );
  }
  function Q(te, ne, oe) {
    var ce = { fired: !1, wrapFn: void 0, target: te, type: ne, listener: oe },
      le = H.bind(ce);
    return (le.listener = oe), (ce.wrapFn = le), le;
  }
  (V.prototype.once = function (ne, oe) {
    return W(oe), this.on(ne, Q(this, ne, oe)), this;
  }),
    (V.prototype.prependOnceListener = function (ne, oe) {
      return W(oe), this.prependListener(ne, Q(this, ne, oe)), this;
    }),
    (V.prototype.removeListener = function (ne, oe) {
      var ce, le, he, de, pe;
      if ((W(oe), (le = this._events), le === void 0)) return this;
      if (((ce = le[ne]), ce === void 0)) return this;
      if (ce === oe || ce.listener === oe)
        --this._eventsCount === 0
          ? (this._events = Object.create(null))
          : (delete le[ne],
            le.removeListener &&
              this.emit("removeListener", ne, ce.listener || oe));
      else if (typeof ce != "function") {
        for (he = -1, de = ce.length - 1; de >= 0; de--)
          if (ce[de] === oe || ce[de].listener === oe) {
            (pe = ce[de].listener), (he = de);
            break;
          }
        if (he < 0) return this;
        he === 0 ? ce.shift() : Z(ce, he),
          ce.length === 1 && (le[ne] = ce[0]),
          le.removeListener !== void 0 &&
            this.emit("removeListener", ne, pe || oe);
      }
      return this;
    }),
    (V.prototype.off = V.prototype.removeListener),
    (V.prototype.removeAllListeners = function (ne) {
      var oe, ce, le;
      if (((ce = this._events), ce === void 0)) return this;
      if (ce.removeListener === void 0)
        return (
          arguments.length === 0
            ? ((this._events = Object.create(null)), (this._eventsCount = 0))
            : ce[ne] !== void 0 &&
              (--this._eventsCount === 0
                ? (this._events = Object.create(null))
                : delete ce[ne]),
          this
        );
      if (arguments.length === 0) {
        var he = Object.keys(ce),
          de;
        for (le = 0; le < he.length; ++le)
          (de = he[le]), de !== "removeListener" && this.removeAllListeners(de);
        return (
          this.removeAllListeners("removeListener"),
          (this._events = Object.create(null)),
          (this._eventsCount = 0),
          this
        );
      }
      if (((oe = ce[ne]), typeof oe == "function")) this.removeListener(ne, oe);
      else if (oe !== void 0)
        for (le = oe.length - 1; le >= 0; le--) this.removeListener(ne, oe[le]);
      return this;
    });
  function z(te, ne, oe) {
    var ce = te._events;
    if (ce === void 0) return [];
    var le = ce[ne];
    return le === void 0
      ? []
      : typeof le == "function"
      ? oe
        ? [le.listener || le]
        : [le]
      : oe
      ? se(le)
      : X(le, le.length);
  }
  (V.prototype.listeners = function (ne) {
    return z(this, ne, !0);
  }),
    (V.prototype.rawListeners = function (ne) {
      return z(this, ne, !1);
    }),
    (V.listenerCount = function (te, ne) {
      return typeof te.listenerCount == "function"
        ? te.listenerCount(ne)
        : Y.call(te, ne);
    }),
    (V.prototype.listenerCount = Y);
  function Y(te) {
    var ne = this._events;
    if (ne !== void 0) {
      var oe = ne[te];
      if (typeof oe == "function") return 1;
      if (oe !== void 0) return oe.length;
    }
    return 0;
  }
  V.prototype.eventNames = function () {
    return this._eventsCount > 0 ? F(this._events) : [];
  };
  function X(te, ne) {
    for (var oe = new Array(ne), ce = 0; ce < ne; ++ce) oe[ce] = te[ce];
    return oe;
  }
  function Z(te, ne) {
    for (; ne + 1 < te.length; ne++) te[ne] = te[ne + 1];
    te.pop();
  }
  function se(te) {
    for (var ne = new Array(te.length), oe = 0; oe < ne.length; ++oe)
      ne[oe] = te[oe].listener || te[oe];
    return ne;
  }
  function ee(te, ne) {
    return new Promise(function (oe, ce) {
      function le(de) {
        te.removeListener(ne, he), ce(de);
      }
      function he() {
        typeof te.removeListener == "function" &&
          te.removeListener("error", le),
          oe([].slice.call(arguments));
      }
      re(te, ne, he, { once: !0 }), ne !== "error" && ie(te, le, { once: !0 });
    });
  }
  function ie(te, ne, oe) {
    typeof te.on == "function" && re(te, "error", ne, oe);
  }
  function re(te, ne, oe, ce) {
    if (typeof te.on == "function") ce.once ? te.once(ne, oe) : te.on(ne, oe);
    else if (typeof te.addEventListener == "function")
      te.addEventListener(ne, function le(he) {
        ce.once && te.removeEventListener(ne, le), oe(he);
      });
    else
      throw new TypeError(
        'The "emitter" argument must be of type EventEmitter. Received type ' +
          typeof te
      );
  }
  return events$1.exports;
}
var eventsExports$1 = requireEvents$1();
let logDisabled_ = !0,
  deprecationWarnings_ = !0;
function extractVersion(B, U, F) {
  const q = B.match(U);
  return q && q.length >= F && parseInt(q[F], 10);
}
function wrapPeerConnectionEvent(B, U, F) {
  if (!B.RTCPeerConnection) return;
  const q = B.RTCPeerConnection.prototype,
    j = q.addEventListener;
  q.addEventListener = function ($, W) {
    if ($ !== U) return j.apply(this, arguments);
    const K = (G) => {
      const H = F(G);
      H && (W.handleEvent ? W.handleEvent(H) : W(H));
    };
    return (
      (this._eventMap = this._eventMap || {}),
      this._eventMap[U] || (this._eventMap[U] = new Map()),
      this._eventMap[U].set(W, K),
      j.apply(this, [$, K])
    );
  };
  const V = q.removeEventListener;
  (q.removeEventListener = function ($, W) {
    if ($ !== U || !this._eventMap || !this._eventMap[U])
      return V.apply(this, arguments);
    if (!this._eventMap[U].has(W)) return V.apply(this, arguments);
    const K = this._eventMap[U].get(W);
    return (
      this._eventMap[U].delete(W),
      this._eventMap[U].size === 0 && delete this._eventMap[U],
      Object.keys(this._eventMap).length === 0 && delete this._eventMap,
      V.apply(this, [$, K])
    );
  }),
    Object.defineProperty(q, "on" + U, {
      get() {
        return this["_on" + U];
      },
      set($) {
        this["_on" + U] &&
          (this.removeEventListener(U, this["_on" + U]),
          delete this["_on" + U]),
          $ && this.addEventListener(U, (this["_on" + U] = $));
      },
      enumerable: !0,
      configurable: !0,
    });
}
function disableLog(B) {
  return typeof B != "boolean"
    ? new Error("Argument type: " + typeof B + ". Please use a boolean.")
    : ((logDisabled_ = B),
      B ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(B) {
  return typeof B != "boolean"
    ? new Error("Argument type: " + typeof B + ". Please use a boolean.")
    : ((deprecationWarnings_ = !B),
      "adapter.js deprecation warnings " + (B ? "disabled" : "enabled"));
}
function log() {
  if (typeof window == "object") {
    if (logDisabled_) return;
    typeof console < "u" &&
      typeof console.log == "function" &&
      console.log.apply(console, arguments);
  }
}
function deprecated(B, U) {
  deprecationWarnings_ &&
    console.warn(B + " is deprecated, please use " + U + " instead.");
}
function detectBrowser(B) {
  const U = { browser: null, version: null };
  if (typeof B > "u" || !B.navigator || !B.navigator.userAgent)
    return (U.browser = "Not a browser."), U;
  const { navigator: F } = B;
  if (F.userAgentData && F.userAgentData.brands) {
    const q = F.userAgentData.brands.find((j) => j.brand === "Chromium");
    if (q) return { browser: "chrome", version: parseInt(q.version, 10) };
  }
  if (F.mozGetUserMedia)
    (U.browser = "firefox"),
      (U.version = extractVersion(F.userAgent, /Firefox\/(\d+)\./, 1));
  else if (
    F.webkitGetUserMedia ||
    (B.isSecureContext === !1 && B.webkitRTCPeerConnection)
  )
    (U.browser = "chrome"),
      (U.version = extractVersion(F.userAgent, /Chrom(e|ium)\/(\d+)\./, 2));
  else if (B.RTCPeerConnection && F.userAgent.match(/AppleWebKit\/(\d+)\./))
    (U.browser = "safari"),
      (U.version = extractVersion(F.userAgent, /AppleWebKit\/(\d+)\./, 1)),
      (U.supportsUnifiedPlan =
        B.RTCRtpTransceiver &&
        "currentDirection" in B.RTCRtpTransceiver.prototype);
  else return (U.browser = "Not a supported browser."), U;
  return U;
}
function isObject(B) {
  return Object.prototype.toString.call(B) === "[object Object]";
}
function compactObject(B) {
  return isObject(B)
    ? Object.keys(B).reduce(function (U, F) {
        const q = isObject(B[F]),
          j = q ? compactObject(B[F]) : B[F],
          V = q && !Object.keys(j).length;
        return j === void 0 || V ? U : Object.assign(U, { [F]: j });
      }, {})
    : B;
}
function walkStats(B, U, F) {
  !U ||
    F.has(U.id) ||
    (F.set(U.id, U),
    Object.keys(U).forEach((q) => {
      q.endsWith("Id")
        ? walkStats(B, B.get(U[q]), F)
        : q.endsWith("Ids") &&
          U[q].forEach((j) => {
            walkStats(B, B.get(j), F);
          });
    }));
}
function filterStats(B, U, F) {
  const q = F ? "outbound-rtp" : "inbound-rtp",
    j = new Map();
  if (U === null) return j;
  const V = [];
  return (
    B.forEach(($) => {
      $.type === "track" && $.trackIdentifier === U.id && V.push($);
    }),
    V.forEach(($) => {
      B.forEach((W) => {
        W.type === q && W.trackId === $.id && walkStats(B, W, j);
      });
    }),
    j
  );
}
const logging = log;
function shimGetUserMedia$2(B, U) {
  const F = B && B.navigator;
  if (!F.mediaDevices) return;
  const q = function (W) {
      if (typeof W != "object" || W.mandatory || W.optional) return W;
      const K = {};
      return (
        Object.keys(W).forEach((G) => {
          if (G === "require" || G === "advanced" || G === "mediaSource")
            return;
          const H = typeof W[G] == "object" ? W[G] : { ideal: W[G] };
          H.exact !== void 0 &&
            typeof H.exact == "number" &&
            (H.min = H.max = H.exact);
          const Q = function (z, Y) {
            return z
              ? z + Y.charAt(0).toUpperCase() + Y.slice(1)
              : Y === "deviceId"
              ? "sourceId"
              : Y;
          };
          if (H.ideal !== void 0) {
            K.optional = K.optional || [];
            let z = {};
            typeof H.ideal == "number"
              ? ((z[Q("min", G)] = H.ideal),
                K.optional.push(z),
                (z = {}),
                (z[Q("max", G)] = H.ideal),
                K.optional.push(z))
              : ((z[Q("", G)] = H.ideal), K.optional.push(z));
          }
          H.exact !== void 0 && typeof H.exact != "number"
            ? ((K.mandatory = K.mandatory || {}),
              (K.mandatory[Q("", G)] = H.exact))
            : ["min", "max"].forEach((z) => {
                H[z] !== void 0 &&
                  ((K.mandatory = K.mandatory || {}),
                  (K.mandatory[Q(z, G)] = H[z]));
              });
        }),
        W.advanced && (K.optional = (K.optional || []).concat(W.advanced)),
        K
      );
    },
    j = function (W, K) {
      if (U.version >= 61) return K(W);
      if (
        ((W = JSON.parse(JSON.stringify(W))), W && typeof W.audio == "object")
      ) {
        const G = function (H, Q, z) {
          Q in H && !(z in H) && ((H[z] = H[Q]), delete H[Q]);
        };
        (W = JSON.parse(JSON.stringify(W))),
          G(W.audio, "autoGainControl", "googAutoGainControl"),
          G(W.audio, "noiseSuppression", "googNoiseSuppression"),
          (W.audio = q(W.audio));
      }
      if (W && typeof W.video == "object") {
        let G = W.video.facingMode;
        G = G && (typeof G == "object" ? G : { ideal: G });
        const H = U.version < 66;
        if (
          G &&
          (G.exact === "user" ||
            G.exact === "environment" ||
            G.ideal === "user" ||
            G.ideal === "environment") &&
          !(
            F.mediaDevices.getSupportedConstraints &&
            F.mediaDevices.getSupportedConstraints().facingMode &&
            !H
          )
        ) {
          delete W.video.facingMode;
          let Q;
          if (
            (G.exact === "environment" || G.ideal === "environment"
              ? (Q = ["back", "rear"])
              : (G.exact === "user" || G.ideal === "user") && (Q = ["front"]),
            Q)
          )
            return F.mediaDevices.enumerateDevices().then((z) => {
              z = z.filter((X) => X.kind === "videoinput");
              let Y = z.find((X) =>
                Q.some((Z) => X.label.toLowerCase().includes(Z))
              );
              return (
                !Y && z.length && Q.includes("back") && (Y = z[z.length - 1]),
                Y &&
                  (W.video.deviceId = G.exact
                    ? { exact: Y.deviceId }
                    : { ideal: Y.deviceId }),
                (W.video = q(W.video)),
                logging("chrome: " + JSON.stringify(W)),
                K(W)
              );
            });
        }
        W.video = q(W.video);
      }
      return logging("chrome: " + JSON.stringify(W)), K(W);
    },
    V = function (W) {
      return U.version >= 64
        ? W
        : {
            name:
              {
                PermissionDeniedError: "NotAllowedError",
                PermissionDismissedError: "NotAllowedError",
                InvalidStateError: "NotAllowedError",
                DevicesNotFoundError: "NotFoundError",
                ConstraintNotSatisfiedError: "OverconstrainedError",
                TrackStartError: "NotReadableError",
                MediaDeviceFailedDueToShutdown: "NotAllowedError",
                MediaDeviceKillSwitchOn: "NotAllowedError",
                TabCaptureError: "AbortError",
                ScreenCaptureError: "AbortError",
                DeviceCaptureError: "AbortError",
              }[W.name] || W.name,
            message: W.message,
            constraint: W.constraint || W.constraintName,
            toString() {
              return this.name + (this.message && ": ") + this.message;
            },
          };
    },
    $ = function (W, K, G) {
      j(W, (H) => {
        F.webkitGetUserMedia(H, K, (Q) => {
          G && G(V(Q));
        });
      });
    };
  if (((F.getUserMedia = $.bind(F)), F.mediaDevices.getUserMedia)) {
    const W = F.mediaDevices.getUserMedia.bind(F.mediaDevices);
    F.mediaDevices.getUserMedia = function (K) {
      return j(K, (G) =>
        W(G).then(
          (H) => {
            if (
              (G.audio && !H.getAudioTracks().length) ||
              (G.video && !H.getVideoTracks().length)
            )
              throw (
                (H.getTracks().forEach((Q) => {
                  Q.stop();
                }),
                new DOMException("", "NotFoundError"))
              );
            return H;
          },
          (H) => Promise.reject(V(H))
        )
      );
    };
  }
}
function shimMediaStream(B) {
  B.MediaStream = B.MediaStream || B.webkitMediaStream;
}
function shimOnTrack$1(B) {
  if (
    typeof B == "object" &&
    B.RTCPeerConnection &&
    !("ontrack" in B.RTCPeerConnection.prototype)
  ) {
    Object.defineProperty(B.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(F) {
        this._ontrack && this.removeEventListener("track", this._ontrack),
          this.addEventListener("track", (this._ontrack = F));
      },
      enumerable: !0,
      configurable: !0,
    });
    const U = B.RTCPeerConnection.prototype.setRemoteDescription;
    B.RTCPeerConnection.prototype.setRemoteDescription = function () {
      return (
        this._ontrackpoly ||
          ((this._ontrackpoly = (q) => {
            q.stream.addEventListener("addtrack", (j) => {
              let V;
              B.RTCPeerConnection.prototype.getReceivers
                ? (V = this.getReceivers().find(
                    (W) => W.track && W.track.id === j.track.id
                  ))
                : (V = { track: j.track });
              const $ = new Event("track");
              ($.track = j.track),
                ($.receiver = V),
                ($.transceiver = { receiver: V }),
                ($.streams = [q.stream]),
                this.dispatchEvent($);
            }),
              q.stream.getTracks().forEach((j) => {
                let V;
                B.RTCPeerConnection.prototype.getReceivers
                  ? (V = this.getReceivers().find(
                      (W) => W.track && W.track.id === j.id
                    ))
                  : (V = { track: j });
                const $ = new Event("track");
                ($.track = j),
                  ($.receiver = V),
                  ($.transceiver = { receiver: V }),
                  ($.streams = [q.stream]),
                  this.dispatchEvent($);
              });
          }),
          this.addEventListener("addstream", this._ontrackpoly)),
        U.apply(this, arguments)
      );
    };
  } else
    wrapPeerConnectionEvent(
      B,
      "track",
      (U) => (
        U.transceiver ||
          Object.defineProperty(U, "transceiver", {
            value: { receiver: U.receiver },
          }),
        U
      )
    );
}
function shimGetSendersWithDtmf(B) {
  if (
    typeof B == "object" &&
    B.RTCPeerConnection &&
    !("getSenders" in B.RTCPeerConnection.prototype) &&
    "createDTMFSender" in B.RTCPeerConnection.prototype
  ) {
    const U = function (j, V) {
      return {
        track: V,
        get dtmf() {
          return (
            this._dtmf === void 0 &&
              (V.kind === "audio"
                ? (this._dtmf = j.createDTMFSender(V))
                : (this._dtmf = null)),
            this._dtmf
          );
        },
        _pc: j,
      };
    };
    if (!B.RTCPeerConnection.prototype.getSenders) {
      B.RTCPeerConnection.prototype.getSenders = function () {
        return (this._senders = this._senders || []), this._senders.slice();
      };
      const j = B.RTCPeerConnection.prototype.addTrack;
      B.RTCPeerConnection.prototype.addTrack = function (W, K) {
        let G = j.apply(this, arguments);
        return G || ((G = U(this, W)), this._senders.push(G)), G;
      };
      const V = B.RTCPeerConnection.prototype.removeTrack;
      B.RTCPeerConnection.prototype.removeTrack = function (W) {
        V.apply(this, arguments);
        const K = this._senders.indexOf(W);
        K !== -1 && this._senders.splice(K, 1);
      };
    }
    const F = B.RTCPeerConnection.prototype.addStream;
    B.RTCPeerConnection.prototype.addStream = function (V) {
      (this._senders = this._senders || []),
        F.apply(this, [V]),
        V.getTracks().forEach(($) => {
          this._senders.push(U(this, $));
        });
    };
    const q = B.RTCPeerConnection.prototype.removeStream;
    B.RTCPeerConnection.prototype.removeStream = function (V) {
      (this._senders = this._senders || []),
        q.apply(this, [V]),
        V.getTracks().forEach(($) => {
          const W = this._senders.find((K) => K.track === $);
          W && this._senders.splice(this._senders.indexOf(W), 1);
        });
    };
  } else if (
    typeof B == "object" &&
    B.RTCPeerConnection &&
    "getSenders" in B.RTCPeerConnection.prototype &&
    "createDTMFSender" in B.RTCPeerConnection.prototype &&
    B.RTCRtpSender &&
    !("dtmf" in B.RTCRtpSender.prototype)
  ) {
    const U = B.RTCPeerConnection.prototype.getSenders;
    (B.RTCPeerConnection.prototype.getSenders = function () {
      const q = U.apply(this, []);
      return q.forEach((j) => (j._pc = this)), q;
    }),
      Object.defineProperty(B.RTCRtpSender.prototype, "dtmf", {
        get() {
          return (
            this._dtmf === void 0 &&
              (this.track.kind === "audio"
                ? (this._dtmf = this._pc.createDTMFSender(this.track))
                : (this._dtmf = null)),
            this._dtmf
          );
        },
      });
  }
}
function shimSenderReceiverGetStats(B) {
  if (
    !(
      typeof B == "object" &&
      B.RTCPeerConnection &&
      B.RTCRtpSender &&
      B.RTCRtpReceiver
    )
  )
    return;
  if (!("getStats" in B.RTCRtpSender.prototype)) {
    const F = B.RTCPeerConnection.prototype.getSenders;
    F &&
      (B.RTCPeerConnection.prototype.getSenders = function () {
        const V = F.apply(this, []);
        return V.forEach(($) => ($._pc = this)), V;
      });
    const q = B.RTCPeerConnection.prototype.addTrack;
    q &&
      (B.RTCPeerConnection.prototype.addTrack = function () {
        const V = q.apply(this, arguments);
        return (V._pc = this), V;
      }),
      (B.RTCRtpSender.prototype.getStats = function () {
        const V = this;
        return this._pc.getStats().then(($) => filterStats($, V.track, !0));
      });
  }
  if (!("getStats" in B.RTCRtpReceiver.prototype)) {
    const F = B.RTCPeerConnection.prototype.getReceivers;
    F &&
      (B.RTCPeerConnection.prototype.getReceivers = function () {
        const j = F.apply(this, []);
        return j.forEach((V) => (V._pc = this)), j;
      }),
      wrapPeerConnectionEvent(
        B,
        "track",
        (q) => ((q.receiver._pc = q.srcElement), q)
      ),
      (B.RTCRtpReceiver.prototype.getStats = function () {
        const j = this;
        return this._pc.getStats().then((V) => filterStats(V, j.track, !1));
      });
  }
  if (
    !(
      "getStats" in B.RTCRtpSender.prototype &&
      "getStats" in B.RTCRtpReceiver.prototype
    )
  )
    return;
  const U = B.RTCPeerConnection.prototype.getStats;
  B.RTCPeerConnection.prototype.getStats = function () {
    if (arguments.length > 0 && arguments[0] instanceof B.MediaStreamTrack) {
      const q = arguments[0];
      let j, V, $;
      return (
        this.getSenders().forEach((W) => {
          W.track === q && (j ? ($ = !0) : (j = W));
        }),
        this.getReceivers().forEach(
          (W) => (W.track === q && (V ? ($ = !0) : (V = W)), W.track === q)
        ),
        $ || (j && V)
          ? Promise.reject(
              new DOMException(
                "There are more than one sender or receiver for the track.",
                "InvalidAccessError"
              )
            )
          : j
          ? j.getStats()
          : V
          ? V.getStats()
          : Promise.reject(
              new DOMException(
                "There is no sender or receiver for the track.",
                "InvalidAccessError"
              )
            )
      );
    }
    return U.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(B) {
  B.RTCPeerConnection.prototype.getLocalStreams = function () {
    return (
      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
      Object.keys(this._shimmedLocalStreams).map(
        ($) => this._shimmedLocalStreams[$][0]
      )
    );
  };
  const U = B.RTCPeerConnection.prototype.addTrack;
  B.RTCPeerConnection.prototype.addTrack = function ($, W) {
    if (!W) return U.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const K = U.apply(this, arguments);
    return (
      this._shimmedLocalStreams[W.id]
        ? this._shimmedLocalStreams[W.id].indexOf(K) === -1 &&
          this._shimmedLocalStreams[W.id].push(K)
        : (this._shimmedLocalStreams[W.id] = [W, K]),
      K
    );
  };
  const F = B.RTCPeerConnection.prototype.addStream;
  B.RTCPeerConnection.prototype.addStream = function ($) {
    (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
      $.getTracks().forEach((G) => {
        if (this.getSenders().find((Q) => Q.track === G))
          throw new DOMException("Track already exists.", "InvalidAccessError");
      });
    const W = this.getSenders();
    F.apply(this, arguments);
    const K = this.getSenders().filter((G) => W.indexOf(G) === -1);
    this._shimmedLocalStreams[$.id] = [$].concat(K);
  };
  const q = B.RTCPeerConnection.prototype.removeStream;
  B.RTCPeerConnection.prototype.removeStream = function ($) {
    return (
      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
      delete this._shimmedLocalStreams[$.id],
      q.apply(this, arguments)
    );
  };
  const j = B.RTCPeerConnection.prototype.removeTrack;
  B.RTCPeerConnection.prototype.removeTrack = function ($) {
    return (
      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
      $ &&
        Object.keys(this._shimmedLocalStreams).forEach((W) => {
          const K = this._shimmedLocalStreams[W].indexOf($);
          K !== -1 && this._shimmedLocalStreams[W].splice(K, 1),
            this._shimmedLocalStreams[W].length === 1 &&
              delete this._shimmedLocalStreams[W];
        }),
      j.apply(this, arguments)
    );
  };
}
function shimAddTrackRemoveTrack(B, U) {
  if (!B.RTCPeerConnection) return;
  if (B.RTCPeerConnection.prototype.addTrack && U.version >= 65)
    return shimAddTrackRemoveTrackWithNative(B);
  const F = B.RTCPeerConnection.prototype.getLocalStreams;
  B.RTCPeerConnection.prototype.getLocalStreams = function () {
    const H = F.apply(this);
    return (
      (this._reverseStreams = this._reverseStreams || {}),
      H.map((Q) => this._reverseStreams[Q.id])
    );
  };
  const q = B.RTCPeerConnection.prototype.addStream;
  B.RTCPeerConnection.prototype.addStream = function (H) {
    if (
      ((this._streams = this._streams || {}),
      (this._reverseStreams = this._reverseStreams || {}),
      H.getTracks().forEach((Q) => {
        if (this.getSenders().find((Y) => Y.track === Q))
          throw new DOMException("Track already exists.", "InvalidAccessError");
      }),
      !this._reverseStreams[H.id])
    ) {
      const Q = new B.MediaStream(H.getTracks());
      (this._streams[H.id] = Q), (this._reverseStreams[Q.id] = H), (H = Q);
    }
    q.apply(this, [H]);
  };
  const j = B.RTCPeerConnection.prototype.removeStream;
  (B.RTCPeerConnection.prototype.removeStream = function (H) {
    (this._streams = this._streams || {}),
      (this._reverseStreams = this._reverseStreams || {}),
      j.apply(this, [this._streams[H.id] || H]),
      delete this._reverseStreams[
        this._streams[H.id] ? this._streams[H.id].id : H.id
      ],
      delete this._streams[H.id];
  }),
    (B.RTCPeerConnection.prototype.addTrack = function (H, Q) {
      if (this.signalingState === "closed")
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          "InvalidStateError"
        );
      const z = [].slice.call(arguments, 1);
      if (z.length !== 1 || !z[0].getTracks().find((Z) => Z === H))
        throw new DOMException(
          "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
          "NotSupportedError"
        );
      if (this.getSenders().find((Z) => Z.track === H))
        throw new DOMException("Track already exists.", "InvalidAccessError");
      (this._streams = this._streams || {}),
        (this._reverseStreams = this._reverseStreams || {});
      const X = this._streams[Q.id];
      if (X)
        X.addTrack(H),
          Promise.resolve().then(() => {
            this.dispatchEvent(new Event("negotiationneeded"));
          });
      else {
        const Z = new B.MediaStream([H]);
        (this._streams[Q.id] = Z),
          (this._reverseStreams[Z.id] = Q),
          this.addStream(Z);
      }
      return this.getSenders().find((Z) => Z.track === H);
    });
  function V(G, H) {
    let Q = H.sdp;
    return (
      Object.keys(G._reverseStreams || []).forEach((z) => {
        const Y = G._reverseStreams[z],
          X = G._streams[Y.id];
        Q = Q.replace(new RegExp(X.id, "g"), Y.id);
      }),
      new RTCSessionDescription({ type: H.type, sdp: Q })
    );
  }
  function $(G, H) {
    let Q = H.sdp;
    return (
      Object.keys(G._reverseStreams || []).forEach((z) => {
        const Y = G._reverseStreams[z],
          X = G._streams[Y.id];
        Q = Q.replace(new RegExp(Y.id, "g"), X.id);
      }),
      new RTCSessionDescription({ type: H.type, sdp: Q })
    );
  }
  ["createOffer", "createAnswer"].forEach(function (G) {
    const H = B.RTCPeerConnection.prototype[G],
      Q = {
        [G]() {
          const z = arguments;
          return arguments.length && typeof arguments[0] == "function"
            ? H.apply(this, [
                (X) => {
                  const Z = V(this, X);
                  z[0].apply(null, [Z]);
                },
                (X) => {
                  z[1] && z[1].apply(null, X);
                },
                arguments[2],
              ])
            : H.apply(this, arguments).then((X) => V(this, X));
        },
      };
    B.RTCPeerConnection.prototype[G] = Q[G];
  });
  const W = B.RTCPeerConnection.prototype.setLocalDescription;
  B.RTCPeerConnection.prototype.setLocalDescription = function () {
    return !arguments.length || !arguments[0].type
      ? W.apply(this, arguments)
      : ((arguments[0] = $(this, arguments[0])), W.apply(this, arguments));
  };
  const K = Object.getOwnPropertyDescriptor(
    B.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(B.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const G = K.get.apply(this);
      return G.type === "" ? G : V(this, G);
    },
  }),
    (B.RTCPeerConnection.prototype.removeTrack = function (H) {
      if (this.signalingState === "closed")
        throw new DOMException(
          "The RTCPeerConnection's signalingState is 'closed'.",
          "InvalidStateError"
        );
      if (!H._pc)
        throw new DOMException(
          "Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.",
          "TypeError"
        );
      if (!(H._pc === this))
        throw new DOMException(
          "Sender was not created by this connection.",
          "InvalidAccessError"
        );
      this._streams = this._streams || {};
      let z;
      Object.keys(this._streams).forEach((Y) => {
        this._streams[Y].getTracks().find((Z) => H.track === Z) &&
          (z = this._streams[Y]);
      }),
        z &&
          (z.getTracks().length === 1
            ? this.removeStream(this._reverseStreams[z.id])
            : z.removeTrack(H.track),
          this.dispatchEvent(new Event("negotiationneeded")));
    });
}
function shimPeerConnection$1(B, U) {
  !B.RTCPeerConnection &&
    B.webkitRTCPeerConnection &&
    (B.RTCPeerConnection = B.webkitRTCPeerConnection),
    B.RTCPeerConnection &&
      U.version < 53 &&
      [
        "setLocalDescription",
        "setRemoteDescription",
        "addIceCandidate",
      ].forEach(function (F) {
        const q = B.RTCPeerConnection.prototype[F],
          j = {
            [F]() {
              return (
                (arguments[0] = new (
                  F === "addIceCandidate"
                    ? B.RTCIceCandidate
                    : B.RTCSessionDescription
                )(arguments[0])),
                q.apply(this, arguments)
              );
            },
          };
        B.RTCPeerConnection.prototype[F] = j[F];
      });
}
function fixNegotiationNeeded(B, U) {
  wrapPeerConnectionEvent(B, "negotiationneeded", (F) => {
    const q = F.target;
    if (
      !(
        (U.version < 72 ||
          (q.getConfiguration &&
            q.getConfiguration().sdpSemantics === "plan-b")) &&
        q.signalingState !== "stable"
      )
    )
      return F;
  });
}
var chromeShim = Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetSendersWithDtmf,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats,
});
function shimGetUserMedia$1(B, U) {
  const F = B && B.navigator,
    q = B && B.MediaStreamTrack;
  if (
    ((F.getUserMedia = function (j, V, $) {
      deprecated(
        "navigator.getUserMedia",
        "navigator.mediaDevices.getUserMedia"
      ),
        F.mediaDevices.getUserMedia(j).then(V, $);
    }),
    !(
      U.version > 55 &&
      "autoGainControl" in F.mediaDevices.getSupportedConstraints()
    ))
  ) {
    const j = function ($, W, K) {
        W in $ && !(K in $) && (($[K] = $[W]), delete $[W]);
      },
      V = F.mediaDevices.getUserMedia.bind(F.mediaDevices);
    if (
      ((F.mediaDevices.getUserMedia = function ($) {
        return (
          typeof $ == "object" &&
            typeof $.audio == "object" &&
            (($ = JSON.parse(JSON.stringify($))),
            j($.audio, "autoGainControl", "mozAutoGainControl"),
            j($.audio, "noiseSuppression", "mozNoiseSuppression")),
          V($)
        );
      }),
      q && q.prototype.getSettings)
    ) {
      const $ = q.prototype.getSettings;
      q.prototype.getSettings = function () {
        const W = $.apply(this, arguments);
        return (
          j(W, "mozAutoGainControl", "autoGainControl"),
          j(W, "mozNoiseSuppression", "noiseSuppression"),
          W
        );
      };
    }
    if (q && q.prototype.applyConstraints) {
      const $ = q.prototype.applyConstraints;
      q.prototype.applyConstraints = function (W) {
        return (
          this.kind === "audio" &&
            typeof W == "object" &&
            ((W = JSON.parse(JSON.stringify(W))),
            j(W, "autoGainControl", "mozAutoGainControl"),
            j(W, "noiseSuppression", "mozNoiseSuppression")),
          $.apply(this, [W])
        );
      };
    }
  }
}
function shimGetDisplayMedia(B, U) {
  (B.navigator.mediaDevices && "getDisplayMedia" in B.navigator.mediaDevices) ||
    (B.navigator.mediaDevices &&
      (B.navigator.mediaDevices.getDisplayMedia = function (q) {
        if (!(q && q.video)) {
          const j = new DOMException(
            "getDisplayMedia without video constraints is undefined"
          );
          return (j.name = "NotFoundError"), (j.code = 8), Promise.reject(j);
        }
        return (
          q.video === !0
            ? (q.video = { mediaSource: U })
            : (q.video.mediaSource = U),
          B.navigator.mediaDevices.getUserMedia(q)
        );
      }));
}
function shimOnTrack(B) {
  typeof B == "object" &&
    B.RTCTrackEvent &&
    "receiver" in B.RTCTrackEvent.prototype &&
    !("transceiver" in B.RTCTrackEvent.prototype) &&
    Object.defineProperty(B.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      },
    });
}
function shimPeerConnection(B, U) {
  if (typeof B != "object" || !(B.RTCPeerConnection || B.mozRTCPeerConnection))
    return;
  !B.RTCPeerConnection &&
    B.mozRTCPeerConnection &&
    (B.RTCPeerConnection = B.mozRTCPeerConnection),
    U.version < 53 &&
      [
        "setLocalDescription",
        "setRemoteDescription",
        "addIceCandidate",
      ].forEach(function (j) {
        const V = B.RTCPeerConnection.prototype[j],
          $ = {
            [j]() {
              return (
                (arguments[0] = new (
                  j === "addIceCandidate"
                    ? B.RTCIceCandidate
                    : B.RTCSessionDescription
                )(arguments[0])),
                V.apply(this, arguments)
              );
            },
          };
        B.RTCPeerConnection.prototype[j] = $[j];
      });
  const F = {
      inboundrtp: "inbound-rtp",
      outboundrtp: "outbound-rtp",
      candidatepair: "candidate-pair",
      localcandidate: "local-candidate",
      remotecandidate: "remote-candidate",
    },
    q = B.RTCPeerConnection.prototype.getStats;
  B.RTCPeerConnection.prototype.getStats = function () {
    const [V, $, W] = arguments;
    return q
      .apply(this, [V || null])
      .then((K) => {
        if (U.version < 53 && !$)
          try {
            K.forEach((G) => {
              G.type = F[G.type] || G.type;
            });
          } catch (G) {
            if (G.name !== "TypeError") throw G;
            K.forEach((H, Q) => {
              K.set(Q, Object.assign({}, H, { type: F[H.type] || H.type }));
            });
          }
        return K;
      })
      .then($, W);
  };
}
function shimSenderGetStats(B) {
  if (
    !(typeof B == "object" && B.RTCPeerConnection && B.RTCRtpSender) ||
    (B.RTCRtpSender && "getStats" in B.RTCRtpSender.prototype)
  )
    return;
  const U = B.RTCPeerConnection.prototype.getSenders;
  U &&
    (B.RTCPeerConnection.prototype.getSenders = function () {
      const j = U.apply(this, []);
      return j.forEach((V) => (V._pc = this)), j;
    });
  const F = B.RTCPeerConnection.prototype.addTrack;
  F &&
    (B.RTCPeerConnection.prototype.addTrack = function () {
      const j = F.apply(this, arguments);
      return (j._pc = this), j;
    }),
    (B.RTCRtpSender.prototype.getStats = function () {
      return this.track
        ? this._pc.getStats(this.track)
        : Promise.resolve(new Map());
    });
}
function shimReceiverGetStats(B) {
  if (
    !(typeof B == "object" && B.RTCPeerConnection && B.RTCRtpSender) ||
    (B.RTCRtpSender && "getStats" in B.RTCRtpReceiver.prototype)
  )
    return;
  const U = B.RTCPeerConnection.prototype.getReceivers;
  U &&
    (B.RTCPeerConnection.prototype.getReceivers = function () {
      const q = U.apply(this, []);
      return q.forEach((j) => (j._pc = this)), q;
    }),
    wrapPeerConnectionEvent(
      B,
      "track",
      (F) => ((F.receiver._pc = F.srcElement), F)
    ),
    (B.RTCRtpReceiver.prototype.getStats = function () {
      return this._pc.getStats(this.track);
    });
}
function shimRemoveStream(B) {
  !B.RTCPeerConnection ||
    "removeStream" in B.RTCPeerConnection.prototype ||
    (B.RTCPeerConnection.prototype.removeStream = function (F) {
      deprecated("removeStream", "removeTrack"),
        this.getSenders().forEach((q) => {
          q.track && F.getTracks().includes(q.track) && this.removeTrack(q);
        });
    });
}
function shimRTCDataChannel(B) {
  B.DataChannel && !B.RTCDataChannel && (B.RTCDataChannel = B.DataChannel);
}
function shimAddTransceiver(B) {
  if (!(typeof B == "object" && B.RTCPeerConnection)) return;
  const U = B.RTCPeerConnection.prototype.addTransceiver;
  U &&
    (B.RTCPeerConnection.prototype.addTransceiver = function () {
      this.setParametersPromises = [];
      let q = arguments[1] && arguments[1].sendEncodings;
      q === void 0 && (q = []), (q = [...q]);
      const j = q.length > 0;
      j &&
        q.forEach(($) => {
          if ("rid" in $ && !/^[a-z0-9]{0,16}$/i.test($.rid))
            throw new TypeError("Invalid RID value provided.");
          if (
            "scaleResolutionDownBy" in $ &&
            !(parseFloat($.scaleResolutionDownBy) >= 1)
          )
            throw new RangeError("scale_resolution_down_by must be >= 1.0");
          if ("maxFramerate" in $ && !(parseFloat($.maxFramerate) >= 0))
            throw new RangeError("max_framerate must be >= 0.0");
        });
      const V = U.apply(this, arguments);
      if (j) {
        const { sender: $ } = V,
          W = $.getParameters();
        (!("encodings" in W) ||
          (W.encodings.length === 1 &&
            Object.keys(W.encodings[0]).length === 0)) &&
          ((W.encodings = q),
          ($.sendEncodings = q),
          this.setParametersPromises.push(
            $.setParameters(W)
              .then(() => {
                delete $.sendEncodings;
              })
              .catch(() => {
                delete $.sendEncodings;
              })
          ));
      }
      return V;
    });
}
function shimGetParameters(B) {
  if (!(typeof B == "object" && B.RTCRtpSender)) return;
  const U = B.RTCRtpSender.prototype.getParameters;
  U &&
    (B.RTCRtpSender.prototype.getParameters = function () {
      const q = U.apply(this, arguments);
      return (
        "encodings" in q ||
          (q.encodings = [].concat(this.sendEncodings || [{}])),
        q
      );
    });
}
function shimCreateOffer(B) {
  if (!(typeof B == "object" && B.RTCPeerConnection)) return;
  const U = B.RTCPeerConnection.prototype.createOffer;
  B.RTCPeerConnection.prototype.createOffer = function () {
    return this.setParametersPromises && this.setParametersPromises.length
      ? Promise.all(this.setParametersPromises)
          .then(() => U.apply(this, arguments))
          .finally(() => {
            this.setParametersPromises = [];
          })
      : U.apply(this, arguments);
  };
}
function shimCreateAnswer(B) {
  if (!(typeof B == "object" && B.RTCPeerConnection)) return;
  const U = B.RTCPeerConnection.prototype.createAnswer;
  B.RTCPeerConnection.prototype.createAnswer = function () {
    return this.setParametersPromises && this.setParametersPromises.length
      ? Promise.all(this.setParametersPromises)
          .then(() => U.apply(this, arguments))
          .finally(() => {
            this.setParametersPromises = [];
          })
      : U.apply(this, arguments);
  };
}
var firefoxShim = Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats,
});
function shimLocalStreamsAPI(B) {
  if (!(typeof B != "object" || !B.RTCPeerConnection)) {
    if (
      ("getLocalStreams" in B.RTCPeerConnection.prototype ||
        (B.RTCPeerConnection.prototype.getLocalStreams = function () {
          return (
            this._localStreams || (this._localStreams = []), this._localStreams
          );
        }),
      !("addStream" in B.RTCPeerConnection.prototype))
    ) {
      const U = B.RTCPeerConnection.prototype.addTrack;
      (B.RTCPeerConnection.prototype.addStream = function (q) {
        this._localStreams || (this._localStreams = []),
          this._localStreams.includes(q) || this._localStreams.push(q),
          q.getAudioTracks().forEach((j) => U.call(this, j, q)),
          q.getVideoTracks().forEach((j) => U.call(this, j, q));
      }),
        (B.RTCPeerConnection.prototype.addTrack = function (q) {
          for (
            var j = arguments.length, V = new Array(j > 1 ? j - 1 : 0), $ = 1;
            $ < j;
            $++
          )
            V[$ - 1] = arguments[$];
          return (
            V &&
              V.forEach((W) => {
                this._localStreams
                  ? this._localStreams.includes(W) || this._localStreams.push(W)
                  : (this._localStreams = [W]);
              }),
            U.apply(this, arguments)
          );
        });
    }
    "removeStream" in B.RTCPeerConnection.prototype ||
      (B.RTCPeerConnection.prototype.removeStream = function (F) {
        this._localStreams || (this._localStreams = []);
        const q = this._localStreams.indexOf(F);
        if (q === -1) return;
        this._localStreams.splice(q, 1);
        const j = F.getTracks();
        this.getSenders().forEach((V) => {
          j.includes(V.track) && this.removeTrack(V);
        });
      });
  }
}
function shimRemoteStreamsAPI(B) {
  if (
    !(typeof B != "object" || !B.RTCPeerConnection) &&
    ("getRemoteStreams" in B.RTCPeerConnection.prototype ||
      (B.RTCPeerConnection.prototype.getRemoteStreams = function () {
        return this._remoteStreams ? this._remoteStreams : [];
      }),
    !("onaddstream" in B.RTCPeerConnection.prototype))
  ) {
    Object.defineProperty(B.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(F) {
        this._onaddstream &&
          (this.removeEventListener("addstream", this._onaddstream),
          this.removeEventListener("track", this._onaddstreampoly)),
          this.addEventListener("addstream", (this._onaddstream = F)),
          this.addEventListener(
            "track",
            (this._onaddstreampoly = (q) => {
              q.streams.forEach((j) => {
                if (
                  (this._remoteStreams || (this._remoteStreams = []),
                  this._remoteStreams.includes(j))
                )
                  return;
                this._remoteStreams.push(j);
                const V = new Event("addstream");
                (V.stream = j), this.dispatchEvent(V);
              });
            })
          );
      },
    });
    const U = B.RTCPeerConnection.prototype.setRemoteDescription;
    B.RTCPeerConnection.prototype.setRemoteDescription = function () {
      const q = this;
      return (
        this._onaddstreampoly ||
          this.addEventListener(
            "track",
            (this._onaddstreampoly = function (j) {
              j.streams.forEach((V) => {
                if (
                  (q._remoteStreams || (q._remoteStreams = []),
                  q._remoteStreams.indexOf(V) >= 0)
                )
                  return;
                q._remoteStreams.push(V);
                const $ = new Event("addstream");
                ($.stream = V), q.dispatchEvent($);
              });
            })
          ),
        U.apply(q, arguments)
      );
    };
  }
}
function shimCallbacksAPI(B) {
  if (typeof B != "object" || !B.RTCPeerConnection) return;
  const U = B.RTCPeerConnection.prototype,
    F = U.createOffer,
    q = U.createAnswer,
    j = U.setLocalDescription,
    V = U.setRemoteDescription,
    $ = U.addIceCandidate;
  (U.createOffer = function (G, H) {
    const Q = arguments.length >= 2 ? arguments[2] : arguments[0],
      z = F.apply(this, [Q]);
    return H ? (z.then(G, H), Promise.resolve()) : z;
  }),
    (U.createAnswer = function (G, H) {
      const Q = arguments.length >= 2 ? arguments[2] : arguments[0],
        z = q.apply(this, [Q]);
      return H ? (z.then(G, H), Promise.resolve()) : z;
    });
  let W = function (K, G, H) {
    const Q = j.apply(this, [K]);
    return H ? (Q.then(G, H), Promise.resolve()) : Q;
  };
  (U.setLocalDescription = W),
    (W = function (K, G, H) {
      const Q = V.apply(this, [K]);
      return H ? (Q.then(G, H), Promise.resolve()) : Q;
    }),
    (U.setRemoteDescription = W),
    (W = function (K, G, H) {
      const Q = $.apply(this, [K]);
      return H ? (Q.then(G, H), Promise.resolve()) : Q;
    }),
    (U.addIceCandidate = W);
}
function shimGetUserMedia(B) {
  const U = B && B.navigator;
  if (U.mediaDevices && U.mediaDevices.getUserMedia) {
    const F = U.mediaDevices,
      q = F.getUserMedia.bind(F);
    U.mediaDevices.getUserMedia = (j) => q(shimConstraints(j));
  }
  !U.getUserMedia &&
    U.mediaDevices &&
    U.mediaDevices.getUserMedia &&
    (U.getUserMedia = function (q, j, V) {
      U.mediaDevices.getUserMedia(q).then(j, V);
    }.bind(U));
}
function shimConstraints(B) {
  return B && B.video !== void 0
    ? Object.assign({}, B, { video: compactObject(B.video) })
    : B;
}
function shimRTCIceServerUrls(B) {
  if (!B.RTCPeerConnection) return;
  const U = B.RTCPeerConnection;
  (B.RTCPeerConnection = function (q, j) {
    if (q && q.iceServers) {
      const V = [];
      for (let $ = 0; $ < q.iceServers.length; $++) {
        let W = q.iceServers[$];
        W.urls === void 0 && W.url
          ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"),
            (W = JSON.parse(JSON.stringify(W))),
            (W.urls = W.url),
            delete W.url,
            V.push(W))
          : V.push(q.iceServers[$]);
      }
      q.iceServers = V;
    }
    return new U(q, j);
  }),
    (B.RTCPeerConnection.prototype = U.prototype),
    "generateCertificate" in U &&
      Object.defineProperty(B.RTCPeerConnection, "generateCertificate", {
        get() {
          return U.generateCertificate;
        },
      });
}
function shimTrackEventTransceiver(B) {
  typeof B == "object" &&
    B.RTCTrackEvent &&
    "receiver" in B.RTCTrackEvent.prototype &&
    !("transceiver" in B.RTCTrackEvent.prototype) &&
    Object.defineProperty(B.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      },
    });
}
function shimCreateOfferLegacy(B) {
  const U = B.RTCPeerConnection.prototype.createOffer;
  B.RTCPeerConnection.prototype.createOffer = function (q) {
    if (q) {
      typeof q.offerToReceiveAudio < "u" &&
        (q.offerToReceiveAudio = !!q.offerToReceiveAudio);
      const j = this.getTransceivers().find(
        ($) => $.receiver.track.kind === "audio"
      );
      q.offerToReceiveAudio === !1 && j
        ? j.direction === "sendrecv"
          ? j.setDirection
            ? j.setDirection("sendonly")
            : (j.direction = "sendonly")
          : j.direction === "recvonly" &&
            (j.setDirection
              ? j.setDirection("inactive")
              : (j.direction = "inactive"))
        : q.offerToReceiveAudio === !0 &&
          !j &&
          this.addTransceiver("audio", { direction: "recvonly" }),
        typeof q.offerToReceiveVideo < "u" &&
          (q.offerToReceiveVideo = !!q.offerToReceiveVideo);
      const V = this.getTransceivers().find(
        ($) => $.receiver.track.kind === "video"
      );
      q.offerToReceiveVideo === !1 && V
        ? V.direction === "sendrecv"
          ? V.setDirection
            ? V.setDirection("sendonly")
            : (V.direction = "sendonly")
          : V.direction === "recvonly" &&
            (V.setDirection
              ? V.setDirection("inactive")
              : (V.direction = "inactive"))
        : q.offerToReceiveVideo === !0 &&
          !V &&
          this.addTransceiver("video", { direction: "recvonly" });
    }
    return U.apply(this, arguments);
  };
}
function shimAudioContext(B) {
  typeof B != "object" ||
    B.AudioContext ||
    (B.AudioContext = B.webkitAudioContext);
}
var safariShim = Object.freeze({
    __proto__: null,
    shimAudioContext,
    shimCallbacksAPI,
    shimConstraints,
    shimCreateOfferLegacy,
    shimGetUserMedia,
    shimLocalStreamsAPI,
    shimRTCIceServerUrls,
    shimRemoteStreamsAPI,
    shimTrackEventTransceiver,
  }),
  sdp$1 = { exports: {} },
  hasRequiredSdp;
function requireSdp() {
  return (
    hasRequiredSdp ||
      ((hasRequiredSdp = 1),
      (function (B) {
        const U = {};
        (U.generateIdentifier = function () {
          return Math.random().toString(36).substring(2, 12);
        }),
          (U.localCName = U.generateIdentifier()),
          (U.splitLines = function (F) {
            return F.trim()
              .split(
                `
`
              )
              .map((q) => q.trim());
          }),
          (U.splitSections = function (F) {
            return F.split(
              `
m=`
            ).map(
              (j, V) =>
                (V > 0 ? "m=" + j : j).trim() +
                `\r
`
            );
          }),
          (U.getDescription = function (F) {
            const q = U.splitSections(F);
            return q && q[0];
          }),
          (U.getMediaSections = function (F) {
            const q = U.splitSections(F);
            return q.shift(), q;
          }),
          (U.matchPrefix = function (F, q) {
            return U.splitLines(F).filter((j) => j.indexOf(q) === 0);
          }),
          (U.parseCandidate = function (F) {
            let q;
            F.indexOf("a=candidate:") === 0
              ? (q = F.substring(12).split(" "))
              : (q = F.substring(10).split(" "));
            const j = {
              foundation: q[0],
              component: { 1: "rtp", 2: "rtcp" }[q[1]] || q[1],
              protocol: q[2].toLowerCase(),
              priority: parseInt(q[3], 10),
              ip: q[4],
              address: q[4],
              port: parseInt(q[5], 10),
              type: q[7],
            };
            for (let V = 8; V < q.length; V += 2)
              switch (q[V]) {
                case "raddr":
                  j.relatedAddress = q[V + 1];
                  break;
                case "rport":
                  j.relatedPort = parseInt(q[V + 1], 10);
                  break;
                case "tcptype":
                  j.tcpType = q[V + 1];
                  break;
                case "ufrag":
                  (j.ufrag = q[V + 1]), (j.usernameFragment = q[V + 1]);
                  break;
                default:
                  j[q[V]] === void 0 && (j[q[V]] = q[V + 1]);
                  break;
              }
            return j;
          }),
          (U.writeCandidate = function (F) {
            const q = [];
            q.push(F.foundation);
            const j = F.component;
            j === "rtp" ? q.push(1) : j === "rtcp" ? q.push(2) : q.push(j),
              q.push(F.protocol.toUpperCase()),
              q.push(F.priority),
              q.push(F.address || F.ip),
              q.push(F.port);
            const V = F.type;
            return (
              q.push("typ"),
              q.push(V),
              V !== "host" &&
                F.relatedAddress &&
                F.relatedPort &&
                (q.push("raddr"),
                q.push(F.relatedAddress),
                q.push("rport"),
                q.push(F.relatedPort)),
              F.tcpType &&
                F.protocol.toLowerCase() === "tcp" &&
                (q.push("tcptype"), q.push(F.tcpType)),
              (F.usernameFragment || F.ufrag) &&
                (q.push("ufrag"), q.push(F.usernameFragment || F.ufrag)),
              "candidate:" + q.join(" ")
            );
          }),
          (U.parseIceOptions = function (F) {
            return F.substring(14).split(" ");
          }),
          (U.parseRtpMap = function (F) {
            let q = F.substring(9).split(" ");
            const j = { payloadType: parseInt(q.shift(), 10) };
            return (
              (q = q[0].split("/")),
              (j.name = q[0]),
              (j.clockRate = parseInt(q[1], 10)),
              (j.channels = q.length === 3 ? parseInt(q[2], 10) : 1),
              (j.numChannels = j.channels),
              j
            );
          }),
          (U.writeRtpMap = function (F) {
            let q = F.payloadType;
            F.preferredPayloadType !== void 0 && (q = F.preferredPayloadType);
            const j = F.channels || F.numChannels || 1;
            return (
              "a=rtpmap:" +
              q +
              " " +
              F.name +
              "/" +
              F.clockRate +
              (j !== 1 ? "/" + j : "") +
              `\r
`
            );
          }),
          (U.parseExtmap = function (F) {
            const q = F.substring(9).split(" ");
            return {
              id: parseInt(q[0], 10),
              direction:
                q[0].indexOf("/") > 0 ? q[0].split("/")[1] : "sendrecv",
              uri: q[1],
              attributes: q.slice(2).join(" "),
            };
          }),
          (U.writeExtmap = function (F) {
            return (
              "a=extmap:" +
              (F.id || F.preferredId) +
              (F.direction && F.direction !== "sendrecv"
                ? "/" + F.direction
                : "") +
              " " +
              F.uri +
              (F.attributes ? " " + F.attributes : "") +
              `\r
`
            );
          }),
          (U.parseFmtp = function (F) {
            const q = {};
            let j;
            const V = F.substring(F.indexOf(" ") + 1).split(";");
            for (let $ = 0; $ < V.length; $++)
              (j = V[$].trim().split("=")), (q[j[0].trim()] = j[1]);
            return q;
          }),
          (U.writeFmtp = function (F) {
            let q = "",
              j = F.payloadType;
            if (
              (F.preferredPayloadType !== void 0 &&
                (j = F.preferredPayloadType),
              F.parameters && Object.keys(F.parameters).length)
            ) {
              const V = [];
              Object.keys(F.parameters).forEach(($) => {
                F.parameters[$] !== void 0
                  ? V.push($ + "=" + F.parameters[$])
                  : V.push($);
              }),
                (q +=
                  "a=fmtp:" +
                  j +
                  " " +
                  V.join(";") +
                  `\r
`);
            }
            return q;
          }),
          (U.parseRtcpFb = function (F) {
            const q = F.substring(F.indexOf(" ") + 1).split(" ");
            return { type: q.shift(), parameter: q.join(" ") };
          }),
          (U.writeRtcpFb = function (F) {
            let q = "",
              j = F.payloadType;
            return (
              F.preferredPayloadType !== void 0 && (j = F.preferredPayloadType),
              F.rtcpFeedback &&
                F.rtcpFeedback.length &&
                F.rtcpFeedback.forEach((V) => {
                  q +=
                    "a=rtcp-fb:" +
                    j +
                    " " +
                    V.type +
                    (V.parameter && V.parameter.length
                      ? " " + V.parameter
                      : "") +
                    `\r
`;
                }),
              q
            );
          }),
          (U.parseSsrcMedia = function (F) {
            const q = F.indexOf(" "),
              j = { ssrc: parseInt(F.substring(7, q), 10) },
              V = F.indexOf(":", q);
            return (
              V > -1
                ? ((j.attribute = F.substring(q + 1, V)),
                  (j.value = F.substring(V + 1)))
                : (j.attribute = F.substring(q + 1)),
              j
            );
          }),
          (U.parseSsrcGroup = function (F) {
            const q = F.substring(13).split(" ");
            return {
              semantics: q.shift(),
              ssrcs: q.map((j) => parseInt(j, 10)),
            };
          }),
          (U.getMid = function (F) {
            const q = U.matchPrefix(F, "a=mid:")[0];
            if (q) return q.substring(6);
          }),
          (U.parseFingerprint = function (F) {
            const q = F.substring(14).split(" ");
            return { algorithm: q[0].toLowerCase(), value: q[1].toUpperCase() };
          }),
          (U.getDtlsParameters = function (F, q) {
            return {
              role: "auto",
              fingerprints: U.matchPrefix(F + q, "a=fingerprint:").map(
                U.parseFingerprint
              ),
            };
          }),
          (U.writeDtlsParameters = function (F, q) {
            let j =
              "a=setup:" +
              q +
              `\r
`;
            return (
              F.fingerprints.forEach((V) => {
                j +=
                  "a=fingerprint:" +
                  V.algorithm +
                  " " +
                  V.value +
                  `\r
`;
              }),
              j
            );
          }),
          (U.parseCryptoLine = function (F) {
            const q = F.substring(9).split(" ");
            return {
              tag: parseInt(q[0], 10),
              cryptoSuite: q[1],
              keyParams: q[2],
              sessionParams: q.slice(3),
            };
          }),
          (U.writeCryptoLine = function (F) {
            return (
              "a=crypto:" +
              F.tag +
              " " +
              F.cryptoSuite +
              " " +
              (typeof F.keyParams == "object"
                ? U.writeCryptoKeyParams(F.keyParams)
                : F.keyParams) +
              (F.sessionParams ? " " + F.sessionParams.join(" ") : "") +
              `\r
`
            );
          }),
          (U.parseCryptoKeyParams = function (F) {
            if (F.indexOf("inline:") !== 0) return null;
            const q = F.substring(7).split("|");
            return {
              keyMethod: "inline",
              keySalt: q[0],
              lifeTime: q[1],
              mkiValue: q[2] ? q[2].split(":")[0] : void 0,
              mkiLength: q[2] ? q[2].split(":")[1] : void 0,
            };
          }),
          (U.writeCryptoKeyParams = function (F) {
            return (
              F.keyMethod +
              ":" +
              F.keySalt +
              (F.lifeTime ? "|" + F.lifeTime : "") +
              (F.mkiValue && F.mkiLength
                ? "|" + F.mkiValue + ":" + F.mkiLength
                : "")
            );
          }),
          (U.getCryptoParameters = function (F, q) {
            return U.matchPrefix(F + q, "a=crypto:").map(U.parseCryptoLine);
          }),
          (U.getIceParameters = function (F, q) {
            const j = U.matchPrefix(F + q, "a=ice-ufrag:")[0],
              V = U.matchPrefix(F + q, "a=ice-pwd:")[0];
            return j && V
              ? { usernameFragment: j.substring(12), password: V.substring(10) }
              : null;
          }),
          (U.writeIceParameters = function (F) {
            let q =
              "a=ice-ufrag:" +
              F.usernameFragment +
              `\r
a=ice-pwd:` +
              F.password +
              `\r
`;
            return (
              F.iceLite &&
                (q += `a=ice-lite\r
`),
              q
            );
          }),
          (U.parseRtpParameters = function (F) {
            const q = {
                codecs: [],
                headerExtensions: [],
                fecMechanisms: [],
                rtcp: [],
              },
              V = U.splitLines(F)[0].split(" ");
            q.profile = V[2];
            for (let W = 3; W < V.length; W++) {
              const K = V[W],
                G = U.matchPrefix(F, "a=rtpmap:" + K + " ")[0];
              if (G) {
                const H = U.parseRtpMap(G),
                  Q = U.matchPrefix(F, "a=fmtp:" + K + " ");
                switch (
                  ((H.parameters = Q.length ? U.parseFmtp(Q[0]) : {}),
                  (H.rtcpFeedback = U.matchPrefix(
                    F,
                    "a=rtcp-fb:" + K + " "
                  ).map(U.parseRtcpFb)),
                  q.codecs.push(H),
                  H.name.toUpperCase())
                ) {
                  case "RED":
                  case "ULPFEC":
                    q.fecMechanisms.push(H.name.toUpperCase());
                    break;
                }
              }
            }
            U.matchPrefix(F, "a=extmap:").forEach((W) => {
              q.headerExtensions.push(U.parseExtmap(W));
            });
            const $ = U.matchPrefix(F, "a=rtcp-fb:* ").map(U.parseRtcpFb);
            return (
              q.codecs.forEach((W) => {
                $.forEach((K) => {
                  W.rtcpFeedback.find(
                    (H) => H.type === K.type && H.parameter === K.parameter
                  ) || W.rtcpFeedback.push(K);
                });
              }),
              q
            );
          }),
          (U.writeRtpDescription = function (F, q) {
            let j = "";
            (j += "m=" + F + " "),
              (j += q.codecs.length > 0 ? "9" : "0"),
              (j += " " + (q.profile || "UDP/TLS/RTP/SAVPF") + " "),
              (j +=
                q.codecs
                  .map(($) =>
                    $.preferredPayloadType !== void 0
                      ? $.preferredPayloadType
                      : $.payloadType
                  )
                  .join(" ") +
                `\r
`),
              (j += `c=IN IP4 0.0.0.0\r
`),
              (j += `a=rtcp:9 IN IP4 0.0.0.0\r
`),
              q.codecs.forEach(($) => {
                (j += U.writeRtpMap($)),
                  (j += U.writeFmtp($)),
                  (j += U.writeRtcpFb($));
              });
            let V = 0;
            return (
              q.codecs.forEach(($) => {
                $.maxptime > V && (V = $.maxptime);
              }),
              V > 0 &&
                (j +=
                  "a=maxptime:" +
                  V +
                  `\r
`),
              q.headerExtensions &&
                q.headerExtensions.forEach(($) => {
                  j += U.writeExtmap($);
                }),
              j
            );
          }),
          (U.parseRtpEncodingParameters = function (F) {
            const q = [],
              j = U.parseRtpParameters(F),
              V = j.fecMechanisms.indexOf("RED") !== -1,
              $ = j.fecMechanisms.indexOf("ULPFEC") !== -1,
              W = U.matchPrefix(F, "a=ssrc:")
                .map((z) => U.parseSsrcMedia(z))
                .filter((z) => z.attribute === "cname"),
              K = W.length > 0 && W[0].ssrc;
            let G;
            const H = U.matchPrefix(F, "a=ssrc-group:FID").map((z) =>
              z
                .substring(17)
                .split(" ")
                .map((X) => parseInt(X, 10))
            );
            H.length > 0 && H[0].length > 1 && H[0][0] === K && (G = H[0][1]),
              j.codecs.forEach((z) => {
                if (z.name.toUpperCase() === "RTX" && z.parameters.apt) {
                  let Y = {
                    ssrc: K,
                    codecPayloadType: parseInt(z.parameters.apt, 10),
                  };
                  K && G && (Y.rtx = { ssrc: G }),
                    q.push(Y),
                    V &&
                      ((Y = JSON.parse(JSON.stringify(Y))),
                      (Y.fec = {
                        ssrc: K,
                        mechanism: $ ? "red+ulpfec" : "red",
                      }),
                      q.push(Y));
                }
              }),
              q.length === 0 && K && q.push({ ssrc: K });
            let Q = U.matchPrefix(F, "b=");
            return (
              Q.length &&
                (Q[0].indexOf("b=TIAS:") === 0
                  ? (Q = parseInt(Q[0].substring(7), 10))
                  : Q[0].indexOf("b=AS:") === 0
                  ? (Q =
                      parseInt(Q[0].substring(5), 10) * 1e3 * 0.95 -
                      50 * 40 * 8)
                  : (Q = void 0),
                q.forEach((z) => {
                  z.maxBitrate = Q;
                })),
              q
            );
          }),
          (U.parseRtcpParameters = function (F) {
            const q = {},
              j = U.matchPrefix(F, "a=ssrc:")
                .map((W) => U.parseSsrcMedia(W))
                .filter((W) => W.attribute === "cname")[0];
            j && ((q.cname = j.value), (q.ssrc = j.ssrc));
            const V = U.matchPrefix(F, "a=rtcp-rsize");
            (q.reducedSize = V.length > 0), (q.compound = V.length === 0);
            const $ = U.matchPrefix(F, "a=rtcp-mux");
            return (q.mux = $.length > 0), q;
          }),
          (U.writeRtcpParameters = function (F) {
            let q = "";
            return (
              F.reducedSize &&
                (q += `a=rtcp-rsize\r
`),
              F.mux &&
                (q += `a=rtcp-mux\r
`),
              F.ssrc !== void 0 &&
                F.cname &&
                (q +=
                  "a=ssrc:" +
                  F.ssrc +
                  " cname:" +
                  F.cname +
                  `\r
`),
              q
            );
          }),
          (U.parseMsid = function (F) {
            let q;
            const j = U.matchPrefix(F, "a=msid:");
            if (j.length === 1)
              return (
                (q = j[0].substring(7).split(" ")),
                { stream: q[0], track: q[1] }
              );
            const V = U.matchPrefix(F, "a=ssrc:")
              .map(($) => U.parseSsrcMedia($))
              .filter(($) => $.attribute === "msid");
            if (V.length > 0)
              return (q = V[0].value.split(" ")), { stream: q[0], track: q[1] };
          }),
          (U.parseSctpDescription = function (F) {
            const q = U.parseMLine(F),
              j = U.matchPrefix(F, "a=max-message-size:");
            let V;
            j.length > 0 && (V = parseInt(j[0].substring(19), 10)),
              isNaN(V) && (V = 65536);
            const $ = U.matchPrefix(F, "a=sctp-port:");
            if ($.length > 0)
              return {
                port: parseInt($[0].substring(12), 10),
                protocol: q.fmt,
                maxMessageSize: V,
              };
            const W = U.matchPrefix(F, "a=sctpmap:");
            if (W.length > 0) {
              const K = W[0].substring(10).split(" ");
              return {
                port: parseInt(K[0], 10),
                protocol: K[1],
                maxMessageSize: V,
              };
            }
          }),
          (U.writeSctpDescription = function (F, q) {
            let j = [];
            return (
              F.protocol !== "DTLS/SCTP"
                ? (j = [
                    "m=" +
                      F.kind +
                      " 9 " +
                      F.protocol +
                      " " +
                      q.protocol +
                      `\r
`,
                    `c=IN IP4 0.0.0.0\r
`,
                    "a=sctp-port:" +
                      q.port +
                      `\r
`,
                  ])
                : (j = [
                    "m=" +
                      F.kind +
                      " 9 " +
                      F.protocol +
                      " " +
                      q.port +
                      `\r
`,
                    `c=IN IP4 0.0.0.0\r
`,
                    "a=sctpmap:" +
                      q.port +
                      " " +
                      q.protocol +
                      ` 65535\r
`,
                  ]),
              q.maxMessageSize !== void 0 &&
                j.push(
                  "a=max-message-size:" +
                    q.maxMessageSize +
                    `\r
`
                ),
              j.join("")
            );
          }),
          (U.generateSessionId = function () {
            return Math.random().toString().substr(2, 22);
          }),
          (U.writeSessionBoilerplate = function (F, q, j) {
            let V;
            const $ = q !== void 0 ? q : 2;
            return (
              F ? (V = F) : (V = U.generateSessionId()),
              `v=0\r
o=` +
                (j || "thisisadapterortc") +
                " " +
                V +
                " " +
                $ +
                ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`
            );
          }),
          (U.getDirection = function (F, q) {
            const j = U.splitLines(F);
            for (let V = 0; V < j.length; V++)
              switch (j[V]) {
                case "a=sendrecv":
                case "a=sendonly":
                case "a=recvonly":
                case "a=inactive":
                  return j[V].substring(2);
              }
            return q ? U.getDirection(q) : "sendrecv";
          }),
          (U.getKind = function (F) {
            return U.splitLines(F)[0].split(" ")[0].substring(2);
          }),
          (U.isRejected = function (F) {
            return F.split(" ", 2)[1] === "0";
          }),
          (U.parseMLine = function (F) {
            const j = U.splitLines(F)[0].substring(2).split(" ");
            return {
              kind: j[0],
              port: parseInt(j[1], 10),
              protocol: j[2],
              fmt: j.slice(3).join(" "),
            };
          }),
          (U.parseOLine = function (F) {
            const j = U.matchPrefix(F, "o=")[0].substring(2).split(" ");
            return {
              username: j[0],
              sessionId: j[1],
              sessionVersion: parseInt(j[2], 10),
              netType: j[3],
              addressType: j[4],
              address: j[5],
            };
          }),
          (U.isValidSDP = function (F) {
            if (typeof F != "string" || F.length === 0) return !1;
            const q = U.splitLines(F);
            for (let j = 0; j < q.length; j++)
              if (q[j].length < 2 || q[j].charAt(1) !== "=") return !1;
            return !0;
          }),
          (B.exports = U);
      })(sdp$1)),
    sdp$1.exports
  );
}
var sdpExports = requireSdp(),
  SDPUtils = getDefaultExportFromCjs$1(sdpExports),
  sdp = _mergeNamespaces$1({ __proto__: null, default: SDPUtils }, [
    sdpExports,
  ]);
function shimRTCIceCandidate(B) {
  if (
    !B.RTCIceCandidate ||
    (B.RTCIceCandidate && "foundation" in B.RTCIceCandidate.prototype)
  )
    return;
  const U = B.RTCIceCandidate;
  (B.RTCIceCandidate = function (q) {
    if (
      (typeof q == "object" &&
        q.candidate &&
        q.candidate.indexOf("a=") === 0 &&
        ((q = JSON.parse(JSON.stringify(q))),
        (q.candidate = q.candidate.substring(2))),
      q.candidate && q.candidate.length)
    ) {
      const j = new U(q),
        V = SDPUtils.parseCandidate(q.candidate);
      for (const $ in V) $ in j || Object.defineProperty(j, $, { value: V[$] });
      return (
        (j.toJSON = function () {
          return {
            candidate: j.candidate,
            sdpMid: j.sdpMid,
            sdpMLineIndex: j.sdpMLineIndex,
            usernameFragment: j.usernameFragment,
          };
        }),
        j
      );
    }
    return new U(q);
  }),
    (B.RTCIceCandidate.prototype = U.prototype),
    wrapPeerConnectionEvent(
      B,
      "icecandidate",
      (F) => (
        F.candidate &&
          Object.defineProperty(F, "candidate", {
            value: new B.RTCIceCandidate(F.candidate),
            writable: "false",
          }),
        F
      )
    );
}
function shimRTCIceCandidateRelayProtocol(B) {
  !B.RTCIceCandidate ||
    (B.RTCIceCandidate && "relayProtocol" in B.RTCIceCandidate.prototype) ||
    wrapPeerConnectionEvent(B, "icecandidate", (U) => {
      if (U.candidate) {
        const F = SDPUtils.parseCandidate(U.candidate.candidate);
        F.type === "relay" &&
          (U.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[
            F.priority >> 24
          ]);
      }
      return U;
    });
}
function shimMaxMessageSize(B, U) {
  if (!B.RTCPeerConnection) return;
  "sctp" in B.RTCPeerConnection.prototype ||
    Object.defineProperty(B.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp > "u" ? null : this._sctp;
      },
    });
  const F = function (W) {
      if (!W || !W.sdp) return !1;
      const K = SDPUtils.splitSections(W.sdp);
      return (
        K.shift(),
        K.some((G) => {
          const H = SDPUtils.parseMLine(G);
          return (
            H && H.kind === "application" && H.protocol.indexOf("SCTP") !== -1
          );
        })
      );
    },
    q = function (W) {
      const K = W.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (K === null || K.length < 2) return -1;
      const G = parseInt(K[1], 10);
      return G !== G ? -1 : G;
    },
    j = function (W) {
      let K = 65536;
      return (
        U.browser === "firefox" &&
          (U.version < 57
            ? W === -1
              ? (K = 16384)
              : (K = 2147483637)
            : U.version < 60
            ? (K = U.version === 57 ? 65535 : 65536)
            : (K = 2147483637)),
        K
      );
    },
    V = function (W, K) {
      let G = 65536;
      U.browser === "firefox" && U.version === 57 && (G = 65535);
      const H = SDPUtils.matchPrefix(W.sdp, "a=max-message-size:");
      return (
        H.length > 0
          ? (G = parseInt(H[0].substring(19), 10))
          : U.browser === "firefox" && K !== -1 && (G = 2147483637),
        G
      );
    },
    $ = B.RTCPeerConnection.prototype.setRemoteDescription;
  B.RTCPeerConnection.prototype.setRemoteDescription = function () {
    if (((this._sctp = null), U.browser === "chrome" && U.version >= 76)) {
      const { sdpSemantics: K } = this.getConfiguration();
      K === "plan-b" &&
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp > "u" ? null : this._sctp;
          },
          enumerable: !0,
          configurable: !0,
        });
    }
    if (F(arguments[0])) {
      const K = q(arguments[0]),
        G = j(K),
        H = V(arguments[0], K);
      let Q;
      G === 0 && H === 0
        ? (Q = Number.POSITIVE_INFINITY)
        : G === 0 || H === 0
        ? (Q = Math.max(G, H))
        : (Q = Math.min(G, H));
      const z = {};
      Object.defineProperty(z, "maxMessageSize", {
        get() {
          return Q;
        },
      }),
        (this._sctp = z);
    }
    return $.apply(this, arguments);
  };
}
function shimSendThrowTypeError(B) {
  if (
    !(
      B.RTCPeerConnection &&
      "createDataChannel" in B.RTCPeerConnection.prototype
    )
  )
    return;
  function U(q, j) {
    const V = q.send;
    q.send = function () {
      const W = arguments[0],
        K = W.length || W.size || W.byteLength;
      if (q.readyState === "open" && j.sctp && K > j.sctp.maxMessageSize)
        throw new TypeError(
          "Message too large (can send a maximum of " +
            j.sctp.maxMessageSize +
            " bytes)"
        );
      return V.apply(q, arguments);
    };
  }
  const F = B.RTCPeerConnection.prototype.createDataChannel;
  (B.RTCPeerConnection.prototype.createDataChannel = function () {
    const j = F.apply(this, arguments);
    return U(j, this), j;
  }),
    wrapPeerConnectionEvent(
      B,
      "datachannel",
      (q) => (U(q.channel, q.target), q)
    );
}
function shimConnectionState(B) {
  if (
    !B.RTCPeerConnection ||
    "connectionState" in B.RTCPeerConnection.prototype
  )
    return;
  const U = B.RTCPeerConnection.prototype;
  Object.defineProperty(U, "connectionState", {
    get() {
      return (
        { completed: "connected", checking: "connecting" }[
          this.iceConnectionState
        ] || this.iceConnectionState
      );
    },
    enumerable: !0,
    configurable: !0,
  }),
    Object.defineProperty(U, "onconnectionstatechange", {
      get() {
        return this._onconnectionstatechange || null;
      },
      set(F) {
        this._onconnectionstatechange &&
          (this.removeEventListener(
            "connectionstatechange",
            this._onconnectionstatechange
          ),
          delete this._onconnectionstatechange),
          F &&
            this.addEventListener(
              "connectionstatechange",
              (this._onconnectionstatechange = F)
            );
      },
      enumerable: !0,
      configurable: !0,
    }),
    ["setLocalDescription", "setRemoteDescription"].forEach((F) => {
      const q = U[F];
      U[F] = function () {
        return (
          this._connectionstatechangepoly ||
            ((this._connectionstatechangepoly = (j) => {
              const V = j.target;
              if (V._lastConnectionState !== V.connectionState) {
                V._lastConnectionState = V.connectionState;
                const $ = new Event("connectionstatechange", j);
                V.dispatchEvent($);
              }
              return j;
            }),
            this.addEventListener(
              "iceconnectionstatechange",
              this._connectionstatechangepoly
            )),
          q.apply(this, arguments)
        );
      };
    });
}
function removeExtmapAllowMixed(B, U) {
  if (
    !B.RTCPeerConnection ||
    (U.browser === "chrome" && U.version >= 71) ||
    (U.browser === "safari" && U.version >= 605)
  )
    return;
  const F = B.RTCPeerConnection.prototype.setRemoteDescription;
  B.RTCPeerConnection.prototype.setRemoteDescription = function (j) {
    if (
      j &&
      j.sdp &&
      j.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1
    ) {
      const V = j.sdp
        .split(
          `
`
        )
        .filter(($) => $.trim() !== "a=extmap-allow-mixed").join(`
`);
      B.RTCSessionDescription && j instanceof B.RTCSessionDescription
        ? (arguments[0] = new B.RTCSessionDescription({ type: j.type, sdp: V }))
        : (j.sdp = V);
    }
    return F.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(B, U) {
  if (!(B.RTCPeerConnection && B.RTCPeerConnection.prototype)) return;
  const F = B.RTCPeerConnection.prototype.addIceCandidate;
  !F ||
    F.length === 0 ||
    (B.RTCPeerConnection.prototype.addIceCandidate = function () {
      return arguments[0]
        ? ((U.browser === "chrome" && U.version < 78) ||
            (U.browser === "firefox" && U.version < 68) ||
            U.browser === "safari") &&
          arguments[0] &&
          arguments[0].candidate === ""
          ? Promise.resolve()
          : F.apply(this, arguments)
        : (arguments[1] && arguments[1].apply(null), Promise.resolve());
    });
}
function shimParameterlessSetLocalDescription(B, U) {
  if (!(B.RTCPeerConnection && B.RTCPeerConnection.prototype)) return;
  const F = B.RTCPeerConnection.prototype.setLocalDescription;
  !F ||
    F.length === 0 ||
    (B.RTCPeerConnection.prototype.setLocalDescription = function () {
      let j = arguments[0] || {};
      if (typeof j != "object" || (j.type && j.sdp))
        return F.apply(this, arguments);
      if (((j = { type: j.type, sdp: j.sdp }), !j.type))
        switch (this.signalingState) {
          case "stable":
          case "have-local-offer":
          case "have-remote-pranswer":
            j.type = "offer";
            break;
          default:
            j.type = "answer";
            break;
        }
      return j.sdp || (j.type !== "offer" && j.type !== "answer")
        ? F.apply(this, [j])
        : (j.type === "offer" ? this.createOffer : this.createAnswer)
            .apply(this)
            .then(($) => F.apply(this, [$]));
    });
}
var commonShim = Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError,
});
function adapterFactory() {
  let { window: B } =
      arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    U =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 };
  const F = log,
    q = detectBrowser(B),
    j = {
      browserDetails: q,
      commonShim,
      extractVersion,
      disableLog,
      disableWarnings,
      sdp,
    };
  switch (q.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !U.shimChrome)
        return F("Chrome shim is not included in this adapter release."), j;
      if (q.version === null)
        return F("Chrome shim can not determine version, not shimming."), j;
      F("adapter.js shimming chrome."),
        (j.browserShim = chromeShim),
        shimAddIceCandidateNullOrEmpty(B, q),
        shimParameterlessSetLocalDescription(B),
        shimGetUserMedia$2(B, q),
        shimMediaStream(B),
        shimPeerConnection$1(B, q),
        shimOnTrack$1(B),
        shimAddTrackRemoveTrack(B, q),
        shimGetSendersWithDtmf(B),
        shimSenderReceiverGetStats(B),
        fixNegotiationNeeded(B, q),
        shimRTCIceCandidate(B),
        shimRTCIceCandidateRelayProtocol(B),
        shimConnectionState(B),
        shimMaxMessageSize(B, q),
        shimSendThrowTypeError(B),
        removeExtmapAllowMixed(B, q);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !U.shimFirefox)
        return F("Firefox shim is not included in this adapter release."), j;
      F("adapter.js shimming firefox."),
        (j.browserShim = firefoxShim),
        shimAddIceCandidateNullOrEmpty(B, q),
        shimParameterlessSetLocalDescription(B),
        shimGetUserMedia$1(B, q),
        shimPeerConnection(B, q),
        shimOnTrack(B),
        shimRemoveStream(B),
        shimSenderGetStats(B),
        shimReceiverGetStats(B),
        shimRTCDataChannel(B),
        shimAddTransceiver(B),
        shimGetParameters(B),
        shimCreateOffer(B),
        shimCreateAnswer(B),
        shimRTCIceCandidate(B),
        shimConnectionState(B),
        shimMaxMessageSize(B, q),
        shimSendThrowTypeError(B);
      break;
    case "safari":
      if (!safariShim || !U.shimSafari)
        return F("Safari shim is not included in this adapter release."), j;
      F("adapter.js shimming safari."),
        (j.browserShim = safariShim),
        shimAddIceCandidateNullOrEmpty(B, q),
        shimParameterlessSetLocalDescription(B),
        shimRTCIceServerUrls(B),
        shimCreateOfferLegacy(B),
        shimCallbacksAPI(B),
        shimLocalStreamsAPI(B),
        shimRemoteStreamsAPI(B),
        shimTrackEventTransceiver(B),
        shimGetUserMedia(B),
        shimAudioContext(B),
        shimRTCIceCandidate(B),
        shimRTCIceCandidateRelayProtocol(B),
        shimMaxMessageSize(B, q),
        shimSendThrowTypeError(B),
        removeExtmapAllowMixed(B, q);
      break;
    default:
      F("Unsupported browser!");
      break;
  }
  return j;
}
adapterFactory({ window: typeof window > "u" ? void 0 : window });
const DECRYPTION_FAILURE_TOLERANCE = 10,
  E2EE_FLAG = "lk_e2ee",
  SALT = "LKFrameEncryptionKey",
  KEY_PROVIDER_DEFAULTS = {
    sharedKey: !1,
    ratchetSalt: SALT,
    ratchetWindowSize: 8,
    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
    keyringSize: 16,
    allowKeyExtraction: !1,
  };
var KeyProviderEvent;
(function (B) {
  (B.SetKey = "setKey"),
    (B.RatchetRequest = "ratchetRequest"),
    (B.KeyRatcheted = "keyRatcheted");
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function (B) {
  B.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function (B) {
  (B.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged"),
    (B.EncryptionError = "encryptionError");
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function (B) {
  B.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return (
    typeof window.RTCRtpSender < "u" &&
    typeof window.RTCRtpSender.prototype.createEncodedStreams < "u"
  );
}
class BaseKeyProvider extends eventsExports$1.EventEmitter {
  constructor() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(),
      (this.onKeyRatcheted = (F, q) => {
        livekitLogger.debug("key ratcheted event received", {
          material: F,
          keyIndex: q,
        });
      }),
      (this.keyInfoMap = new Map()),
      (this.options = Object.assign(
        Object.assign({}, KEY_PROVIDER_DEFAULTS),
        U
      )),
      this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  onSetEncryptionKey(U, F, q) {
    const j = { key: U, participantIdentity: F, keyIndex: q };
    if (!this.options.sharedKey && !F)
      throw new Error(
        "participant identity needs to be passed for encryption key if sharedKey option is false"
      );
    this.keyInfoMap.set("".concat(F ?? "shared", "-").concat(q ?? 0), j),
      this.emit(KeyProviderEvent.SetKey, j);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(U, F) {
    this.emit(KeyProviderEvent.RatchetRequest, U, F);
  }
}
class LivekitError extends Error {
  constructor(U, F) {
    super(F || "an error has occured"),
      (this.name = "LiveKitError"),
      (this.code = U);
  }
}
var ConnectionErrorReason;
(function (B) {
  (B[(B.NotAllowed = 0)] = "NotAllowed"),
    (B[(B.ServerUnreachable = 1)] = "ServerUnreachable"),
    (B[(B.InternalError = 2)] = "InternalError"),
    (B[(B.Cancelled = 3)] = "Cancelled"),
    (B[(B.LeaveRequest = 4)] = "LeaveRequest");
})(ConnectionErrorReason || (ConnectionErrorReason = {}));
class ConnectionError extends LivekitError {
  constructor(U, F, q, j) {
    super(1, U),
      (this.name = "ConnectionError"),
      (this.status = q),
      (this.reason = F),
      (this.context = j),
      (this.reasonName = ConnectionErrorReason[F]);
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(U) {
    super(21, U ?? "device is unsupported"),
      (this.name = "DeviceUnsupportedError");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(U) {
    super(20, U ?? "track is invalid"), (this.name = "TrackInvalidError");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(U) {
    super(10, U ?? "unsupported server"), (this.name = "UnsupportedServer");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(U) {
    super(12, U ?? "unexpected connection state"),
      (this.name = "UnexpectedConnectionState");
  }
}
class NegotiationError extends LivekitError {
  constructor(U) {
    super(13, U ?? "unable to negotiate"), (this.name = "NegotiationError");
  }
}
class PublishTrackError extends LivekitError {
  constructor(U, F) {
    super(15, U), (this.name = "PublishTrackError"), (this.status = F);
  }
}
class SignalRequestError extends LivekitError {
  constructor(U, F) {
    super(15, U),
      (this.reason = F),
      (this.reasonName = typeof F == "string" ? F : RequestResponse_Reason[F]);
  }
}
var MediaDeviceFailure;
(function (B) {
  (B.PermissionDenied = "PermissionDenied"),
    (B.NotFound = "NotFound"),
    (B.DeviceInUse = "DeviceInUse"),
    (B.Other = "Other");
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function (B) {
  function U(F) {
    if (F && "name" in F)
      return F.name === "NotFoundError" || F.name === "DevicesNotFoundError"
        ? B.NotFound
        : F.name === "NotAllowedError" || F.name === "PermissionDeniedError"
        ? B.PermissionDenied
        : F.name === "NotReadableError" || F.name === "TrackStartError"
        ? B.DeviceInUse
        : B.Other;
  }
  B.getFailure = U;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var CryptorErrorReason;
(function (B) {
  (B[(B.InvalidKey = 0)] = "InvalidKey"),
    (B[(B.MissingKey = 1)] = "MissingKey"),
    (B[(B.InternalError = 2)] = "InternalError");
})(CryptorErrorReason || (CryptorErrorReason = {}));
var RoomEvent;
(function (B) {
  (B.Connected = "connected"),
    (B.Reconnecting = "reconnecting"),
    (B.SignalReconnecting = "signalReconnecting"),
    (B.Reconnected = "reconnected"),
    (B.Disconnected = "disconnected"),
    (B.ConnectionStateChanged = "connectionStateChanged"),
    (B.MediaDevicesChanged = "mediaDevicesChanged"),
    (B.ParticipantConnected = "participantConnected"),
    (B.ParticipantDisconnected = "participantDisconnected"),
    (B.TrackPublished = "trackPublished"),
    (B.TrackSubscribed = "trackSubscribed"),
    (B.TrackSubscriptionFailed = "trackSubscriptionFailed"),
    (B.TrackUnpublished = "trackUnpublished"),
    (B.TrackUnsubscribed = "trackUnsubscribed"),
    (B.TrackMuted = "trackMuted"),
    (B.TrackUnmuted = "trackUnmuted"),
    (B.LocalTrackPublished = "localTrackPublished"),
    (B.LocalTrackUnpublished = "localTrackUnpublished"),
    (B.LocalAudioSilenceDetected = "localAudioSilenceDetected"),
    (B.ActiveSpeakersChanged = "activeSpeakersChanged"),
    (B.ParticipantMetadataChanged = "participantMetadataChanged"),
    (B.ParticipantNameChanged = "participantNameChanged"),
    (B.ParticipantAttributesChanged = "participantAttributesChanged"),
    (B.RoomMetadataChanged = "roomMetadataChanged"),
    (B.DataReceived = "dataReceived"),
    (B.SipDTMFReceived = "sipDTMFReceived"),
    (B.TranscriptionReceived = "transcriptionReceived"),
    (B.ConnectionQualityChanged = "connectionQualityChanged"),
    (B.TrackStreamStateChanged = "trackStreamStateChanged"),
    (B.TrackSubscriptionPermissionChanged =
      "trackSubscriptionPermissionChanged"),
    (B.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged"),
    (B.AudioPlaybackStatusChanged = "audioPlaybackChanged"),
    (B.VideoPlaybackStatusChanged = "videoPlaybackChanged"),
    (B.MediaDevicesError = "mediaDevicesError"),
    (B.ParticipantPermissionsChanged = "participantPermissionsChanged"),
    (B.SignalConnected = "signalConnected"),
    (B.RecordingStatusChanged = "recordingStatusChanged"),
    (B.ParticipantEncryptionStatusChanged =
      "participantEncryptionStatusChanged"),
    (B.EncryptionError = "encryptionError"),
    (B.DCBufferStatusChanged = "dcBufferStatusChanged"),
    (B.ActiveDeviceChanged = "activeDeviceChanged"),
    (B.ChatMessage = "chatMessage"),
    (B.LocalTrackSubscribed = "localTrackSubscribed"),
    (B.MetricsReceived = "metricsReceived");
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function (B) {
  (B.TrackPublished = "trackPublished"),
    (B.TrackSubscribed = "trackSubscribed"),
    (B.TrackSubscriptionFailed = "trackSubscriptionFailed"),
    (B.TrackUnpublished = "trackUnpublished"),
    (B.TrackUnsubscribed = "trackUnsubscribed"),
    (B.TrackMuted = "trackMuted"),
    (B.TrackUnmuted = "trackUnmuted"),
    (B.LocalTrackPublished = "localTrackPublished"),
    (B.LocalTrackUnpublished = "localTrackUnpublished"),
    (B.ParticipantMetadataChanged = "participantMetadataChanged"),
    (B.ParticipantNameChanged = "participantNameChanged"),
    (B.DataReceived = "dataReceived"),
    (B.SipDTMFReceived = "sipDTMFReceived"),
    (B.TranscriptionReceived = "transcriptionReceived"),
    (B.IsSpeakingChanged = "isSpeakingChanged"),
    (B.ConnectionQualityChanged = "connectionQualityChanged"),
    (B.TrackStreamStateChanged = "trackStreamStateChanged"),
    (B.TrackSubscriptionPermissionChanged =
      "trackSubscriptionPermissionChanged"),
    (B.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged"),
    (B.MediaDevicesError = "mediaDevicesError"),
    (B.AudioStreamAcquired = "audioStreamAcquired"),
    (B.ParticipantPermissionsChanged = "participantPermissionsChanged"),
    (B.PCTrackAdded = "pcTrackAdded"),
    (B.AttributesChanged = "attributesChanged"),
    (B.LocalTrackSubscribed = "localTrackSubscribed"),
    (B.ChatMessage = "chatMessage");
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function (B) {
  (B.TransportsCreated = "transportsCreated"),
    (B.Connected = "connected"),
    (B.Disconnected = "disconnected"),
    (B.Resuming = "resuming"),
    (B.Resumed = "resumed"),
    (B.Restarting = "restarting"),
    (B.Restarted = "restarted"),
    (B.SignalResumed = "signalResumed"),
    (B.SignalRestarted = "signalRestarted"),
    (B.Closing = "closing"),
    (B.MediaTrackAdded = "mediaTrackAdded"),
    (B.ActiveSpeakersUpdate = "activeSpeakersUpdate"),
    (B.DataPacketReceived = "dataPacketReceived"),
    (B.RTPVideoMapUpdate = "rtpVideoMapUpdate"),
    (B.DCBufferStatusChanged = "dcBufferStatusChanged"),
    (B.ParticipantUpdate = "participantUpdate"),
    (B.RoomUpdate = "roomUpdate"),
    (B.SpeakersChanged = "speakersChanged"),
    (B.StreamStateChanged = "streamStateChanged"),
    (B.ConnectionQualityUpdate = "connectionQualityUpdate"),
    (B.SubscriptionError = "subscriptionError"),
    (B.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate"),
    (B.RemoteMute = "remoteMute"),
    (B.SubscribedQualityUpdate = "subscribedQualityUpdate"),
    (B.LocalTrackUnpublished = "localTrackUnpublished"),
    (B.LocalTrackSubscribed = "localTrackSubscribed"),
    (B.Offline = "offline"),
    (B.SignalRequestResponse = "signalRequestResponse"),
    (B.SignalConnected = "signalConnected");
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function (B) {
  (B.Message = "message"),
    (B.Muted = "muted"),
    (B.Unmuted = "unmuted"),
    (B.Restarted = "restarted"),
    (B.Ended = "ended"),
    (B.Subscribed = "subscribed"),
    (B.Unsubscribed = "unsubscribed"),
    (B.UpdateSettings = "updateSettings"),
    (B.UpdateSubscription = "updateSubscription"),
    (B.AudioPlaybackStarted = "audioPlaybackStarted"),
    (B.AudioPlaybackFailed = "audioPlaybackFailed"),
    (B.AudioSilenceDetected = "audioSilenceDetected"),
    (B.VisibilityChanged = "visibilityChanged"),
    (B.VideoDimensionsChanged = "videoDimensionsChanged"),
    (B.VideoPlaybackStarted = "videoPlaybackStarted"),
    (B.VideoPlaybackFailed = "videoPlaybackFailed"),
    (B.ElementAttached = "elementAttached"),
    (B.ElementDetached = "elementDetached"),
    (B.UpstreamPaused = "upstreamPaused"),
    (B.UpstreamResumed = "upstreamResumed"),
    (B.SubscriptionPermissionChanged = "subscriptionPermissionChanged"),
    (B.SubscriptionStatusChanged = "subscriptionStatusChanged"),
    (B.SubscriptionFailed = "subscriptionFailed"),
    (B.TrackProcessorUpdate = "trackProcessorUpdate"),
    (B.AudioTrackFeatureUpdate = "audioTrackFeatureUpdate"),
    (B.TranscriptionReceived = "transcriptionReceived"),
    (B.TimeSyncUpdate = "timeSyncUpdate");
})(TrackEvent || (TrackEvent = {}));
function cloneDeep(B) {
  return typeof B > "u"
    ? B
    : typeof structuredClone == "function"
    ? structuredClone(B)
    : JSON.parse(JSON.stringify(B));
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(B) {
  let U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof navigator > "u") return;
  const F = navigator.userAgent.toLowerCase();
  if (browserDetails === void 0 || U) {
    const q = browsersList.find((j) => {
      let { test: V } = j;
      return V.test(F);
    });
    browserDetails = q == null ? void 0 : q.describe(F);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(B) {
      return {
        name: "Firefox",
        version: getMatch(
          /(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,
          B
        ),
        os: B.toLowerCase().includes("fxios") ? "iOS" : void 0,
        osVersion: getOSVersion(B),
      };
    },
  },
  {
    test: /chrom|crios|crmo/i,
    describe(B) {
      return {
        name: "Chrome",
        version: getMatch(
          /(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i,
          B
        ),
        os: B.toLowerCase().includes("crios") ? "iOS" : void 0,
        osVersion: getOSVersion(B),
      };
    },
  },
  {
    test: /safari|applewebkit/i,
    describe(B) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, B),
        os: B.includes("mobile/") ? "iOS" : "macOS",
        osVersion: getOSVersion(B),
      };
    },
  },
];
function getMatch(B, U) {
  let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const q = U.match(B);
  return (q && q.length >= F && q[F]) || "";
}
function getOSVersion(B) {
  return B.includes("mac os")
    ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, B, 1).replace(/_/g, ".")
    : void 0;
}
var version$1 = "2.11.3";
const version$2 = version$1,
  protocolVersion = 15;
class CriticalTimers {}
CriticalTimers.setTimeout = function () {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function () {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function () {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function () {
  return clearInterval(...arguments);
};
const BACKGROUND_REACTION_DELAY = 5e3,
  recycledElements = [];
var VideoQuality;
(function (B) {
  (B[(B.LOW = 0)] = "LOW"),
    (B[(B.MEDIUM = 1)] = "MEDIUM"),
    (B[(B.HIGH = 2)] = "HIGH");
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports$1.EventEmitter {
  constructor(U, F) {
    let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var j;
    super(),
      (this.attachedElements = []),
      (this.isMuted = !1),
      (this.streamState = Track.StreamState.Active),
      (this.isInBackground = !1),
      (this._currentBitrate = 0),
      (this.log = livekitLogger),
      (this.appVisibilityChangedListener = () => {
        this.backgroundTimeout && clearTimeout(this.backgroundTimeout),
          document.visibilityState === "hidden"
            ? (this.backgroundTimeout = setTimeout(
                () => this.handleAppVisibilityChanged(),
                BACKGROUND_REACTION_DELAY
              ))
            : this.handleAppVisibilityChanged();
      }),
      (this.log = getLogger(
        (j = q.loggerName) !== null && j !== void 0 ? j : LoggerNames.Track
      )),
      (this.loggerContextCb = q.loggerContextCb),
      this.setMaxListeners(100),
      (this.kind = F),
      (this._mediaStreamTrack = U),
      (this._mediaStreamID = U.id),
      (this.source = Track.Source.Unknown);
  }
  get logContext() {
    var U;
    return Object.assign(
      Object.assign(
        {},
        (U = this.loggerContextCb) === null || U === void 0
          ? void 0
          : U.call(this)
      ),
      getLogContextFromTrack(this)
    );
  }
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(U) {
    let F = "audio";
    this.kind === Track.Kind.Video && (F = "video"),
      this.attachedElements.length === 0 &&
        this.kind === Track.Kind.Video &&
        this.addAppVisibilityListener(),
      U ||
        (F === "audio" &&
          (recycledElements.forEach((V) => {
            V.parentElement === null && !U && (U = V);
          }),
          U && recycledElements.splice(recycledElements.indexOf(U), 1)),
        U || (U = document.createElement(F))),
      this.attachedElements.includes(U) || this.attachedElements.push(U),
      attachToElement(this.mediaStreamTrack, U);
    const q = U.srcObject.getTracks(),
      j = q.some((V) => V.kind === "audio");
    return (
      U.play()
        .then(() => {
          this.emit(
            j
              ? TrackEvent.AudioPlaybackStarted
              : TrackEvent.VideoPlaybackStarted
          );
        })
        .catch((V) => {
          V.name === "NotAllowedError"
            ? this.emit(
                j
                  ? TrackEvent.AudioPlaybackFailed
                  : TrackEvent.VideoPlaybackFailed,
                V
              )
            : V.name === "AbortError"
            ? livekitLogger.debug(
                "".concat(
                  j ? "audio" : "video",
                  " playback aborted, likely due to new play request"
                )
              )
            : livekitLogger.warn(
                "could not playback ".concat(j ? "audio" : "video"),
                V
              ),
            j &&
              U &&
              q.some(($) => $.kind === "video") &&
              V.name === "NotAllowedError" &&
              ((U.muted = !0), U.play().catch(() => {}));
        }),
      this.emit(TrackEvent.ElementAttached, U),
      U
    );
  }
  detach(U) {
    try {
      if (U) {
        detachTrack(this.mediaStreamTrack, U);
        const q = this.attachedElements.indexOf(U);
        return (
          q >= 0 &&
            (this.attachedElements.splice(q, 1),
            this.recycleElement(U),
            this.emit(TrackEvent.ElementDetached, U)),
          U
        );
      }
      const F = [];
      return (
        this.attachedElements.forEach((q) => {
          detachTrack(this.mediaStreamTrack, q),
            F.push(q),
            this.recycleElement(q),
            this.emit(TrackEvent.ElementDetached, q);
        }),
        (this.attachedElements = []),
        F
      );
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval),
      this.timeSyncHandle && cancelAnimationFrame(this.timeSyncHandle);
  }
  updateLoggerOptions(U) {
    U.loggerName && (this.log = getLogger(U.loggerName)),
      U.loggerContextCb && (this.loggerContextCb = U.loggerContextCb);
  }
  recycleElement(U) {
    if (U instanceof HTMLAudioElement) {
      let F = !0;
      U.pause(),
        recycledElements.forEach((q) => {
          q.parentElement || (F = !1);
        }),
        F && recycledElements.push(U);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.isInBackground = document.visibilityState === "hidden"),
        !this.isInBackground &&
          this.kind === Track.Kind.Video &&
          setTimeout(
            () =>
              this.attachedElements.forEach((U) => U.play().catch(() => {})),
            0
          );
    });
  }
  addAppVisibilityListener() {
    isWeb()
      ? ((this.isInBackground = document.visibilityState === "hidden"),
        document.addEventListener(
          "visibilitychange",
          this.appVisibilityChangedListener
        ))
      : (this.isInBackground = !1);
  }
  removeAppVisibilityListener() {
    isWeb() &&
      document.removeEventListener(
        "visibilitychange",
        this.appVisibilityChangedListener
      );
  }
}
function attachToElement(B, U) {
  let F;
  U.srcObject instanceof MediaStream
    ? (F = U.srcObject)
    : (F = new MediaStream());
  let q;
  B.kind === "audio" ? (q = F.getAudioTracks()) : (q = F.getVideoTracks()),
    q.includes(B) ||
      (q.forEach((j) => {
        F.removeTrack(j);
      }),
      F.addTrack(B)),
    (!isSafari() || !(U instanceof HTMLVideoElement)) && (U.autoplay = !0),
    (U.muted = F.getAudioTracks().length === 0),
    U instanceof HTMLVideoElement && (U.playsInline = !0),
    U.srcObject !== F &&
      ((U.srcObject = F),
      (isSafari() || isFireFox()) &&
        U instanceof HTMLVideoElement &&
        setTimeout(() => {
          (U.srcObject = F), U.play().catch(() => {});
        }, 0));
}
function detachTrack(B, U) {
  if (U.srcObject instanceof MediaStream) {
    const F = U.srcObject;
    F.removeTrack(B),
      F.getTracks().length > 0 ? (U.srcObject = F) : (U.srcObject = null);
  }
}
(function (B) {
  let U;
  (function (G) {
    (G.Audio = "audio"), (G.Video = "video"), (G.Unknown = "unknown");
  })((U = B.Kind || (B.Kind = {})));
  let F;
  (function (G) {
    (G.Camera = "camera"),
      (G.Microphone = "microphone"),
      (G.ScreenShare = "screen_share"),
      (G.ScreenShareAudio = "screen_share_audio"),
      (G.Unknown = "unknown");
  })((F = B.Source || (B.Source = {})));
  let q;
  (function (G) {
    (G.Active = "active"), (G.Paused = "paused"), (G.Unknown = "unknown");
  })((q = B.StreamState || (B.StreamState = {})));
  function j(G) {
    switch (G) {
      case U.Audio:
        return TrackType.AUDIO;
      case U.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  B.kindToProto = j;
  function V(G) {
    switch (G) {
      case TrackType.AUDIO:
        return U.Audio;
      case TrackType.VIDEO:
        return U.Video;
      default:
        return U.Unknown;
    }
  }
  B.kindFromProto = V;
  function $(G) {
    switch (G) {
      case F.Camera:
        return TrackSource.CAMERA;
      case F.Microphone:
        return TrackSource.MICROPHONE;
      case F.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case F.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  B.sourceToProto = $;
  function W(G) {
    switch (G) {
      case TrackSource.CAMERA:
        return F.Camera;
      case TrackSource.MICROPHONE:
        return F.Microphone;
      case TrackSource.SCREEN_SHARE:
        return F.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return F.ScreenShareAudio;
      default:
        return F.Unknown;
    }
  }
  B.sourceFromProto = W;
  function K(G) {
    switch (G) {
      case StreamState.ACTIVE:
        return q.Active;
      case StreamState.PAUSED:
        return q.Paused;
      default:
        return q.Unknown;
    }
  }
  B.streamStateFromProto = K;
})(Track || (Track = {}));
class VideoPreset {
  constructor(U, F, q, j, V) {
    if (typeof U == "object")
      (this.width = U.width),
        (this.height = U.height),
        (this.aspectRatio = U.aspectRatio),
        (this.encoding = {
          maxBitrate: U.maxBitrate,
          maxFramerate: U.maxFramerate,
          priority: U.priority,
        });
    else if (F !== void 0 && q !== void 0)
      (this.width = U),
        (this.height = F),
        (this.aspectRatio = U / F),
        (this.encoding = { maxBitrate: q, maxFramerate: j, priority: V });
    else
      throw new TypeError(
        "Unsupported options: provide at least width, height and maxBitrate"
      );
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.aspectRatio,
    };
  }
}
const backupCodecs = ["vp8", "h264"],
  videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(B) {
  return !!backupCodecs.find((U) => U === B);
}
var BackupCodecPolicy;
(function (B) {
  (B[(B.PREFER_REGRESSION = 0)] = "PREFER_REGRESSION"),
    (B[(B.SIMULCAST = 1)] = "SIMULCAST"),
    (B[(B.REGRESSION = 2)] = "REGRESSION");
})(BackupCodecPolicy || (BackupCodecPolicy = {}));
var AudioPresets;
(function (B) {
  (B.telephone = { maxBitrate: 12e3 }),
    (B.speech = { maxBitrate: 24e3 }),
    (B.music = { maxBitrate: 48e3 }),
    (B.musicStereo = { maxBitrate: 64e3 }),
    (B.musicHighQuality = { maxBitrate: 96e3 }),
    (B.musicHighQualityStereo = { maxBitrate: 128e3 });
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
    h90: new VideoPreset(160, 90, 9e4, 20),
    h180: new VideoPreset(320, 180, 16e4, 20),
    h216: new VideoPreset(384, 216, 18e4, 20),
    h360: new VideoPreset(640, 360, 45e4, 20),
    h540: new VideoPreset(960, 540, 8e5, 25),
    h720: new VideoPreset(1280, 720, 17e5, 30),
    h1080: new VideoPreset(1920, 1080, 3e6, 30),
    h1440: new VideoPreset(2560, 1440, 5e6, 30),
    h2160: new VideoPreset(3840, 2160, 8e6, 30),
  },
  VideoPresets43 = {
    h120: new VideoPreset(160, 120, 7e4, 20),
    h180: new VideoPreset(240, 180, 125e3, 20),
    h240: new VideoPreset(320, 240, 14e4, 20),
    h360: new VideoPreset(480, 360, 33e4, 20),
    h480: new VideoPreset(640, 480, 5e5, 20),
    h540: new VideoPreset(720, 540, 6e5, 25),
    h720: new VideoPreset(960, 720, 13e5, 30),
    h1080: new VideoPreset(1440, 1080, 23e5, 30),
    h1440: new VideoPreset(1920, 1440, 38e5, 30),
  },
  ScreenSharePresets = {
    h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
    h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
    h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
    h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
    h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
    h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
    h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
    original: new VideoPreset(0, 0, 7e6, 30, "medium"),
  },
  separator = "|",
  ddExtensionURI =
    "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(B) {
  const U = B.split(separator);
  return U.length > 1 ? [U[0], B.substr(U[0].length + 1)] : [B, ""];
}
function sleep$1(B) {
  return __awaiter$b(this, void 0, void 0, function* () {
    return new Promise((U) => CriticalTimers.setTimeout(U, B));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari()) return !1;
  const B = RTCRtpSender.getCapabilities("video");
  let U = !1;
  if (B) {
    for (const F of B.codecs)
      if (F.mimeType === "video/AV1") {
        U = !0;
        break;
      }
  }
  return U;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox()) return !1;
  if (isSafari()) {
    const F = getBrowser();
    if (F != null && F.version && compareVersions(F.version, "16") < 0)
      return !1;
  }
  const B = RTCRtpSender.getCapabilities("video");
  let U = !1;
  if (B) {
    for (const F of B.codecs)
      if (F.mimeType === "video/VP9") {
        U = !0;
        break;
      }
  }
  return U;
}
function isSVCCodec(B) {
  return B === "av1" || B === "vp9";
}
function supportsSetSinkId(B) {
  return document
    ? (B || (B = document.createElement("audio")), "setSinkId" in B)
    : !1;
}
function isBrowserSupported() {
  return typeof RTCPeerConnection > "u"
    ? !1
    : supportsTransceiver() || supportsAddTrack();
}
function isFireFox() {
  var B;
  return (
    ((B = getBrowser()) === null || B === void 0 ? void 0 : B.name) ===
    "Firefox"
  );
}
function isSafari() {
  var B;
  return (
    ((B = getBrowser()) === null || B === void 0 ? void 0 : B.name) === "Safari"
  );
}
function isSafari17() {
  const B = getBrowser();
  return (
    (B == null ? void 0 : B.name) === "Safari" && B.version.startsWith("17.")
  );
}
function isMobile() {
  var B, U;
  return isWeb()
    ? (U =
        (B = navigator.userAgentData) === null || B === void 0
          ? void 0
          : B.mobile) !== null && U !== void 0
      ? U
      : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
    : !1;
}
function isE2EESimulcastSupported() {
  const B = getBrowser(),
    U = "17.2";
  if (B)
    return (B.name !== "Safari" && B.os !== "iOS") ||
      (B.os === "iOS" && B.osVersion && compareVersions(U, B.osVersion) >= 0)
      ? !0
      : B.name === "Safari" && compareVersions(U, B.version) >= 0;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(B) {
  return (
    B.hostname.endsWith(".livekit.cloud") || B.hostname.endsWith(".livekit.run")
  );
}
function getLKReactNativeInfo() {
  if (global && global.LiveKitReactNativeGlobal)
    return global.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative()) return;
  let B = getLKReactNativeInfo();
  if (B) return B.platform;
}
function getDevicePixelRatio() {
  if (isWeb()) return window.devicePixelRatio;
  if (isReactNative()) {
    let B = getLKReactNativeInfo();
    if (B) return B.devicePixelRatio;
  }
  return 1;
}
function compareVersions(B, U) {
  const F = B.split("."),
    q = U.split("."),
    j = Math.min(F.length, q.length);
  for (let V = 0; V < j; ++V) {
    const $ = parseInt(F[V], 10),
      W = parseInt(q[V], 10);
    if ($ > W) return 1;
    if ($ < W) return -1;
    if (V === j - 1 && $ === W) return 0;
  }
  return B === "" && U !== ""
    ? -1
    : U === ""
    ? 1
    : F.length == q.length
    ? 0
    : F.length < q.length
    ? -1
    : 1;
}
function roDispatchCallback(B) {
  for (const U of B) U.target.handleResize(U);
}
function ioDispatchCallback(B) {
  for (const U of B) U.target.handleVisibilityChanged(U);
}
let resizeObserver = null;
const getResizeObserver = () => (
  resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)),
  resizeObserver
);
let intersectionObserver = null;
const getIntersectionObserver = () => (
  intersectionObserver ||
    (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
      root: null,
      rootMargin: "0px",
    })),
  intersectionObserver
);
function getClientInfo() {
  var B;
  const U = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version: version$2,
  });
  return (
    isReactNative() &&
      (U.os = (B = getReactNativeOs()) !== null && B !== void 0 ? B : ""),
    U
  );
}
function createDummyVideoStreamTrack() {
  let B = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16,
    U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16,
    F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    q = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const j = document.createElement("canvas");
  (j.width = B), (j.height = U);
  const V = j.getContext("2d");
  V == null || V.fillRect(0, 0, j.width, j.height),
    q &&
      V &&
      (V.beginPath(),
      V.arc(B / 2, U / 2, 50, 0, Math.PI * 2, !0),
      V.closePath(),
      (V.fillStyle = "grey"),
      V.fill());
  const $ = j.captureStream(),
    [W] = $.getTracks();
  if (!W) throw Error("Could not get empty media stream video track");
  return (W.enabled = F), W;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const B = new AudioContext(),
      U = B.createOscillator(),
      F = B.createGain();
    F.gain.setValueAtTime(0, 0);
    const q = B.createMediaStreamDestination();
    if (
      (U.connect(F),
      F.connect(q),
      U.start(),
      ([emptyAudioStreamTrack] = q.stream.getAudioTracks()),
      !emptyAudioStreamTrack)
    )
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(U, F) {
    (this.onFinally = F),
      (this.promise = new Promise((q, j) =>
        __awaiter$b(this, void 0, void 0, function* () {
          (this.resolve = q), (this.reject = j), U && (yield U(q, j));
        })
      ).finally(() => {
        var q;
        return (q = this.onFinally) === null || q === void 0
          ? void 0
          : q.call(this);
      }));
  }
}
function isVideoCodec(B) {
  return videoCodecs.includes(B);
}
function unwrapConstraint(B) {
  if (typeof B == "string" || typeof B == "number") return B;
  if (Array.isArray(B)) return B[0];
  if (B.exact) return Array.isArray(B.exact) ? B.exact[0] : B.exact;
  if (B.ideal) return Array.isArray(B.ideal) ? B.ideal[0] : B.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(B) {
  return B.startsWith("http") ? B.replace(/^(http)/, "ws") : B;
}
function toHttpUrl(B) {
  return B.startsWith("ws") ? B.replace(/^(ws)/, "http") : B;
}
function extractTranscriptionSegments(B, U) {
  return B.segments.map((F) => {
    let { id: q, text: j, language: V, startTime: $, endTime: W, final: K } = F;
    var G;
    const H = (G = U.get(q)) !== null && G !== void 0 ? G : Date.now(),
      Q = Date.now();
    return (
      K ? U.delete(q) : U.set(q, H),
      {
        id: q,
        text: j,
        startTime: Number.parseInt($.toString()),
        endTime: Number.parseInt(W.toString()),
        final: K,
        language: V,
        firstReceivedTime: H,
        lastReceivedTime: Q,
      }
    );
  });
}
function extractChatMessage(B) {
  const { id: U, timestamp: F, message: q, editTimestamp: j } = B;
  return {
    id: U,
    timestamp: Number.parseInt(F.toString()),
    editTimestamp: j ? Number.parseInt(j.toString()) : void 0,
    message: q,
  };
}
function getDisconnectReasonFromConnectionError(B) {
  switch (B.reason) {
    case ConnectionErrorReason.LeaveRequest:
      return B.context;
    case ConnectionErrorReason.Cancelled:
      return DisconnectReason.CLIENT_INITIATED;
    case ConnectionErrorReason.NotAllowed:
      return DisconnectReason.USER_REJECTED;
    case ConnectionErrorReason.ServerUnreachable:
      return DisconnectReason.JOIN_FAILURE;
    default:
      return DisconnectReason.UNKNOWN_REASON;
  }
}
function bigIntToNumber(B) {
  return B !== void 0 ? Number(B) : void 0;
}
function numberToBigInt(B) {
  return B !== void 0 ? BigInt(B) : void 0;
}
function isLocalTrack(B) {
  return !!B && !(B instanceof MediaStreamTrack) && B.isLocal;
}
function isAudioTrack(B) {
  return !!B && B.kind == Track.Kind.Audio;
}
function isVideoTrack(B) {
  return !!B && B.kind == Track.Kind.Video;
}
function isLocalVideoTrack(B) {
  return isLocalTrack(B) && isVideoTrack(B);
}
function isLocalAudioTrack(B) {
  return isLocalTrack(B) && isAudioTrack(B);
}
function isRemoteTrack(B) {
  return !!B && !B.isLocal;
}
function isRemotePub(B) {
  return !!B && !B.isLocal;
}
function isRemoteVideoTrack(B) {
  return isRemoteTrack(B) && isVideoTrack(B);
}
function isLocalParticipant(B) {
  return B.isLocal;
}
function splitUtf8(B, U) {
  const F = [];
  let q = new TextEncoder().encode(B);
  for (; q.length > U; ) {
    let j = U;
    for (; j > 0; ) {
      const V = q[j];
      if (V !== void 0 && (V & 192) !== 128) break;
      j--;
    }
    F.push(q.slice(0, j)), (q = q.slice(j));
  }
  return q.length > 0 && F.push(q), F;
}
function mergeDefaultOptions(B, U, F) {
  var q, j, V, $;
  const {
      optionsWithoutProcessor: W,
      audioProcessor: K,
      videoProcessor: G,
    } = extractProcessorsFromOptions(B ?? {}),
    H = U == null ? void 0 : U.processor,
    Q = F == null ? void 0 : F.processor,
    z = W ?? {};
  return (
    z.audio === !0 && (z.audio = {}),
    z.video === !0 && (z.video = {}),
    z.audio &&
      (mergeObjectWithoutOverwriting(z.audio, U),
      ((q = (V = z.audio).deviceId) !== null && q !== void 0) ||
        (V.deviceId = { ideal: "default" }),
      (K || H) && (z.audio.processor = K ?? H)),
    z.video &&
      (mergeObjectWithoutOverwriting(z.video, F),
      ((j = ($ = z.video).deviceId) !== null && j !== void 0) ||
        ($.deviceId = { ideal: "default" }),
      (G || Q) && (z.video.processor = G ?? Q)),
    z
  );
}
function mergeObjectWithoutOverwriting(B, U) {
  return (
    Object.keys(U).forEach((F) => {
      B[F] === void 0 && (B[F] = U[F]);
    }),
    B
  );
}
function constraintsForOptions(B) {
  var U, F, q, j;
  const V = {};
  if (B.video)
    if (typeof B.video == "object") {
      const $ = {},
        W = $,
        K = B.video;
      Object.keys(K).forEach((G) => {
        switch (G) {
          case "resolution":
            mergeObjectWithoutOverwriting(W, K.resolution);
            break;
          default:
            W[G] = K[G];
        }
      }),
        (V.video = $),
        ((U = (q = V.video).deviceId) !== null && U !== void 0) ||
          (q.deviceId = { ideal: "default" });
    } else V.video = B.video ? { deviceId: { ideal: "default" } } : !1;
  else V.video = !1;
  return (
    B.audio
      ? typeof B.audio == "object"
        ? ((V.audio = B.audio),
          ((F = (j = V.audio).deviceId) !== null && F !== void 0) ||
            (j.deviceId = { ideal: "default" }))
        : (V.audio = { deviceId: { ideal: "default" } })
      : (V.audio = !1),
    V
  );
}
function detectSilence(B) {
  return __awaiter$b(this, arguments, void 0, function (U) {
    let F =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
    return (function* () {
      const q = getNewAudioContext();
      if (q) {
        const j = q.createAnalyser();
        j.fftSize = 2048;
        const V = j.frequencyBinCount,
          $ = new Uint8Array(V);
        q
          .createMediaStreamSource(new MediaStream([U.mediaStreamTrack]))
          .connect(j),
          yield sleep$1(F),
          j.getByteTimeDomainData($);
        const K = $.some((G) => G !== 128 && G !== 0);
        return q.close(), !K;
      }
      return !1;
    })();
  });
}
function getNewAudioContext() {
  var B;
  const U =
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext);
  if (U) {
    const F = new U({ latencyHint: "interactive" });
    if (
      F.state === "suspended" &&
      typeof window < "u" &&
      !((B = window.document) === null || B === void 0) &&
      B.body
    ) {
      const q = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          var j;
          try {
            F.state === "suspended" && (yield F.resume());
          } catch (V) {
            console.warn("Error trying to auto-resume audio context", V);
          }
          (j = window.document.body) === null ||
            j === void 0 ||
            j.removeEventListener("click", q);
        });
      window.document.body.addEventListener("click", q);
    }
    return F;
  }
}
function sourceToKind(B) {
  return B === Track.Source.Microphone
    ? "audioinput"
    : B === Track.Source.Camera
    ? "videoinput"
    : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(B) {
  var U, F;
  let q = (U = B.video) !== null && U !== void 0 ? U : !0;
  return (
    B.resolution &&
      B.resolution.width > 0 &&
      B.resolution.height > 0 &&
      ((q = typeof q == "boolean" ? {} : q),
      isSafari()
        ? (q = Object.assign(Object.assign({}, q), {
            width: { max: B.resolution.width },
            height: { max: B.resolution.height },
            frameRate: B.resolution.frameRate,
          }))
        : (q = Object.assign(Object.assign({}, q), {
            width: { ideal: B.resolution.width },
            height: { ideal: B.resolution.height },
            frameRate: B.resolution.frameRate,
          }))),
    {
      audio: (F = B.audio) !== null && F !== void 0 ? F : !1,
      video: q,
      controller: B.controller,
      selfBrowserSurface: B.selfBrowserSurface,
      surfaceSwitching: B.surfaceSwitching,
      systemAudio: B.systemAudio,
      preferCurrentTab: B.preferCurrentTab,
    }
  );
}
function mimeTypeToVideoCodecString(B) {
  return B.split("/")[1].toLowerCase();
}
function getTrackPublicationInfo(B) {
  const U = [];
  return (
    B.forEach((F) => {
      F.track !== void 0 &&
        U.push(
          new TrackPublishedResponse({
            cid: F.track.mediaStreamID,
            track: F.trackInfo,
          })
        );
    }),
    U
  );
}
function getLogContextFromTrack(B) {
  return "mediaStreamTrack" in B
    ? {
        trackID: B.sid,
        source: B.source,
        muted: B.isMuted,
        enabled: B.mediaStreamTrack.enabled,
        kind: B.kind,
        streamID: B.mediaStreamID,
        streamTrackID: B.mediaStreamTrack.id,
      }
    : {
        trackID: B.trackSid,
        enabled: B.isEnabled,
        muted: B.isMuted,
        trackInfo: Object.assign(
          {
            mimeType: B.mimeType,
            name: B.trackName,
            encrypted: B.isEncrypted,
            kind: B.kind,
            source: B.source,
          },
          B.track ? getLogContextFromTrack(B.track) : {}
        ),
      };
}
function supportsSynchronizationSources() {
  return (
    typeof RTCRtpReceiver < "u" && "getSynchronizationSources" in RTCRtpReceiver
  );
}
function diffAttributes(B, U) {
  var F;
  B === void 0 && (B = {}), U === void 0 && (U = {});
  const q = [...Object.keys(U), ...Object.keys(B)],
    j = {};
  for (const V of q)
    B[V] !== U[V] && (j[V] = (F = U[V]) !== null && F !== void 0 ? F : "");
  return j;
}
function extractProcessorsFromOptions(B) {
  const U = Object.assign({}, B);
  let F, q;
  return (
    typeof U.audio == "object" &&
      U.audio.processor &&
      ((F = U.audio.processor),
      (U.audio = Object.assign(Object.assign({}, U.audio), {
        processor: void 0,
      }))),
    typeof U.video == "object" &&
      U.video.processor &&
      ((q = U.video.processor),
      (U.video = Object.assign(Object.assign({}, U.video), {
        processor: void 0,
      }))),
    {
      audioProcessor: F,
      videoProcessor: q,
      optionsWithoutProcessor: cloneDeep(U),
    }
  );
}
function getTrackSourceFromProto(B) {
  switch (B) {
    case TrackSource.CAMERA:
      return Track.Source.Camera;
    case TrackSource.MICROPHONE:
      return Track.Source.Microphone;
    case TrackSource.SCREEN_SHARE:
      return Track.Source.ScreenShare;
    case TrackSource.SCREEN_SHARE_AUDIO:
      return Track.Source.ScreenShareAudio;
    default:
      return Track.Source.Unknown;
  }
}
class E2EEManager extends eventsExports$1.EventEmitter {
  constructor(U) {
    super(),
      (this.onWorkerMessage = (F) => {
        var q, j;
        const { kind: V, data: $ } = F.data;
        switch (V) {
          case "error":
            livekitLogger.error($.error.message),
              this.emit(EncryptionEvent.EncryptionError, $.error);
            break;
          case "initAck":
            $.enabled &&
              this.keyProvider.getKeys().forEach((W) => {
                this.postKey(W);
              });
            break;
          case "enable":
            if (
              ($.enabled &&
                this.keyProvider.getKeys().forEach((W) => {
                  this.postKey(W);
                }),
              this.encryptionEnabled !== $.enabled &&
                $.participantIdentity ===
                  ((q = this.room) === null || q === void 0
                    ? void 0
                    : q.localParticipant.identity))
            )
              this.emit(
                EncryptionEvent.ParticipantEncryptionStatusChanged,
                $.enabled,
                this.room.localParticipant
              ),
                (this.encryptionEnabled = $.enabled);
            else if ($.participantIdentity) {
              const W =
                (j = this.room) === null || j === void 0
                  ? void 0
                  : j.getParticipantByIdentity($.participantIdentity);
              if (!W)
                throw TypeError(
                  "couldn't set encryption status, participant not found".concat(
                    $.participantIdentity
                  )
                );
              this.emit(
                EncryptionEvent.ParticipantEncryptionStatusChanged,
                $.enabled,
                W
              );
            }
            break;
          case "ratchetKey":
            this.keyProvider.emit(
              KeyProviderEvent.KeyRatcheted,
              $.material,
              $.keyIndex
            );
            break;
        }
      }),
      (this.onWorkerError = (F) => {
        livekitLogger.error("e2ee worker encountered an error:", {
          error: F.error,
        }),
          this.emit(EncryptionEvent.EncryptionError, F.error);
      }),
      (this.keyProvider = U.keyProvider),
      (this.worker = U.worker),
      (this.encryptionEnabled = !1);
  }
  setup(U) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError(
        "tried to setup end-to-end encryption on an unsupported browser"
      );
    if ((livekitLogger.info("setting up e2ee"), U !== this.room)) {
      (this.room = U), this.setupEventListeners(U, this.keyProvider);
      const F = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions(),
          loglevel: workerLogger.getLevel(),
        },
      };
      this.worker &&
        (livekitLogger.info("initializing worker", { worker: this.worker }),
        (this.worker.onmessage = this.onWorkerMessage),
        (this.worker.onerror = this.onWorkerError),
        this.worker.postMessage(F));
    }
  }
  setParticipantCryptorEnabled(U, F) {
    livekitLogger.debug(
      "set e2ee to ".concat(U, " for participant ").concat(F)
    ),
      this.postEnable(U, F);
  }
  setSifTrailer(U) {
    !U || U.length === 0
      ? livekitLogger.warn("ignoring server sent trailer as it's empty")
      : this.postSifTrailer(U);
  }
  setupEngine(U) {
    U.on(EngineEvent.RTPVideoMapUpdate, (F) => {
      this.postRTPMap(F);
    });
  }
  setupEventListeners(U, F) {
    U.on(RoomEvent.TrackPublished, (q, j) =>
      this.setParticipantCryptorEnabled(
        q.trackInfo.encryption !== Encryption_Type.NONE,
        j.identity
      )
    ),
      U.on(RoomEvent.ConnectionStateChanged, (q) => {
        q === ConnectionState.Connected &&
          U.remoteParticipants.forEach((j) => {
            j.trackPublications.forEach((V) => {
              this.setParticipantCryptorEnabled(
                V.trackInfo.encryption !== Encryption_Type.NONE,
                j.identity
              );
            });
          });
      })
        .on(RoomEvent.TrackUnsubscribed, (q, j, V) => {
          var $;
          const W = {
            kind: "removeTransform",
            data: { participantIdentity: V.identity, trackId: q.mediaStreamID },
          };
          ($ = this.worker) === null || $ === void 0 || $.postMessage(W);
        })
        .on(RoomEvent.TrackSubscribed, (q, j, V) => {
          this.setupE2EEReceiver(q, V.identity, j.trackInfo);
        })
        .on(RoomEvent.SignalConnected, () => {
          if (!this.room)
            throw new TypeError(
              "expected room to be present on signal connect"
            );
          F.getKeys().forEach((q) => {
            this.postKey(q);
          }),
            this.setParticipantCryptorEnabled(
              this.room.localParticipant.isE2EEEnabled,
              this.room.localParticipant.identity
            );
        }),
      U.localParticipant.on(ParticipantEvent.LocalTrackPublished, (q) =>
        __awaiter$b(this, void 0, void 0, function* () {
          this.setupE2EESender(q.track, q.track.sender);
        })
      ),
      F.on(KeyProviderEvent.SetKey, (q) => this.postKey(q)).on(
        KeyProviderEvent.RatchetRequest,
        (q, j) =>
          this.postRatchetRequest(q, j, F.getOptions().allowKeyExtraction)
      );
  }
  postRatchetRequest(U, F, q) {
    if (!this.worker) throw Error("could not ratchet key, worker is missing");
    const j = {
      kind: "ratchetRequest",
      data: { participantIdentity: U, keyIndex: F, extractable: q },
    };
    this.worker.postMessage(j);
  }
  postKey(U) {
    let { key: F, participantIdentity: q, keyIndex: j } = U;
    var V;
    if (!this.worker) throw Error("could not set key, worker is missing");
    const $ = {
      kind: "setKey",
      data: {
        participantIdentity: q,
        isPublisher:
          q ===
          ((V = this.room) === null || V === void 0
            ? void 0
            : V.localParticipant.identity),
        key: F,
        keyIndex: j,
      },
    };
    this.worker.postMessage($);
  }
  postEnable(U, F) {
    if (this.worker) {
      const q = {
        kind: "enable",
        data: { enabled: U, participantIdentity: F },
      };
      this.worker.postMessage(q);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(U) {
    var F;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (
      !(
        !((F = this.room) === null || F === void 0) &&
        F.localParticipant.identity
      )
    )
      throw TypeError(
        "could not post rtp map, local participant identity is missing"
      );
    const q = {
      kind: "setRTPMap",
      data: {
        map: U,
        participantIdentity: this.room.localParticipant.identity,
      },
    };
    this.worker.postMessage(q);
  }
  postSifTrailer(U) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const F = { kind: "setSifTrailer", data: { trailer: U } };
    this.worker.postMessage(F);
  }
  setupE2EEReceiver(U, F, q) {
    if (U.receiver) {
      if (!(q != null && q.mimeType) || q.mimeType === "")
        throw new TypeError(
          "MimeType missing from trackInfo, cannot set up E2EE cryptor"
        );
      this.handleReceiver(
        U.receiver,
        U.mediaStreamID,
        F,
        U.kind === "video" ? mimeTypeToVideoCodecString(q.mimeType) : void 0
      );
    }
  }
  setupE2EESender(U, F) {
    if (!isLocalTrack(U) || !F) {
      F || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(F, U.mediaStreamID, void 0);
  }
  handleReceiver(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const V = {
            kind: "decode",
            participantIdentity: q,
            trackId: F,
            codec: j,
          };
          U.transform = new RTCRtpScriptTransform(this.worker, V);
        } else {
          if (E2EE_FLAG in U && j) {
            const K = {
              kind: "updateCodec",
              data: { trackId: F, codec: j, participantIdentity: q },
            };
            this.worker.postMessage(K);
            return;
          }
          let V = U.writableStream,
            $ = U.readableStream;
          if (!V || !$) {
            const K = U.createEncodedStreams();
            (U.writableStream = K.writable),
              (V = K.writable),
              (U.readableStream = K.readable),
              ($ = K.readable);
          }
          const W = {
            kind: "decode",
            data: {
              readableStream: $,
              writableStream: V,
              trackId: F,
              codec: j,
              participantIdentity: q,
            },
          };
          this.worker.postMessage(W, [$, V]);
        }
        U[E2EE_FLAG] = !0;
      }
    });
  }
  handleSender(U, F, q) {
    var j;
    if (!(E2EE_FLAG in U || !this.worker)) {
      if (
        !(
          !((j = this.room) === null || j === void 0) &&
          j.localParticipant.identity
        ) ||
        this.room.localParticipant.identity === ""
      )
        throw TypeError(
          "local identity needs to be known in order to set up encrypted sender"
        );
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const V = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: F,
          codec: q,
        };
        U.transform = new RTCRtpScriptTransform(this.worker, V);
      } else {
        livekitLogger.info("initialize encoded streams");
        const V = U.createEncodedStreams(),
          $ = {
            kind: "encode",
            data: {
              readableStream: V.readable,
              writableStream: V.writable,
              codec: q,
              trackId: F,
              participantIdentity: this.room.localParticipant.identity,
            },
          };
        this.worker.postMessage($, [V.readable, V.writable]);
      }
      U[E2EE_FLAG] = !0;
    }
  }
}
const defaultId = "default";
class DeviceManager {
  constructor() {
    this._previousDevices = [];
  }
  static getInstance() {
    return (
      this.instance === void 0 && (this.instance = new DeviceManager()),
      this.instance
    );
  }
  get previousDevices() {
    return this._previousDevices;
  }
  getDevices(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return (function* () {
        var V;
        if (
          ((V = DeviceManager.userMediaPromiseMap) === null || V === void 0
            ? void 0
            : V.size) > 0
        ) {
          livekitLogger.debug("awaiting getUserMedia promise");
          try {
            F
              ? yield DeviceManager.userMediaPromiseMap.get(F)
              : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
          } catch {
            livekitLogger.warn("error waiting for media permissons");
          }
        }
        let $ = yield navigator.mediaDevices.enumerateDevices();
        if (
          j &&
          !(isSafari() && q.hasDeviceInUse(F)) &&
          ($.filter((K) => K.kind === F).length === 0 ||
            $.some((K) => {
              const G = K.label === "",
                H = F ? K.kind === F : !0;
              return G && H;
            }))
        ) {
          const K = {
              video: F !== "audioinput" && F !== "audiooutput",
              audio: F !== "videoinput" && { deviceId: { ideal: "default" } },
            },
            G = yield navigator.mediaDevices.getUserMedia(K);
          ($ = yield navigator.mediaDevices.enumerateDevices()),
            G.getTracks().forEach((H) => {
              H.stop();
            });
        }
        return (
          (q._previousDevices = $), F && ($ = $.filter((W) => W.kind === F)), $
        );
      })();
    });
  }
  normalizeDeviceId(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (F !== defaultId) return F;
      const j = yield this.getDevices(U),
        V = j.find((W) => W.deviceId === defaultId);
      if (!V) {
        livekitLogger.warn("could not reliably determine default device");
        return;
      }
      const $ = j.find(
        (W) => W.deviceId !== defaultId && W.groupId === (q ?? V.groupId)
      );
      if (!$) {
        livekitLogger.warn("could not reliably determine default device");
        return;
      }
      return $ == null ? void 0 : $.deviceId;
    });
  }
  hasDeviceInUse(U) {
    return U
      ? DeviceManager.userMediaPromiseMap.has(U)
      : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = new Map();
var QueueTaskStatus;
(function (B) {
  (B[(B.WAITING = 0)] = "WAITING"),
    (B[(B.RUNNING = 1)] = "RUNNING"),
    (B[(B.COMPLETED = 2)] = "COMPLETED");
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    (this.pendingTasks = new Map()),
      (this.taskMutex = new _$1()),
      (this.nextTaskIndex = 0);
  }
  run(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING,
      };
      this.pendingTasks.set(F.id, F);
      const q = yield this.taskMutex.lock();
      try {
        return (
          (F.executedAt = Date.now()),
          (F.status = QueueTaskStatus.RUNNING),
          yield U()
        );
      } finally {
        (F.status = QueueTaskStatus.COMPLETED),
          this.pendingTasks.delete(F.id),
          q();
      }
    });
  }
  flush() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.run(() => __awaiter$b(this, void 0, void 0, function* () {}));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
function createRtcUrl(B, U) {
  const F = new URL(toWebsocketUrl(B));
  return (
    U.forEach((q, j) => {
      F.searchParams.set(j, q);
    }),
    appendUrlPath(F, "rtc")
  );
}
function createValidateUrl(B) {
  const U = new URL(toHttpUrl(B));
  return appendUrlPath(U, "validate");
}
function ensureTrailingSlash(B) {
  return B.endsWith("/") ? B : "".concat(B, "/");
}
function appendUrlPath(B, U) {
  return (
    (B.pathname = "".concat(ensureTrailingSlash(B.pathname)).concat(U)),
    B.toString()
  );
}
const passThroughQueueSignals = [
  "syncState",
  "trickle",
  "offer",
  "answer",
  "simulate",
  "leave",
];
function canPassThroughQueue(B) {
  const U = passThroughQueueSignals.indexOf(B.case) >= 0;
  return (
    livekitLogger.trace("request allowed to bypass queue:", {
      canPass: U,
      req: B,
    }),
    U
  );
}
var SignalConnectionState;
(function (B) {
  (B[(B.CONNECTING = 0)] = "CONNECTING"),
    (B[(B.CONNECTED = 1)] = "CONNECTED"),
    (B[(B.RECONNECTING = 2)] = "RECONNECTING"),
    (B[(B.DISCONNECTING = 3)] = "DISCONNECTING"),
    (B[(B.DISCONNECTED = 4)] = "DISCONNECTED");
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return (
      this.state === SignalConnectionState.DISCONNECTING ||
      this.state === SignalConnectionState.DISCONNECTED
    );
  }
  get isEstablishingConnection() {
    return (
      this.state === SignalConnectionState.CONNECTING ||
      this.state === SignalConnectionState.RECONNECTING
    );
  }
  getNextRequestId() {
    return (this._requestId += 1), this._requestId;
  }
  constructor() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
      F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var q;
    (this.rtt = 0),
      (this.state = SignalConnectionState.DISCONNECTED),
      (this.log = livekitLogger),
      (this._requestId = 0),
      (this.resetCallbacks = () => {
        (this.onAnswer = void 0),
          (this.onLeave = void 0),
          (this.onLocalTrackPublished = void 0),
          (this.onLocalTrackUnpublished = void 0),
          (this.onNegotiateRequested = void 0),
          (this.onOffer = void 0),
          (this.onRemoteMuteChanged = void 0),
          (this.onSubscribedQualityUpdate = void 0),
          (this.onTokenRefresh = void 0),
          (this.onTrickle = void 0),
          (this.onClose = void 0);
      }),
      (this.log = getLogger(
        (q = F.loggerName) !== null && q !== void 0 ? q : LoggerNames.Signal
      )),
      (this.loggerContextCb = F.loggerContextCb),
      (this.useJSON = U),
      (this.requestQueue = new AsyncQueue()),
      (this.queuedRequests = []),
      (this.closingLock = new _$1()),
      (this.connectionLock = new _$1()),
      (this.state = SignalConnectionState.DISCONNECTED);
  }
  get logContext() {
    var U, F;
    return (F =
      (U = this.loggerContextCb) === null || U === void 0
        ? void 0
        : U.call(this)) !== null && F !== void 0
      ? F
      : {};
  }
  join(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return (
        (this.state = SignalConnectionState.CONNECTING),
        (this.options = q),
        yield this.connect(U, F, q, j)
      );
    });
  }
  reconnect(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn(
          "attempted to reconnect without signal options being set, ignoring",
          this.logContext
        );
        return;
      }
      return (
        (this.state = SignalConnectionState.RECONNECTING),
        this.clearPingInterval(),
        yield this.connect(
          U,
          F,
          Object.assign(Object.assign({}, this.options), {
            reconnect: !0,
            sid: q,
            reconnectReason: j,
          })
        )
      );
    });
  }
  connect(U, F, q, j) {
    this.connectOptions = q;
    const V = getClientInfo(),
      $ = createConnectionParams(F, V, q),
      W = createRtcUrl(U, $),
      K = createValidateUrl(W);
    return new Promise((G, H) =>
      __awaiter$b(this, void 0, void 0, function* () {
        const Q = yield this.connectionLock.lock();
        try {
          const z = () =>
              __awaiter$b(this, void 0, void 0, function* () {
                this.close(),
                  clearTimeout(Y),
                  H(
                    new ConnectionError(
                      "room connection has been cancelled (signal)",
                      ConnectionErrorReason.Cancelled
                    )
                  );
              }),
            Y = setTimeout(() => {
              this.close(),
                H(
                  new ConnectionError(
                    "room connection has timed out (signal)",
                    ConnectionErrorReason.ServerUnreachable
                  )
                );
            }, q.websocketTimeout);
          j != null && j.aborted && z(),
            j == null || j.addEventListener("abort", z);
          const X = new URL(W);
          X.searchParams.has("access_token") &&
            X.searchParams.set("access_token", "<redacted>"),
            this.log.debug(
              "connecting to ".concat(X),
              Object.assign(
                { reconnect: q.reconnect, reconnectReason: q.reconnectReason },
                this.logContext
              )
            ),
            this.ws && (yield this.close(!1)),
            (this.ws = new WebSocket(W)),
            (this.ws.binaryType = "arraybuffer"),
            (this.ws.onopen = () => {
              clearTimeout(Y);
            }),
            (this.ws.onerror = (Z) =>
              __awaiter$b(this, void 0, void 0, function* () {
                if (this.state !== SignalConnectionState.CONNECTED) {
                  (this.state = SignalConnectionState.DISCONNECTED),
                    clearTimeout(Y);
                  try {
                    const se = yield fetch(K);
                    if (se.status.toFixed(0).startsWith("4")) {
                      const ee = yield se.text();
                      H(
                        new ConnectionError(
                          ee,
                          ConnectionErrorReason.NotAllowed,
                          se.status
                        )
                      );
                    } else
                      H(
                        new ConnectionError(
                          "Encountered unknown websocket error during connection: ".concat(
                            Z.toString()
                          ),
                          ConnectionErrorReason.InternalError,
                          se.status
                        )
                      );
                  } catch (se) {
                    H(
                      new ConnectionError(
                        se instanceof Error
                          ? se.message
                          : "server was not reachable",
                        ConnectionErrorReason.ServerUnreachable
                      )
                    );
                  }
                  return;
                }
                this.handleWSError(Z);
              })),
            (this.ws.onmessage = (Z) =>
              __awaiter$b(this, void 0, void 0, function* () {
                var se, ee, ie;
                let re;
                if (typeof Z.data == "string") {
                  const te = JSON.parse(Z.data);
                  re = SignalResponse.fromJson(te, { ignoreUnknownFields: !0 });
                } else if (Z.data instanceof ArrayBuffer)
                  re = SignalResponse.fromBinary(new Uint8Array(Z.data));
                else {
                  this.log.error(
                    "could not decode websocket message: ".concat(
                      typeof Z.data
                    ),
                    this.logContext
                  );
                  return;
                }
                if (this.state !== SignalConnectionState.CONNECTED) {
                  let te = !1;
                  if (
                    (((se = re.message) === null || se === void 0
                      ? void 0
                      : se.case) === "join"
                      ? ((this.state = SignalConnectionState.CONNECTED),
                        j == null || j.removeEventListener("abort", z),
                        (this.pingTimeoutDuration =
                          re.message.value.pingTimeout),
                        (this.pingIntervalDuration =
                          re.message.value.pingInterval),
                        this.pingTimeoutDuration &&
                          this.pingTimeoutDuration > 0 &&
                          (this.log.debug(
                            "ping config",
                            Object.assign(Object.assign({}, this.logContext), {
                              timeout: this.pingTimeoutDuration,
                              interval: this.pingIntervalDuration,
                            })
                          ),
                          this.startPingInterval()),
                        G(re.message.value))
                      : this.state === SignalConnectionState.RECONNECTING &&
                        re.message.case !== "leave"
                      ? ((this.state = SignalConnectionState.CONNECTED),
                        j == null || j.removeEventListener("abort", z),
                        this.startPingInterval(),
                        ((ee = re.message) === null || ee === void 0
                          ? void 0
                          : ee.case) === "reconnect"
                          ? G(re.message.value)
                          : (this.log.debug(
                              "declaring signal reconnected without reconnect response received",
                              this.logContext
                            ),
                            G(void 0),
                            (te = !0)))
                      : this.isEstablishingConnection &&
                        re.message.case === "leave"
                      ? H(
                          new ConnectionError(
                            "Received leave request while trying to (re)connect",
                            ConnectionErrorReason.LeaveRequest,
                            void 0,
                            re.message.value.reason
                          )
                        )
                      : q.reconnect ||
                        H(
                          new ConnectionError(
                            "did not receive join response, got ".concat(
                              (ie = re.message) === null || ie === void 0
                                ? void 0
                                : ie.case,
                              " instead"
                            ),
                            ConnectionErrorReason.InternalError
                          )
                        ),
                    !te)
                  )
                    return;
                }
                this.signalLatency && (yield sleep$1(this.signalLatency)),
                  this.handleSignalResponse(re);
              })),
            (this.ws.onclose = (Z) => {
              this.isEstablishingConnection &&
                H(
                  new ConnectionError(
                    "Websocket got closed during a (re)connection attempt",
                    ConnectionErrorReason.InternalError
                  )
                ),
                this.log.warn(
                  "websocket closed",
                  Object.assign(Object.assign({}, this.logContext), {
                    reason: Z.reason,
                    code: Z.code,
                    wasClean: Z.wasClean,
                    state: this.state,
                  })
                ),
                this.handleOnClose(Z.reason);
            });
        } finally {
          Q();
        }
      })
    );
  }
  close() {
    return __awaiter$b(this, arguments, void 0, function () {
      var U = this;
      let F =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return (function* () {
        const q = yield U.closingLock.lock();
        try {
          if (
            (U.clearPingInterval(),
            F && (U.state = SignalConnectionState.DISCONNECTING),
            U.ws)
          ) {
            (U.ws.onmessage = null),
              (U.ws.onopen = null),
              (U.ws.onclose = null);
            const j = new Promise((V) => {
              U.ws
                ? (U.ws.onclose = () => {
                    V();
                  })
                : V();
            });
            U.ws.readyState < U.ws.CLOSING &&
              (U.ws.close(), yield Promise.race([j, sleep$1(250)])),
              (U.ws = void 0);
          }
        } finally {
          F && (U.state = SignalConnectionState.DISCONNECTED), q();
        }
      })();
    });
  }
  sendOffer(U) {
    this.log.debug(
      "sending offer",
      Object.assign(Object.assign({}, this.logContext), { offerSdp: U.sdp })
    ),
      this.sendRequest({ case: "offer", value: toProtoSessionDescription(U) });
  }
  sendAnswer(U) {
    return (
      this.log.debug(
        "sending answer",
        Object.assign(Object.assign({}, this.logContext), { answerSdp: U.sdp })
      ),
      this.sendRequest({ case: "answer", value: toProtoSessionDescription(U) })
    );
  }
  sendIceCandidate(U, F) {
    return (
      this.log.debug(
        "sending ice candidate",
        Object.assign(Object.assign({}, this.logContext), { candidate: U })
      ),
      this.sendRequest({
        case: "trickle",
        value: new TrickleRequest({
          candidateInit: JSON.stringify(U),
          target: F,
        }),
      })
    );
  }
  sendMuteTrack(U, F) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({ sid: U, muted: F }),
    });
  }
  sendAddTrack(U) {
    return this.sendRequest({ case: "addTrack", value: U });
  }
  sendUpdateLocalMetadata(U, F) {
    return __awaiter$b(this, arguments, void 0, function (q, j) {
      var V = this;
      let $ =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return (function* () {
        const W = V.getNextRequestId();
        return (
          yield V.sendRequest({
            case: "updateMetadata",
            value: new UpdateParticipantMetadata({
              requestId: W,
              metadata: q,
              name: j,
              attributes: $,
            }),
          }),
          W
        );
      })();
    });
  }
  sendUpdateTrackSettings(U) {
    this.sendRequest({ case: "trackSetting", value: U });
  }
  sendUpdateSubscription(U) {
    return this.sendRequest({ case: "subscription", value: U });
  }
  sendSyncState(U) {
    return this.sendRequest({ case: "syncState", value: U });
  }
  sendUpdateVideoLayers(U, F) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({ trackSid: U, layers: F }),
    });
  }
  sendUpdateSubscriptionPermissions(U, F) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: U,
        trackPermissions: F,
      }),
    });
  }
  sendSimulateScenario(U) {
    return this.sendRequest({ case: "simulate", value: U });
  }
  sendPing() {
    return Promise.all([
      this.sendRequest({ case: "ping", value: protoInt64.parse(Date.now()) }),
      this.sendRequest({
        case: "pingReq",
        value: new Ping({
          timestamp: protoInt64.parse(Date.now()),
          rtt: protoInt64.parse(this.rtt),
        }),
      }),
    ]);
  }
  sendUpdateLocalAudioTrack(U, F) {
    return this.sendRequest({
      case: "updateAudioTrack",
      value: new UpdateLocalAudioTrack({ trackSid: U, features: F }),
    });
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        reason: DisconnectReason.CLIENT_INITIATED,
        action: LeaveRequest_Action.DISCONNECT,
      }),
    });
  }
  sendRequest(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      return (function* () {
        if (
          !j &&
          !canPassThroughQueue(F) &&
          q.state === SignalConnectionState.RECONNECTING
        ) {
          q.queuedRequests.push(() =>
            __awaiter$b(q, void 0, void 0, function* () {
              yield this.sendRequest(F, !0);
            })
          );
          return;
        }
        if (
          (j || (yield q.requestQueue.flush()),
          q.signalLatency && (yield sleep$1(q.signalLatency)),
          !q.ws || q.ws.readyState !== q.ws.OPEN)
        ) {
          q.log.error(
            "cannot send signal request before connected, type: ".concat(
              F == null ? void 0 : F.case
            ),
            q.logContext
          );
          return;
        }
        const $ = new SignalRequest({ message: F });
        try {
          q.useJSON ? q.ws.send($.toJsonString()) : q.ws.send($.toBinary());
        } catch (W) {
          q.log.error(
            "error sending signal message",
            Object.assign(Object.assign({}, q.logContext), { error: W })
          );
        }
      })();
    });
  }
  handleSignalResponse(U) {
    var F, q;
    const j = U.message;
    if (j == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let V = !1;
    if (j.case === "answer") {
      const $ = fromProtoSessionDescription(j.value);
      this.onAnswer && this.onAnswer($);
    } else if (j.case === "offer") {
      const $ = fromProtoSessionDescription(j.value);
      this.onOffer && this.onOffer($);
    } else if (j.case === "trickle") {
      const $ = JSON.parse(j.value.candidateInit);
      this.onTrickle && this.onTrickle($, j.value.target);
    } else
      j.case === "update"
        ? this.onParticipantUpdate &&
          this.onParticipantUpdate(
            (F = j.value.participants) !== null && F !== void 0 ? F : []
          )
        : j.case === "trackPublished"
        ? this.onLocalTrackPublished && this.onLocalTrackPublished(j.value)
        : j.case === "speakersChanged"
        ? this.onSpeakersChanged &&
          this.onSpeakersChanged(
            (q = j.value.speakers) !== null && q !== void 0 ? q : []
          )
        : j.case === "leave"
        ? this.onLeave && this.onLeave(j.value)
        : j.case === "mute"
        ? this.onRemoteMuteChanged &&
          this.onRemoteMuteChanged(j.value.sid, j.value.muted)
        : j.case === "roomUpdate"
        ? this.onRoomUpdate && j.value.room && this.onRoomUpdate(j.value.room)
        : j.case === "connectionQuality"
        ? this.onConnectionQuality && this.onConnectionQuality(j.value)
        : j.case === "streamStateUpdate"
        ? this.onStreamStateUpdate && this.onStreamStateUpdate(j.value)
        : j.case === "subscribedQualityUpdate"
        ? this.onSubscribedQualityUpdate &&
          this.onSubscribedQualityUpdate(j.value)
        : j.case === "subscriptionPermissionUpdate"
        ? this.onSubscriptionPermissionUpdate &&
          this.onSubscriptionPermissionUpdate(j.value)
        : j.case === "refreshToken"
        ? this.onTokenRefresh && this.onTokenRefresh(j.value)
        : j.case === "trackUnpublished"
        ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(j.value)
        : j.case === "subscriptionResponse"
        ? this.onSubscriptionError && this.onSubscriptionError(j.value)
        : j.case === "pong" ||
          (j.case === "pongResp"
            ? ((this.rtt =
                Date.now() -
                Number.parseInt(j.value.lastPingTimestamp.toString())),
              this.resetPingTimeout(),
              (V = !0))
            : j.case === "requestResponse"
            ? this.onRequestResponse && this.onRequestResponse(j.value)
            : j.case === "trackSubscribed"
            ? this.onLocalTrackSubscribed &&
              this.onLocalTrackSubscribed(j.value.trackSid)
            : this.log.debug(
                "unsupported message",
                Object.assign(Object.assign({}, this.logContext), {
                  msgCase: j.case,
                })
              ));
    V || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const U = this.queuedRequests.shift();
      U && this.requestQueue.run(U);
    }
  }
  handleOnClose(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED) return;
      const F = this.onClose;
      yield this.close(),
        this.log.debug(
          "websocket connection closed: ".concat(U),
          Object.assign(Object.assign({}, this.logContext), { reason: U })
        ),
        F && F(U);
    });
  }
  handleWSError(U) {
    this.log.error(
      "websocket error",
      Object.assign(Object.assign({}, this.logContext), { error: U })
    );
  }
  resetPingTimeout() {
    if ((this.clearPingTimeout(), !this.pingTimeoutDuration)) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn(
        "ping timeout triggered. last pong received at: ".concat(
          new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()
        ),
        this.logContext
      ),
        this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (
      (this.clearPingInterval(),
      this.resetPingTimeout(),
      !this.pingIntervalDuration)
    ) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext),
      (this.pingInterval = CriticalTimers.setInterval(() => {
        this.sendPing();
      }, this.pingIntervalDuration * 1e3));
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext),
      this.clearPingTimeout(),
      this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(B) {
  const U = { type: "offer", sdp: B.sdp };
  switch (B.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      U.type = B.type;
      break;
  }
  return U;
}
function toProtoSessionDescription(B) {
  return new SessionDescription({ sdp: B.sdp, type: B.type });
}
function createConnectionParams(B, U, F) {
  var q;
  const j = new URLSearchParams();
  return (
    j.set("access_token", B),
    F.reconnect && (j.set("reconnect", "1"), F.sid && j.set("sid", F.sid)),
    j.set("auto_subscribe", F.autoSubscribe ? "1" : "0"),
    j.set("sdk", isReactNative() ? "reactnative" : "js"),
    j.set("version", U.version),
    j.set("protocol", U.protocol.toString()),
    U.deviceModel && j.set("device_model", U.deviceModel),
    U.os && j.set("os", U.os),
    U.osVersion && j.set("os_version", U.osVersion),
    U.browser && j.set("browser", U.browser),
    U.browserVersion && j.set("browser_version", U.browserVersion),
    F.adaptiveStream && j.set("adaptive_stream", "1"),
    F.reconnectReason &&
      j.set("reconnect_reason", F.reconnectReason.toString()),
    !((q = navigator.connection) === null || q === void 0) &&
      q.type &&
      j.set("network", navigator.connection.type),
    j
  );
}
var lib = {},
  parser = {},
  grammar = { exports: {} },
  hasRequiredGrammar;
function requireGrammar() {
  if (hasRequiredGrammar) return grammar.exports;
  hasRequiredGrammar = 1;
  var B = (grammar.exports = {
    v: [{ name: "version", reg: /^(\d*)$/ }],
    o: [
      {
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: [
          "username",
          "sessionId",
          "sessionVersion",
          "netType",
          "ipVer",
          "address",
        ],
        format: "%s %s %d %s IP%d %s",
      },
    ],
    s: [{ name: "name" }],
    i: [{ name: "description" }],
    u: [{ name: "uri" }],
    e: [{ name: "email" }],
    p: [{ name: "phone" }],
    z: [{ name: "timezones" }],
    r: [{ name: "repeats" }],
    t: [
      {
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d",
      },
    ],
    c: [
      {
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s",
      },
    ],
    b: [
      {
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s",
      },
    ],
    m: [
      {
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s",
      },
    ],
    a: [
      {
        push: "rtp",
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: ["payload", "codec", "rate", "encoding"],
        format: function (U) {
          return U.encoding
            ? "rtpmap:%d %s/%s/%s"
            : U.rate
            ? "rtpmap:%d %s/%s"
            : "rtpmap:%d %s";
        },
      },
      {
        push: "fmtp",
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: ["payload", "config"],
        format: "fmtp:%d %s",
      },
      { name: "control", reg: /^control:(.*)/, format: "control:%s" },
      {
        name: "rtcp",
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: ["port", "netType", "ipVer", "address"],
        format: function (U) {
          return U.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        },
      },
      {
        push: "rtcpFbTrrInt",
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: ["payload", "value"],
        format: "rtcp-fb:%s trr-int %d",
      },
      {
        push: "rtcpFb",
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: ["payload", "type", "subtype"],
        format: function (U) {
          return U.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        },
      },
      {
        push: "ext",
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: ["value", "direction", "encrypt-uri", "uri", "config"],
        format: function (U) {
          return (
            "extmap:%d" +
            (U.direction ? "/%s" : "%v") +
            (U["encrypt-uri"] ? " %s" : "%v") +
            " %s" +
            (U.config ? " %s" : "")
          );
        },
      },
      { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ },
      {
        push: "crypto",
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: ["id", "suite", "config", "sessionConfig"],
        format: function (U) {
          return U.sessionConfig != null
            ? "crypto:%d %s %s %s"
            : "crypto:%d %s %s";
        },
      },
      { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" },
      {
        name: "connectionType",
        reg: /^connection:(new|existing)/,
        format: "connection:%s",
      },
      { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" },
      { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" },
      { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" },
      {
        name: "maxptime",
        reg: /^maxptime:(\d*(?:\.\d*)*)/,
        format: "maxptime:%d",
      },
      { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ },
      { name: "icelite", reg: /^(ice-lite)/ },
      { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" },
      { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" },
      {
        name: "fingerprint",
        reg: /^fingerprint:(\S*) (\S*)/,
        names: ["type", "hash"],
        format: "fingerprint:%s %s",
      },
      {
        push: "candidates",
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: [
          "foundation",
          "component",
          "transport",
          "priority",
          "ip",
          "port",
          "type",
          "raddr",
          "rport",
          "tcptype",
          "generation",
          "network-id",
          "network-cost",
        ],
        format: function (U) {
          var F = "candidate:%s %d %s %d %s %d typ %s";
          return (
            (F += U.raddr != null ? " raddr %s rport %d" : "%v%v"),
            (F += U.tcptype != null ? " tcptype %s" : "%v"),
            U.generation != null && (F += " generation %d"),
            (F += U["network-id"] != null ? " network-id %d" : "%v"),
            (F += U["network-cost"] != null ? " network-cost %d" : "%v"),
            F
          );
        },
      },
      { name: "endOfCandidates", reg: /^(end-of-candidates)/ },
      {
        name: "remoteCandidates",
        reg: /^remote-candidates:(.*)/,
        format: "remote-candidates:%s",
      },
      {
        name: "iceOptions",
        reg: /^ice-options:(\S*)/,
        format: "ice-options:%s",
      },
      {
        push: "ssrcs",
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: ["id", "attribute", "value"],
        format: function (U) {
          var F = "ssrc:%d";
          return (
            U.attribute != null &&
              ((F += " %s"), U.value != null && (F += ":%s")),
            F
          );
        },
      },
      {
        push: "ssrcGroups",
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: ["semantics", "ssrcs"],
        format: "ssrc-group:%s %s",
      },
      {
        name: "msidSemantic",
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: ["semantic", "token"],
        format: "msid-semantic: %s %s",
      },
      {
        push: "groups",
        reg: /^group:(\w*) (.*)/,
        names: ["type", "mids"],
        format: "group:%s %s",
      },
      { name: "rtcpMux", reg: /^(rtcp-mux)/ },
      { name: "rtcpRsize", reg: /^(rtcp-rsize)/ },
      {
        name: "sctpmap",
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: ["sctpmapNumber", "app", "maxMessageSize"],
        format: function (U) {
          return U.maxMessageSize != null
            ? "sctpmap:%s %s %s"
            : "sctpmap:%s %s";
        },
      },
      {
        name: "xGoogleFlag",
        reg: /^x-google-flag:([^\s]*)/,
        format: "x-google-flag:%s",
      },
      {
        push: "rids",
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: ["id", "direction", "params"],
        format: function (U) {
          return U.params ? "rid:%s %s %s" : "rid:%s %s";
        },
      },
      {
        push: "imageattrs",
        reg: new RegExp(
          "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
        ),
        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
        format: function (U) {
          return "imageattr:%s %s %s" + (U.dir2 ? " %s %s" : "");
        },
      },
      {
        name: "simulcast",
        reg: new RegExp(
          "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
        ),
        names: ["dir1", "list1", "dir2", "list2"],
        format: function (U) {
          return "simulcast:%s %s" + (U.dir2 ? " %s %s" : "");
        },
      },
      {
        name: "simulcast_03",
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: ["value"],
        format: "simulcast: %s",
      },
      {
        name: "framerate",
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: "framerate:%s",
      },
      {
        name: "sourceFilter",
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: [
          "filterMode",
          "netType",
          "addressTypes",
          "destAddress",
          "srcList",
        ],
        format: "source-filter: %s %s %s %s %s",
      },
      { name: "bundleOnly", reg: /^(bundle-only)/ },
      { name: "label", reg: /^label:(.+)/, format: "label:%s" },
      { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" },
      {
        name: "maxMessageSize",
        reg: /^max-message-size:(\d+)$/,
        format: "max-message-size:%s",
      },
      {
        push: "tsRefClocks",
        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
        names: ["clksrc", "clksrcExt"],
        format: function (U) {
          return "ts-refclk:%s" + (U.clksrcExt != null ? "=%s" : "");
        },
      },
      {
        name: "mediaClk",
        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
        names: [
          "id",
          "mediaClockName",
          "mediaClockValue",
          "rateNumerator",
          "rateDenominator",
        ],
        format: function (U) {
          var F = "mediaclk:";
          return (
            (F += U.id != null ? "id=%s %s" : "%v%s"),
            (F += U.mediaClockValue != null ? "=%s" : ""),
            (F += U.rateNumerator != null ? " rate=%s" : ""),
            (F += U.rateDenominator != null ? "/%s" : ""),
            F
          );
        },
      },
      { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" },
      { name: "content", reg: /^content:(.+)/, format: "content:%s" },
      {
        name: "bfcpFloorCtrl",
        reg: /^floorctrl:(c-only|s-only|c-s)/,
        format: "floorctrl:%s",
      },
      { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" },
      { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" },
      {
        name: "bfcpFloorId",
        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
        names: ["id", "mStream"],
        format: "floorid:%s mstrm:%s",
      },
      { push: "invalid", names: ["value"] },
    ],
  });
  return (
    Object.keys(B).forEach(function (U) {
      var F = B[U];
      F.forEach(function (q) {
        q.reg || (q.reg = /(.*)/), q.format || (q.format = "%s");
      });
    }),
    grammar.exports
  );
}
var hasRequiredParser;
function requireParser() {
  return (
    hasRequiredParser ||
      ((hasRequiredParser = 1),
      (function (B) {
        var U = function (W) {
            return String(Number(W)) === W ? Number(W) : W;
          },
          F = function (W, K, G, H) {
            if (H && !G) K[H] = U(W[1]);
            else
              for (var Q = 0; Q < G.length; Q += 1)
                W[Q + 1] != null && (K[G[Q]] = U(W[Q + 1]));
          },
          q = function (W, K, G) {
            var H = W.name && W.names;
            W.push && !K[W.push]
              ? (K[W.push] = [])
              : H && !K[W.name] && (K[W.name] = {});
            var Q = W.push ? {} : H ? K[W.name] : K;
            F(G.match(W.reg), Q, W.names, W.name), W.push && K[W.push].push(Q);
          },
          j = requireGrammar(),
          V = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        B.parse = function (W) {
          var K = {},
            G = [],
            H = K;
          return (
            W.split(/(\r\n|\r|\n)/)
              .filter(V)
              .forEach(function (Q) {
                var z = Q[0],
                  Y = Q.slice(2);
                z === "m" &&
                  (G.push({ rtp: [], fmtp: [] }), (H = G[G.length - 1]));
                for (var X = 0; X < (j[z] || []).length; X += 1) {
                  var Z = j[z][X];
                  if (Z.reg.test(Y)) return q(Z, H, Y);
                }
              }),
            (K.media = G),
            K
          );
        };
        var $ = function (W, K) {
          var G = K.split(/=(.+)/, 2);
          return (
            G.length === 2
              ? (W[G[0]] = U(G[1]))
              : G.length === 1 && K.length > 1 && (W[G[0]] = void 0),
            W
          );
        };
        (B.parseParams = function (W) {
          return W.split(/;\s?/).reduce($, {});
        }),
          (B.parseFmtpConfig = B.parseParams),
          (B.parsePayloads = function (W) {
            return W.toString().split(" ").map(Number);
          }),
          (B.parseRemoteCandidates = function (W) {
            for (
              var K = [], G = W.split(" ").map(U), H = 0;
              H < G.length;
              H += 3
            )
              K.push({ component: G[H], ip: G[H + 1], port: G[H + 2] });
            return K;
          }),
          (B.parseImageAttributes = function (W) {
            return W.split(" ").map(function (K) {
              return K.substring(1, K.length - 1)
                .split(",")
                .reduce($, {});
            });
          }),
          (B.parseSimulcastStreamList = function (W) {
            return W.split(";").map(function (K) {
              return K.split(",").map(function (G) {
                var H,
                  Q = !1;
                return (
                  G[0] !== "~"
                    ? (H = U(G))
                    : ((H = U(G.substring(1, G.length))), (Q = !0)),
                  { scid: H, paused: Q }
                );
              });
            });
          });
      })(parser)),
    parser
  );
}
var writer$1, hasRequiredWriter$1;
function requireWriter$1() {
  if (hasRequiredWriter$1) return writer$1;
  hasRequiredWriter$1 = 1;
  var B = requireGrammar(),
    U = /%[sdv%]/g,
    F = function ($) {
      var W = 1,
        K = arguments,
        G = K.length;
      return $.replace(U, function (H) {
        if (W >= G) return H;
        var Q = K[W];
        switch (((W += 1), H)) {
          case "%%":
            return "%";
          case "%s":
            return String(Q);
          case "%d":
            return Number(Q);
          case "%v":
            return "";
        }
      });
    },
    q = function ($, W, K) {
      var G =
          W.format instanceof Function
            ? W.format(W.push ? K : K[W.name])
            : W.format,
        H = [$ + "=" + G];
      if (W.names)
        for (var Q = 0; Q < W.names.length; Q += 1) {
          var z = W.names[Q];
          W.name ? H.push(K[W.name][z]) : H.push(K[W.names[Q]]);
        }
      else H.push(K[W.name]);
      return F.apply(null, H);
    },
    j = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
    V = ["i", "c", "b", "a"];
  return (
    (writer$1 = function ($, W) {
      (W = W || {}),
        $.version == null && ($.version = 0),
        $.name == null && ($.name = " "),
        $.media.forEach(function (Q) {
          Q.payloads == null && (Q.payloads = "");
        });
      var K = W.outerOrder || j,
        G = W.innerOrder || V,
        H = [];
      return (
        K.forEach(function (Q) {
          B[Q].forEach(function (z) {
            z.name in $ && $[z.name] != null
              ? H.push(q(Q, z, $))
              : z.push in $ &&
                $[z.push] != null &&
                $[z.push].forEach(function (Y) {
                  H.push(q(Q, z, Y));
                });
          });
        }),
        $.media.forEach(function (Q) {
          H.push(q("m", B.m[0], Q)),
            G.forEach(function (z) {
              B[z].forEach(function (Y) {
                Y.name in Q && Q[Y.name] != null
                  ? H.push(q(z, Y, Q))
                  : Y.push in Q &&
                    Q[Y.push] != null &&
                    Q[Y.push].forEach(function (X) {
                      H.push(q(z, Y, X));
                    });
              });
            });
        }),
        H.join(`\r
`) +
          `\r
`
      );
    }),
    writer$1
  );
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var B = requireParser(),
    U = requireWriter$1(),
    F = requireGrammar();
  return (
    (lib.grammar = F),
    (lib.write = U),
    (lib.parse = B.parse),
    (lib.parseParams = B.parseParams),
    (lib.parseFmtpConfig = B.parseFmtpConfig),
    (lib.parsePayloads = B.parsePayloads),
    (lib.parseRemoteCandidates = B.parseRemoteCandidates),
    (lib.parseImageAttributes = B.parseImageAttributes),
    (lib.parseSimulcastStreamList = B.parseSimulcastStreamList),
    lib
  );
}
var libExports = requireLib();
function r$1(B, U, F) {
  var q, j, V;
  U === void 0 && (U = 50), F === void 0 && (F = {});
  var $ = (q = F.isImmediate) != null && q,
    W = (j = F.callback) != null && j,
    K = F.maxWait,
    G = Date.now(),
    H = [];
  function Q() {
    if (K !== void 0) {
      var Y = Date.now() - G;
      if (Y + U >= K) return K - Y;
    }
    return U;
  }
  var z = function () {
    var Y = [].slice.call(arguments),
      X = this;
    return new Promise(function (Z, se) {
      var ee = $ && V === void 0;
      if (
        (V !== void 0 && clearTimeout(V),
        (V = setTimeout(function () {
          if (((V = void 0), (G = Date.now()), !$)) {
            var re = B.apply(X, Y);
            W && W(re),
              H.forEach(function (te) {
                return (0, te.resolve)(re);
              }),
              (H = []);
          }
        }, Q())),
        ee)
      ) {
        var ie = B.apply(X, Y);
        return W && W(ie), Z(ie);
      }
      H.push({ resolve: Z, reject: se });
    });
  };
  return (
    (z.cancel = function (Y) {
      V !== void 0 && clearTimeout(V),
        H.forEach(function (X) {
          return (0, X.reject)(Y);
        }),
        (H = []);
    }),
    z
  );
}
const startBitrateForSVC = 0.7,
  debounceInterval = 20,
  PCEvents = {
    NegotiationStarted: "negotiationStarted",
    NegotiationComplete: "negotiationComplete",
    RTPVideoPayloadTypes: "rtpVideoPayloadTypes",
  };
class PCTransport extends eventsExports$1.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(U) {
    let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var q;
    super(),
      (this.log = livekitLogger),
      (this.ddExtID = 0),
      (this.pendingCandidates = []),
      (this.restartingIce = !1),
      (this.renegotiate = !1),
      (this.trackBitrates = []),
      (this.remoteStereoMids = []),
      (this.remoteNackMids = []),
      (this.negotiate = r$1(
        (j) =>
          __awaiter$b(this, void 0, void 0, function* () {
            this.emit(PCEvents.NegotiationStarted);
            try {
              yield this.createAndSendOffer();
            } catch (V) {
              if (j) j(V);
              else throw V;
            }
          }),
        debounceInterval
      )),
      (this.close = () => {
        this._pc &&
          (this._pc.close(),
          (this._pc.onconnectionstatechange = null),
          (this._pc.oniceconnectionstatechange = null),
          (this._pc.onicegatheringstatechange = null),
          (this._pc.ondatachannel = null),
          (this._pc.onnegotiationneeded = null),
          (this._pc.onsignalingstatechange = null),
          (this._pc.onicecandidate = null),
          (this._pc.ondatachannel = null),
          (this._pc.ontrack = null),
          (this._pc.onconnectionstatechange = null),
          (this._pc.oniceconnectionstatechange = null),
          (this._pc = null));
      }),
      (this.log = getLogger(
        (q = F.loggerName) !== null && q !== void 0
          ? q
          : LoggerNames.PCTransport
      )),
      (this.loggerOptions = F),
      (this.config = U),
      (this._pc = this.createPC());
  }
  createPC() {
    const U = new RTCPeerConnection(this.config);
    return (
      (U.onicecandidate = (F) => {
        var q;
        F.candidate &&
          ((q = this.onIceCandidate) === null ||
            q === void 0 ||
            q.call(this, F.candidate));
      }),
      (U.onicecandidateerror = (F) => {
        var q;
        (q = this.onIceCandidateError) === null ||
          q === void 0 ||
          q.call(this, F);
      }),
      (U.oniceconnectionstatechange = () => {
        var F;
        (F = this.onIceConnectionStateChange) === null ||
          F === void 0 ||
          F.call(this, U.iceConnectionState);
      }),
      (U.onsignalingstatechange = () => {
        var F;
        (F = this.onSignalingStatechange) === null ||
          F === void 0 ||
          F.call(this, U.signalingState);
      }),
      (U.onconnectionstatechange = () => {
        var F;
        (F = this.onConnectionStateChange) === null ||
          F === void 0 ||
          F.call(this, U.connectionState);
      }),
      (U.ondatachannel = (F) => {
        var q;
        (q = this.onDataChannel) === null || q === void 0 || q.call(this, F);
      }),
      (U.ontrack = (F) => {
        var q;
        (q = this.onTrack) === null || q === void 0 || q.call(this, F);
      }),
      U
    );
  }
  get logContext() {
    var U, F;
    return Object.assign(
      {},
      (F = (U = this.loggerOptions).loggerContextCb) === null || F === void 0
        ? void 0
        : F.call(U)
    );
  }
  get isICEConnected() {
    return (
      this._pc !== null &&
      (this.pc.iceConnectionState === "connected" ||
        this.pc.iceConnectionState === "completed")
    );
  }
  addIceCandidate(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(U);
      this.pendingCandidates.push(U);
    });
  }
  setRemoteDescription(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F;
      let q;
      if (U.type === "offer") {
        let { stereoMids: j, nackMids: V } =
          extractStereoAndNackAudioFromOffer(U);
        (this.remoteStereoMids = j), (this.remoteNackMids = V);
      } else if (U.type === "answer") {
        const j = libExports.parse(
          (F = U.sdp) !== null && F !== void 0 ? F : ""
        );
        j.media.forEach((V) => {
          V.type === "audio" &&
            this.trackBitrates.some(($) => {
              if (!$.transceiver || V.mid != $.transceiver.mid) return !1;
              let W = 0;
              if (
                (V.rtp.some((G) =>
                  G.codec.toUpperCase() === $.codec.toUpperCase()
                    ? ((W = G.payload), !0)
                    : !1
                ),
                W === 0)
              )
                return !0;
              let K = !1;
              for (const G of V.fmtp)
                if (G.payload === W) {
                  (G.config = G.config
                    .split(";")
                    .filter((H) => !H.includes("maxaveragebitrate"))
                    .join(";")),
                    $.maxbr > 0 &&
                      (G.config += ";maxaveragebitrate=".concat($.maxbr * 1e3)),
                    (K = !0);
                  break;
                }
              return (
                K ||
                  ($.maxbr > 0 &&
                    V.fmtp.push({
                      payload: W,
                      config: "maxaveragebitrate=".concat($.maxbr * 1e3),
                    })),
                !0
              );
            });
        }),
          (q = libExports.write(j));
      }
      yield this.setMungedSDP(U, q, !0),
        this.pendingCandidates.forEach((j) => {
          this.pc.addIceCandidate(j);
        }),
        (this.pendingCandidates = []),
        (this.restartingIce = !1),
        this.renegotiate
          ? ((this.renegotiate = !1), yield this.createAndSendOffer())
          : U.type === "answer" &&
            (this.emit(PCEvents.NegotiationComplete),
            U.sdp &&
              libExports.parse(U.sdp).media.forEach((V) => {
                V.type === "video" &&
                  this.emit(PCEvents.RTPVideoPayloadTypes, V.rtp);
              }));
    });
  }
  createAndSendOffer(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F;
      if (this.onOffer === void 0) return;
      if (
        (U != null &&
          U.iceRestart &&
          (this.log.debug("restarting ICE", this.logContext),
          (this.restartingIce = !0)),
        this._pc && this._pc.signalingState === "have-local-offer")
      ) {
        const V = this._pc.remoteDescription;
        if (U != null && U.iceRestart && V)
          yield this._pc.setRemoteDescription(V);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn(
          "could not createOffer with closed peer connection",
          this.logContext
        );
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const q = yield this.pc.createOffer(U);
      this.log.debug(
        "original offer",
        Object.assign({ sdp: q.sdp }, this.logContext)
      );
      const j = libExports.parse((F = q.sdp) !== null && F !== void 0 ? F : "");
      j.media.forEach((V) => {
        ensureIPAddrMatchVersion(V),
          V.type === "audio"
            ? ensureAudioNackAndStereo(V, [], [])
            : V.type === "video" &&
              this.trackBitrates.some(($) => {
                if (!V.msid || !$.cid || !V.msid.includes($.cid)) return !1;
                let W = 0;
                if (
                  (V.rtp.some((G) =>
                    G.codec.toUpperCase() === $.codec.toUpperCase()
                      ? ((W = G.payload), !0)
                      : !1
                  ),
                  W === 0 ||
                    (isSVCCodec($.codec) &&
                      this.ensureVideoDDExtensionForSVC(V, j),
                    $.codec !== "av1"))
                )
                  return !0;
                const K = Math.round($.maxbr * startBitrateForSVC);
                for (const G of V.fmtp)
                  if (G.payload === W) {
                    G.config.includes("x-google-start-bitrate") ||
                      (G.config += ";x-google-start-bitrate=".concat(K));
                    break;
                  }
                return !0;
              });
      }),
        yield this.setMungedSDP(q, libExports.write(j)),
        this.onOffer(q);
    });
  }
  createAndSetAnswer() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.pc.createAnswer(),
        q = libExports.parse((U = F.sdp) !== null && U !== void 0 ? U : "");
      return (
        q.media.forEach((j) => {
          ensureIPAddrMatchVersion(j),
            j.type === "audio" &&
              ensureAudioNackAndStereo(
                j,
                this.remoteStereoMids,
                this.remoteNackMids
              );
        }),
        yield this.setMungedSDP(F, libExports.write(q)),
        F
      );
    });
  }
  createDataChannel(U, F) {
    return this.pc.createDataChannel(U, F);
  }
  addTransceiver(U, F) {
    return this.pc.addTransceiver(U, F);
  }
  addTrack(U) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(U);
  }
  setTrackCodecBitrate(U) {
    this.trackBitrates.push(U);
  }
  setConfiguration(U) {
    var F;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (F = this._pc) === null || F === void 0
      ? void 0
      : F.setConfiguration(U);
  }
  canRemoveTrack() {
    var U;
    return !!(!((U = this._pc) === null || U === void 0) && U.removeTrack);
  }
  removeTrack(U) {
    var F;
    return (F = this._pc) === null || F === void 0 ? void 0 : F.removeTrack(U);
  }
  getConnectionState() {
    var U, F;
    return (F =
      (U = this._pc) === null || U === void 0 ? void 0 : U.connectionState) !==
      null && F !== void 0
      ? F
      : "closed";
  }
  getICEConnectionState() {
    var U, F;
    return (F =
      (U = this._pc) === null || U === void 0
        ? void 0
        : U.iceConnectionState) !== null && F !== void 0
      ? F
      : "closed";
  }
  getSignallingState() {
    var U, F;
    return (F =
      (U = this._pc) === null || U === void 0 ? void 0 : U.signalingState) !==
      null && F !== void 0
      ? F
      : "closed";
  }
  getTransceivers() {
    var U, F;
    return (F =
      (U = this._pc) === null || U === void 0
        ? void 0
        : U.getTransceivers()) !== null && F !== void 0
      ? F
      : [];
  }
  getSenders() {
    var U, F;
    return (F =
      (U = this._pc) === null || U === void 0 ? void 0 : U.getSenders()) !==
      null && F !== void 0
      ? F
      : [];
  }
  getLocalDescription() {
    var U;
    return (U = this._pc) === null || U === void 0
      ? void 0
      : U.localDescription;
  }
  getRemoteDescription() {
    var U;
    return (U = this.pc) === null || U === void 0
      ? void 0
      : U.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      if (!this._pc) return;
      let F = "";
      const q = new Map(),
        j = new Map();
      if (
        ((yield this._pc.getStats()).forEach((W) => {
          switch (W.type) {
            case "transport":
              F = W.selectedCandidatePairId;
              break;
            case "candidate-pair":
              F === "" && W.selected && (F = W.id), q.set(W.id, W);
              break;
            case "remote-candidate":
              j.set(W.id, "".concat(W.address, ":").concat(W.port));
              break;
          }
        }),
        F === "")
      )
        return;
      const $ =
        (U = q.get(F)) === null || U === void 0 ? void 0 : U.remoteCandidateId;
      if ($ !== void 0) return j.get($);
    });
  }
  setMungedSDP(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (F) {
        const j = U.sdp;
        U.sdp = F;
        try {
          this.log.debug(
            "setting munged ".concat(q ? "remote" : "local", " description"),
            this.logContext
          ),
            q
              ? yield this.pc.setRemoteDescription(U)
              : yield this.pc.setLocalDescription(U);
          return;
        } catch (V) {
          this.log.warn(
            "not able to set ".concat(
              U.type,
              ", falling back to unmodified sdp"
            ),
            Object.assign(Object.assign({}, this.logContext), {
              error: V,
              sdp: F,
            })
          ),
            (U.sdp = j);
        }
      }
      try {
        q
          ? yield this.pc.setRemoteDescription(U)
          : yield this.pc.setLocalDescription(U);
      } catch (j) {
        let V = "unknown error";
        j instanceof Error ? (V = j.message) : typeof j == "string" && (V = j);
        const $ = { error: V, sdp: U.sdp };
        throw (
          (!q &&
            this.pc.remoteDescription &&
            ($.remoteSdp = this.pc.remoteDescription),
          this.log.error(
            "unable to set ".concat(U.type),
            Object.assign(Object.assign({}, this.logContext), { fields: $ })
          ),
          new NegotiationError(V))
        );
      }
    });
  }
  ensureVideoDDExtensionForSVC(U, F) {
    var q, j;
    if (
      !((q = U.ext) === null || q === void 0
        ? void 0
        : q.some(($) => $.uri === ddExtensionURI))
    ) {
      if (this.ddExtID === 0) {
        let $ = 0;
        F.media.forEach((W) => {
          var K;
          W.type === "video" &&
            ((K = W.ext) === null ||
              K === void 0 ||
              K.forEach((G) => {
                G.value > $ && ($ = G.value);
              }));
        }),
          (this.ddExtID = $ + 1);
      }
      (j = U.ext) === null ||
        j === void 0 ||
        j.push({ value: this.ddExtID, uri: ddExtensionURI });
    }
  }
}
function ensureAudioNackAndStereo(B, U, F) {
  let q = 0;
  B.rtp.some((j) => (j.codec === "opus" ? ((q = j.payload), !0) : !1)),
    q > 0 &&
      (B.rtcpFb || (B.rtcpFb = []),
      F.includes(B.mid) &&
        !B.rtcpFb.some((j) => j.payload === q && j.type === "nack") &&
        B.rtcpFb.push({ payload: q, type: "nack" }),
      U.includes(B.mid) &&
        B.fmtp.some((j) =>
          j.payload === q
            ? (j.config.includes("stereo=1") || (j.config += ";stereo=1"), !0)
            : !1
        ));
}
function extractStereoAndNackAudioFromOffer(B) {
  var U;
  const F = [],
    q = [],
    j = libExports.parse((U = B.sdp) !== null && U !== void 0 ? U : "");
  let V = 0;
  return (
    j.media.forEach(($) => {
      var W;
      $.type === "audio" &&
        ($.rtp.some((K) => (K.codec === "opus" ? ((V = K.payload), !0) : !1)),
        !((W = $.rtcpFb) === null || W === void 0) &&
          W.some((K) => K.payload === V && K.type === "nack") &&
          q.push($.mid),
        $.fmtp.some((K) =>
          K.payload === V
            ? (K.config.includes("sprop-stereo=1") && F.push($.mid), !0)
            : !1
        ));
    }),
    { stereoMids: F, nackMids: q }
  );
}
function ensureIPAddrMatchVersion(B) {
  if (B.connection) {
    const U = B.connection.ip.indexOf(":") >= 0;
    ((B.connection.version === 4 && U) || (B.connection.version === 6 && !U)) &&
      ((B.connection.ip = "0.0.0.0"), (B.connection.version = 4));
  }
}
const defaultVideoCodec = "vp8",
  publishDefaults = {
    audioPreset: AudioPresets.music,
    dtx: !0,
    red: !0,
    forceStereo: !1,
    simulcast: !0,
    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
    stopMicTrackOnMute: !1,
    videoCodec: defaultVideoCodec,
    backupCodec: !0,
  },
  audioDefaults = {
    deviceId: { ideal: "default" },
    autoGainControl: !0,
    echoCancellation: !0,
    noiseSuppression: !0,
    voiceIsolation: !0,
  },
  videoDefaults = {
    deviceId: { ideal: "default" },
    resolution: VideoPresets.h720.resolution,
  },
  roomOptionDefaults = {
    adaptiveStream: !1,
    dynacast: !1,
    stopLocalTrackOnUnpublish: !0,
    reconnectPolicy: new DefaultReconnectPolicy(),
    disconnectOnPageLeave: !0,
    webAudioMix: !1,
  },
  roomConnectOptionDefaults = {
    autoSubscribe: !0,
    maxRetries: 1,
    peerConnectionTimeout: 15e3,
    websocketTimeout: 15e3,
  };
var PCTransportState;
(function (B) {
  (B[(B.NEW = 0)] = "NEW"),
    (B[(B.CONNECTING = 1)] = "CONNECTING"),
    (B[(B.CONNECTED = 2)] = "CONNECTED"),
    (B[(B.FAILED = 3)] = "FAILED"),
    (B[(B.CLOSING = 4)] = "CLOSING"),
    (B[(B.CLOSED = 5)] = "CLOSED");
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(U, F, q) {
    var j;
    (this.peerConnectionTimeout =
      roomConnectOptionDefaults.peerConnectionTimeout),
      (this.log = livekitLogger),
      (this.updateState = () => {
        var V;
        const $ = this.state,
          W = this.requiredTransports.map((K) => K.getConnectionState());
        W.every((K) => K === "connected")
          ? (this.state = PCTransportState.CONNECTED)
          : W.some((K) => K === "failed")
          ? (this.state = PCTransportState.FAILED)
          : W.some((K) => K === "connecting")
          ? (this.state = PCTransportState.CONNECTING)
          : W.every((K) => K === "closed")
          ? (this.state = PCTransportState.CLOSED)
          : W.some((K) => K === "closed")
          ? (this.state = PCTransportState.CLOSING)
          : W.every((K) => K === "new") && (this.state = PCTransportState.NEW),
          $ !== this.state &&
            (this.log.debug(
              "pc state change: from "
                .concat(PCTransportState[$], " to ")
                .concat(PCTransportState[this.state]),
              this.logContext
            ),
            (V = this.onStateChange) === null ||
              V === void 0 ||
              V.call(
                this,
                this.state,
                this.publisher.getConnectionState(),
                this.subscriber.getConnectionState()
              ));
      }),
      (this.log = getLogger(
        (j = q.loggerName) !== null && j !== void 0 ? j : LoggerNames.PCManager
      )),
      (this.loggerOptions = q),
      (this.isPublisherConnectionRequired = !F),
      (this.isSubscriberConnectionRequired = F),
      (this.publisher = new PCTransport(U, q)),
      (this.subscriber = new PCTransport(U, q)),
      (this.publisher.onConnectionStateChange = this.updateState),
      (this.subscriber.onConnectionStateChange = this.updateState),
      (this.publisher.onIceConnectionStateChange = this.updateState),
      (this.subscriber.onIceConnectionStateChange = this.updateState),
      (this.publisher.onSignalingStatechange = this.updateState),
      (this.subscriber.onSignalingStatechange = this.updateState),
      (this.publisher.onIceCandidate = (V) => {
        var $;
        ($ = this.onIceCandidate) === null ||
          $ === void 0 ||
          $.call(this, V, SignalTarget.PUBLISHER);
      }),
      (this.subscriber.onIceCandidate = (V) => {
        var $;
        ($ = this.onIceCandidate) === null ||
          $ === void 0 ||
          $.call(this, V, SignalTarget.SUBSCRIBER);
      }),
      (this.subscriber.onDataChannel = (V) => {
        var $;
        ($ = this.onDataChannel) === null || $ === void 0 || $.call(this, V);
      }),
      (this.subscriber.onTrack = (V) => {
        var $;
        ($ = this.onTrack) === null || $ === void 0 || $.call(this, V);
      }),
      (this.publisher.onOffer = (V) => {
        var $;
        ($ = this.onPublisherOffer) === null || $ === void 0 || $.call(this, V);
      }),
      (this.state = PCTransportState.NEW),
      (this.connectionLock = new _$1()),
      (this.remoteOfferLock = new _$1());
  }
  get logContext() {
    var U, F;
    return Object.assign(
      {},
      (F = (U = this.loggerOptions).loggerContextCb) === null || F === void 0
        ? void 0
        : F.call(U)
    );
  }
  requirePublisher() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    (this.isPublisherConnectionRequired = U), this.updateState();
  }
  requireSubscriber() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    (this.isSubscriberConnectionRequired = U), this.updateState();
  }
  createAndSendPublisherOffer(U) {
    return this.publisher.createAndSendOffer(U);
  }
  setPublisherAnswer(U) {
    return this.publisher.setRemoteDescription(U);
  }
  removeTrack(U) {
    return this.publisher.removeTrack(U);
  }
  close() {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const U = this.publisher;
        for (const F of U.getSenders())
          try {
            U.canRemoveTrack() && U.removeTrack(F);
          } catch (q) {
            this.log.warn(
              "could not removeTrack",
              Object.assign(Object.assign({}, this.logContext), { error: q })
            );
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]),
        this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.subscriber.restartingIce = !0),
        this.needsPublisher &&
          (yield this.createAndSendPublisherOffer({ iceRestart: !0 }));
    });
  }
  addIceCandidate(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      F === SignalTarget.PUBLISHER
        ? yield this.publisher.addIceCandidate(U)
        : yield this.subscriber.addIceCandidate(U);
    });
  }
  createSubscriberAnswerFromOffer(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.log.debug(
        "received server offer",
        Object.assign(Object.assign({}, this.logContext), {
          RTCSdpType: U.type,
          sdp: U.sdp,
          signalingState: this.subscriber.getSignallingState().toString(),
        })
      );
      const F = yield this.remoteOfferLock.lock();
      try {
        return (
          yield this.subscriber.setRemoteDescription(U),
          yield this.subscriber.createAndSetAnswer()
        );
      } finally {
        F();
      }
    });
  }
  updateConfiguration(U, F) {
    this.publisher.setConfiguration(U),
      this.subscriber.setConfiguration(U),
      F && this.triggerIceRestart();
  }
  ensurePCTransportConnection(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var q;
      const j = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired &&
          this.publisher.getConnectionState() !== "connected" &&
          this.publisher.getConnectionState() !== "connecting" &&
          (this.log.debug(
            "negotiation required, start negotiating",
            this.logContext
          ),
          this.publisher.negotiate()),
          yield Promise.all(
            (q = this.requiredTransports) === null || q === void 0
              ? void 0
              : q.map((V) => this.ensureTransportConnected(V, U, F))
          );
      } finally {
        j();
      }
    });
  }
  negotiate(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return new Promise((F, q) =>
        __awaiter$b(this, void 0, void 0, function* () {
          const j = setTimeout(() => {
              q("negotiation timed out");
            }, this.peerConnectionTimeout),
            V = () => {
              clearTimeout(j), q("negotiation aborted");
            };
          U.signal.addEventListener("abort", V),
            this.publisher.once(PCEvents.NegotiationStarted, () => {
              U.signal.aborted ||
                this.publisher.once(PCEvents.NegotiationComplete, () => {
                  clearTimeout(j), F();
                });
            }),
            yield this.publisher.negotiate(($) => {
              clearTimeout(j), q($);
            });
        })
      );
    });
  }
  addPublisherTransceiver(U, F) {
    return this.publisher.addTransceiver(U, F);
  }
  addPublisherTrack(U) {
    return this.publisher.addTrack(U);
  }
  createPublisherDataChannel(U, F) {
    return this.publisher.createDataChannel(U, F);
  }
  getConnectedAddress(U) {
    return U === SignalTarget.PUBLISHER
      ? this.publisher.getConnectedAddress()
      : U === SignalTarget.SUBSCRIBER
      ? this.publisher.getConnectedAddress()
      : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const U = [];
    return (
      this.isPublisherConnectionRequired && U.push(this.publisher),
      this.isSubscriberConnectionRequired && U.push(this.subscriber),
      U
    );
  }
  ensureTransportConnected(U, F) {
    return __awaiter$b(this, arguments, void 0, function (q, j) {
      var V = this;
      let $ =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : this.peerConnectionTimeout;
      return (function* () {
        if (q.getConnectionState() !== "connected")
          return new Promise((K, G) =>
            __awaiter$b(V, void 0, void 0, function* () {
              const H = () => {
                this.log.warn("abort transport connection", this.logContext),
                  CriticalTimers.clearTimeout(Q),
                  G(
                    new ConnectionError(
                      "room connection has been cancelled",
                      ConnectionErrorReason.Cancelled
                    )
                  );
              };
              j != null && j.signal.aborted && H(),
                j == null || j.signal.addEventListener("abort", H);
              const Q = CriticalTimers.setTimeout(() => {
                j == null || j.signal.removeEventListener("abort", H),
                  G(
                    new ConnectionError(
                      "could not establish pc connection",
                      ConnectionErrorReason.InternalError
                    )
                  );
              }, $);
              for (; this.state !== PCTransportState.CONNECTED; )
                if ((yield sleep$1(50), j != null && j.signal.aborted)) {
                  G(
                    new ConnectionError(
                      "room connection has been cancelled",
                      ConnectionErrorReason.Cancelled
                    )
                  );
                  return;
                }
              CriticalTimers.clearTimeout(Q),
                j == null || j.signal.removeEventListener("abort", H),
                K();
            })
          );
      })();
    });
  }
}
class RpcError extends Error {
  constructor(U, F, q) {
    super(F),
      (this.code = U),
      (this.message = truncateBytes(F, RpcError.MAX_MESSAGE_BYTES)),
      (this.data = q ? truncateBytes(q, RpcError.MAX_DATA_BYTES) : void 0);
  }
  static fromProto(U) {
    return new RpcError(U.code, U.message, U.data);
  }
  toProto() {
    return new RpcError$1({
      code: this.code,
      message: this.message,
      data: this.data,
    });
  }
  static builtIn(U, F) {
    return new RpcError(RpcError.ErrorCode[U], RpcError.ErrorMessage[U], F);
  }
}
RpcError.MAX_MESSAGE_BYTES = 256;
RpcError.MAX_DATA_BYTES = 15360;
RpcError.ErrorCode = {
  APPLICATION_ERROR: 1500,
  CONNECTION_TIMEOUT: 1501,
  RESPONSE_TIMEOUT: 1502,
  RECIPIENT_DISCONNECTED: 1503,
  RESPONSE_PAYLOAD_TOO_LARGE: 1504,
  SEND_FAILED: 1505,
  UNSUPPORTED_METHOD: 1400,
  RECIPIENT_NOT_FOUND: 1401,
  REQUEST_PAYLOAD_TOO_LARGE: 1402,
  UNSUPPORTED_SERVER: 1403,
  UNSUPPORTED_VERSION: 1404,
};
RpcError.ErrorMessage = {
  APPLICATION_ERROR: "Application error in method handler",
  CONNECTION_TIMEOUT: "Connection timeout",
  RESPONSE_TIMEOUT: "Response timeout",
  RECIPIENT_DISCONNECTED: "Recipient disconnected",
  RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
  SEND_FAILED: "Failed to send",
  UNSUPPORTED_METHOD: "Method not supported at destination",
  RECIPIENT_NOT_FOUND: "Recipient not found",
  REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
  UNSUPPORTED_SERVER: "RPC not supported by server",
  UNSUPPORTED_VERSION: "Unsupported RPC version",
};
const MAX_PAYLOAD_BYTES = 15360;
function byteLength(B) {
  return new TextEncoder().encode(B).length;
}
function truncateBytes(B, U) {
  if (byteLength(B) <= U) return B;
  let F = 0,
    q = B.length;
  const j = new TextEncoder();
  for (; F < q; ) {
    const V = Math.floor((F + q + 1) / 2);
    j.encode(B.slice(0, V)).length <= U ? (F = V) : (q = V - 1);
  }
  return B.slice(0, F);
}
const monitorFrequency = 2e3;
function computeBitrate(B, U) {
  if (!U) return 0;
  let F, q;
  return (
    "bytesReceived" in B
      ? ((F = B.bytesReceived), (q = U.bytesReceived))
      : "bytesSent" in B && ((F = B.bytesSent), (q = U.bytesSent)),
    F === void 0 ||
    q === void 0 ||
    B.timestamp === void 0 ||
    U.timestamp === void 0
      ? 0
      : ((F - q) * 8 * 1e3) / (B.timestamp - U.timestamp)
  );
}
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get sender() {
    return this._sender;
  }
  set sender(U) {
    this._sender = U;
  }
  get constraints() {
    return this._constraints;
  }
  constructor(U, F, q) {
    let j = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
      V = arguments.length > 4 ? arguments[4] : void 0;
    super(U, F, V),
      (this.manuallyStopped = !1),
      (this._isUpstreamPaused = !1),
      (this.handleTrackMuteEvent = () =>
        this.debouncedTrackMuteHandler().catch(() =>
          this.log.debug(
            "track mute bounce got cancelled by an unmute event",
            this.logContext
          )
        )),
      (this.debouncedTrackMuteHandler = r$1(
        () =>
          __awaiter$b(this, void 0, void 0, function* () {
            yield this.pauseUpstream();
          }),
        5e3
      )),
      (this.handleTrackUnmuteEvent = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          this.debouncedTrackMuteHandler.cancel("unmute"),
            yield this.resumeUpstream();
        })),
      (this.handleEnded = () => {
        this.isInBackground && (this.reacquireTrack = !0),
          this._mediaStreamTrack.removeEventListener(
            "mute",
            this.handleTrackMuteEvent
          ),
          this._mediaStreamTrack.removeEventListener(
            "unmute",
            this.handleTrackUnmuteEvent
          ),
          this.emit(TrackEvent.Ended, this);
      }),
      (this.reacquireTrack = !1),
      (this.providedByUser = j),
      (this.muteLock = new _$1()),
      (this.pauseUpstreamLock = new _$1()),
      (this.processorLock = new _$1()),
      (this.restartLock = new _$1()),
      this.setMediaStreamTrack(U, !0),
      (this._constraints = U.getConstraints()),
      q && (this._constraints = q);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video) return;
    const { width: U, height: F } = this._mediaStreamTrack.getSettings();
    if (U && F) return { width: U, height: F };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var U, F;
    return (F =
      (U = this.processor) === null || U === void 0
        ? void 0
        : U.processedTrack) !== null && F !== void 0
      ? F
      : this._mediaStreamTrack;
  }
  get isLocal() {
    return !0;
  }
  getSourceTrackSettings() {
    return this._mediaStreamTrack.getSettings();
  }
  setMediaStreamTrack(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var q;
      if (U === this._mediaStreamTrack && !F) return;
      this._mediaStreamTrack &&
        (this.attachedElements.forEach((V) => {
          detachTrack(this._mediaStreamTrack, V);
        }),
        this.debouncedTrackMuteHandler.cancel("new-track"),
        this._mediaStreamTrack.removeEventListener("ended", this.handleEnded),
        this._mediaStreamTrack.removeEventListener(
          "mute",
          this.handleTrackMuteEvent
        ),
        this._mediaStreamTrack.removeEventListener(
          "unmute",
          this.handleTrackUnmuteEvent
        )),
        (this.mediaStream = new MediaStream([U])),
        U &&
          (U.addEventListener("ended", this.handleEnded),
          U.addEventListener("mute", this.handleTrackMuteEvent),
          U.addEventListener("unmute", this.handleTrackUnmuteEvent),
          (this._constraints = U.getConstraints()));
      let j;
      if (this.processor && U) {
        const V = yield this.processorLock.lock();
        try {
          if (
            (this.log.debug("restarting processor", this.logContext),
            this.kind === "unknown")
          )
            throw TypeError("cannot set processor on track of unknown kind");
          this.processorElement &&
            (attachToElement(U, this.processorElement),
            (this.processorElement.muted = !0)),
            yield this.processor.restart({
              track: U,
              kind: this.kind,
              element: this.processorElement,
            }),
            (j = this.processor.processedTrack);
        } finally {
          V();
        }
      }
      this.sender &&
        ((q = this.sender.transport) === null || q === void 0
          ? void 0
          : q.state) !== "closed" &&
        (yield this.sender.replaceTrack(j ?? U)),
        !this.providedByUser &&
          this._mediaStreamTrack !== U &&
          this._mediaStreamTrack.stop(),
        (this._mediaStreamTrack = U),
        U &&
          ((this._mediaStreamTrack.enabled = !this.isMuted),
          yield this.resumeUpstream(),
          this.attachedElements.forEach((V) => {
            attachToElement(j ?? U, V);
          }));
    });
  }
  waitForDimensions() {
    return __awaiter$b(this, arguments, void 0, function () {
      var U = this;
      let F =
        arguments.length > 0 && arguments[0] !== void 0
          ? arguments[0]
          : defaultDimensionsTimeout;
      return (function* () {
        var q;
        if (U.kind === Track.Kind.Audio)
          throw new Error("cannot get dimensions for audio tracks");
        ((q = getBrowser()) === null || q === void 0 ? void 0 : q.os) ===
          "iOS" && (yield sleep$1(10));
        const j = Date.now();
        for (; Date.now() - j < F; ) {
          const V = U.dimensions;
          if (V) return V;
          yield sleep$1(50);
        }
        throw new TrackInvalidError(
          "unable to get track dimensions after timeout"
        );
      })();
    });
  }
  setDeviceId(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return (this._constraints.deviceId === U &&
        this._mediaStreamTrack.getSettings().deviceId ===
          unwrapConstraint(U)) ||
        ((this._constraints.deviceId = U), this.isMuted)
        ? !0
        : (yield this.restartTrack(),
          unwrapConstraint(U) ===
            this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  getDeviceId() {
    return __awaiter$b(this, arguments, void 0, function () {
      var U = this;
      let F =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return (function* () {
        if (U.source === Track.Source.ScreenShare) return;
        const { deviceId: q, groupId: j } = U._mediaStreamTrack.getSettings(),
          V = U.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
        return F ? DeviceManager.getInstance().normalizeDeviceId(V, q, j) : q;
      })();
    });
  }
  mute() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      let q, j;
      return (
        typeof F == "boolean"
          ? (q = F)
          : F !== void 0 && ((q = F.userProvidedTrack), (j = F.stopProcessor)),
        (this.providedByUser = q ?? !0),
        this.log.debug("replace MediaStreamTrack", this.logContext),
        yield this.setMediaStreamTrack(U),
        j && this.processor && (yield this.stopProcessor()),
        this
      );
    });
  }
  restart(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.manuallyStopped = !1;
      const F = yield this.restartLock.lock();
      try {
        U || (U = this._constraints);
        const { deviceId: q, facingMode: j } = U,
          V = __rest(U, ["deviceId", "facingMode"]);
        this.log.debug(
          "restarting track with constraints",
          Object.assign(Object.assign({}, this.logContext), { constraints: U })
        );
        const $ = { audio: !1, video: !1 };
        this.kind === Track.Kind.Video
          ? ($.video = q || j ? { deviceId: q, facingMode: j } : !0)
          : ($.audio = q ? { deviceId: q } : !0),
          this.attachedElements.forEach((G) => {
            detachTrack(this.mediaStreamTrack, G);
          }),
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded),
          this._mediaStreamTrack.stop();
        const K = (yield navigator.mediaDevices.getUserMedia($)).getTracks()[0];
        return (
          yield K.applyConstraints(V),
          K.addEventListener("ended", this.handleEnded),
          this.log.debug("re-acquired MediaStreamTrack", this.logContext),
          yield this.setMediaStreamTrack(K),
          (this._constraints = U),
          this.emit(TrackEvent.Restarted, this),
          this.manuallyStopped &&
            (this.log.warn(
              "track was stopped during a restart, stopping restarted track",
              this.logContext
            ),
            this.stop()),
          this
        );
      } finally {
        F();
      }
    });
  }
  setTrackMuted(U) {
    this.log.debug(
      "setting ".concat(this.kind, " track ").concat(U ? "muted" : "unmuted"),
      this.logContext
    ),
      !(this.isMuted === U && this._mediaStreamTrack.enabled !== U) &&
        ((this.isMuted = U),
        (this._mediaStreamTrack.enabled = !U),
        this.emit(U ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return (
      this._mediaStreamTrack.readyState !== "live" ||
      this._mediaStreamTrack.muted ||
      !this._mediaStreamTrack.enabled ||
      this.reacquireTrack
    );
  }
  handleAppVisibilityChanged() {
    const U = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged,
      },
    });
    return __awaiter$b(this, void 0, void 0, function* () {
      yield U.handleAppVisibilityChanged.call(this),
        isMobile() &&
          (this.log.debug(
            "visibility changed, is in Background: ".concat(
              this.isInBackground
            ),
            this.logContext
          ),
          !this.isInBackground &&
            this.needsReAcquisition &&
            !this.isUserProvided &&
            !this.isMuted &&
            (this.log.debug(
              "track needs to be reacquired, restarting ".concat(this.source),
              this.logContext
            ),
            yield this.restart(),
            (this.reacquireTrack = !1)));
    });
  }
  stop() {
    var U;
    (this.manuallyStopped = !0),
      super.stop(),
      this._mediaStreamTrack.removeEventListener("ended", this.handleEnded),
      this._mediaStreamTrack.removeEventListener(
        "mute",
        this.handleTrackMuteEvent
      ),
      this._mediaStreamTrack.removeEventListener(
        "unmute",
        this.handleTrackUnmuteEvent
      ),
      (U = this.processor) === null || U === void 0 || U.destroy(),
      (this.processor = void 0);
  }
  pauseUpstream() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0) return;
        if (!this.sender) {
          this.log.warn(
            "unable to pause upstream for an unpublished track",
            this.logContext
          );
          return;
        }
        (this._isUpstreamPaused = !0),
          this.emit(TrackEvent.UpstreamPaused, this);
        const q = getBrowser();
        if (
          (q == null ? void 0 : q.name) === "Safari" &&
          compareVersions(q.version, "12.0") < 0
        )
          throw new DeviceUnsupportedError(
            "pauseUpstream is not supported on Safari < 12."
          );
        ((U = this.sender.transport) === null || U === void 0
          ? void 0
          : U.state) !== "closed" && (yield this.sender.replaceTrack(null));
      } finally {
        F();
      }
    });
  }
  resumeUpstream() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1) return;
        if (!this.sender) {
          this.log.warn(
            "unable to resume upstream for an unpublished track",
            this.logContext
          );
          return;
        }
        (this._isUpstreamPaused = !1),
          this.emit(TrackEvent.UpstreamResumed, this),
          ((U = this.sender.transport) === null || U === void 0
            ? void 0
            : U.state) !== "closed" &&
            (yield this.sender.replaceTrack(this.mediaStreamTrack));
      } finally {
        F();
      }
    });
  }
  getRTCStatsReport() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      return !((U = this.sender) === null || U === void 0) && U.getStats
        ? yield this.sender.getStats()
        : void 0;
    });
  }
  setProcessor(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return (function* () {
        var V;
        const $ = yield q.processorLock.lock();
        try {
          q.log.debug("setting up processor", q.logContext);
          const W = document.createElement(q.kind),
            K = {
              kind: q.kind,
              track: q._mediaStreamTrack,
              element: W,
              audioContext: q.audioContext,
            };
          if (
            (yield F.init(K),
            q.log.debug("processor initialized", q.logContext),
            q.processor && (yield q.stopProcessor()),
            q.kind === "unknown")
          )
            throw TypeError("cannot set processor on track of unknown kind");
          if (
            (attachToElement(q._mediaStreamTrack, W),
            (W.muted = !0),
            W.play().catch((G) =>
              q.log.error(
                "failed to play processor element",
                Object.assign(Object.assign({}, q.logContext), { error: G })
              )
            ),
            (q.processor = F),
            (q.processorElement = W),
            q.processor.processedTrack)
          ) {
            for (const G of q.attachedElements)
              G !== q.processorElement &&
                j &&
                (detachTrack(q._mediaStreamTrack, G),
                attachToElement(q.processor.processedTrack, G));
            yield (V = q.sender) === null || V === void 0
              ? void 0
              : V.replaceTrack(q.processor.processedTrack);
          }
          q.emit(TrackEvent.TrackProcessorUpdate, q.processor);
        } finally {
          $();
        }
      })();
    });
  }
  getProcessor() {
    return this.processor;
  }
  stopProcessor() {
    return __awaiter$b(this, arguments, void 0, function () {
      var U = this;
      let F =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return (function* () {
        var q, j;
        U.processor &&
          (U.log.debug("stopping processor", U.logContext),
          (q = U.processor.processedTrack) === null || q === void 0 || q.stop(),
          yield U.processor.destroy(),
          (U.processor = void 0),
          F ||
            ((j = U.processorElement) === null || j === void 0 || j.remove(),
            (U.processorElement = void 0)),
          yield U._mediaStreamTrack.applyConstraints(U._constraints),
          yield U.setMediaStreamTrack(U._mediaStreamTrack, !0),
          U.emit(TrackEvent.TrackProcessorUpdate));
      })();
    });
  }
}
class LocalAudioTrack extends LocalTrack {
  get enhancedNoiseCancellation() {
    return this.isKrispNoiseFilterEnabled;
  }
  constructor(U, F) {
    let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
      j = arguments.length > 3 ? arguments[3] : void 0,
      V = arguments.length > 4 ? arguments[4] : void 0;
    super(U, Track.Kind.Audio, F, q, V),
      (this.stopOnMute = !1),
      (this.isKrispNoiseFilterEnabled = !1),
      (this.monitorSender = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.sender) {
            this._currentBitrate = 0;
            return;
          }
          let $;
          try {
            $ = yield this.getSenderStats();
          } catch (W) {
            this.log.error(
              "could not get audio sender stats",
              Object.assign(Object.assign({}, this.logContext), { error: W })
            );
            return;
          }
          $ &&
            this.prevStats &&
            (this._currentBitrate = computeBitrate($, this.prevStats)),
            (this.prevStats = $);
        })),
      (this.handleKrispNoiseFilterEnable = () => {
        (this.isKrispNoiseFilterEnabled = !0),
          this.log.debug("Krisp noise filter enabled", this.logContext),
          this.emit(
            TrackEvent.AudioTrackFeatureUpdate,
            this,
            AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
            !0
          );
      }),
      (this.handleKrispNoiseFilterDisable = () => {
        (this.isKrispNoiseFilterEnabled = !1),
          this.log.debug("Krisp noise filter disabled", this.logContext),
          this.emit(
            TrackEvent.AudioTrackFeatureUpdate,
            this,
            AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
            !1
          );
      }),
      (this.audioContext = j),
      this.checkForSilence();
  }
  mute() {
    const U = Object.create(null, { mute: { get: () => super.mute } });
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = yield this.muteLock.lock();
      try {
        return this.isMuted
          ? (this.log.debug("Track already muted", this.logContext), this)
          : (this.source === Track.Source.Microphone &&
              this.stopOnMute &&
              !this.isUserProvided &&
              (this.log.debug("stopping mic track", this.logContext),
              this._mediaStreamTrack.stop()),
            yield U.mute.call(this),
            this);
      } finally {
        F();
      }
    });
  }
  unmute() {
    const U = Object.create(null, { unmute: { get: () => super.unmute } });
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = yield this.muteLock.lock();
      try {
        if (!this.isMuted)
          return this.log.debug("Track already unmuted", this.logContext), this;
        const q =
          this._constraints.deviceId &&
          this._mediaStreamTrack.getSettings().deviceId !==
            unwrapConstraint(this._constraints.deviceId);
        return (
          this.source === Track.Source.Microphone &&
            (this.stopOnMute ||
              this._mediaStreamTrack.readyState === "ended" ||
              q) &&
            !this.isUserProvided &&
            (this.log.debug("reacquiring mic track", this.logContext),
            yield this.restartTrack()),
          yield U.unmute.call(this),
          this
        );
      } finally {
        F();
      }
    });
  }
  restartTrack(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let F;
      if (U) {
        const q = constraintsForOptions({ audio: U });
        typeof q.audio != "boolean" && (F = q.audio);
      }
      yield this.restart(F);
    });
  }
  restart(U) {
    const F = Object.create(null, { restart: { get: () => super.restart } });
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = yield F.restart.call(this, U);
      return this.checkForSilence(), q;
    });
  }
  startMonitor() {
    isWeb() &&
      (this.monitorInterval ||
        (this.monitorInterval = setInterval(() => {
          this.monitorSender();
        }, monitorFrequency)));
  }
  setProcessor(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F;
      const q = yield this.processorLock.lock();
      try {
        if (!isReactNative() && !this.audioContext)
          throw Error(
            "Audio context needs to be set on LocalAudioTrack in order to enable processors"
          );
        this.processor && (yield this.stopProcessor());
        const j = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext,
        };
        this.log.debug(
          "setting up audio processor ".concat(U.name),
          this.logContext
        ),
          yield U.init(j),
          (this.processor = U),
          this.processor.processedTrack &&
            (yield (F = this.sender) === null || F === void 0
              ? void 0
              : F.replaceTrack(this.processor.processedTrack),
            this.processor.processedTrack.addEventListener(
              "enable-lk-krisp-noise-filter",
              this.handleKrispNoiseFilterEnable
            ),
            this.processor.processedTrack.addEventListener(
              "disable-lk-krisp-noise-filter",
              this.handleKrispNoiseFilterDisable
            )),
          this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
      } finally {
        q();
      }
    });
  }
  setAudioContext(U) {
    this.audioContext = U;
  }
  getSenderStats() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      if (!(!((U = this.sender) === null || U === void 0) && U.getStats))
        return;
      const F = yield this.sender.getStats();
      let q;
      return (
        F.forEach((j) => {
          j.type === "outbound-rtp" &&
            (q = {
              type: "audio",
              streamId: j.id,
              packetsSent: j.packetsSent,
              packetsLost: j.packetsLost,
              bytesSent: j.bytesSent,
              timestamp: j.timestamp,
              roundTripTime: j.roundTripTime,
              jitter: j.jitter,
            });
        }),
        q
      );
    });
  }
  checkForSilence() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const U = yield detectSilence(this);
      return (
        U &&
          (this.isMuted ||
            this.log.warn(
              "silence detected on local audio track",
              this.logContext
            ),
          this.emit(TrackEvent.AudioSilenceDetected)),
        U
      );
    });
  }
}
function mediaTrackToLocalTrack(B, U, F) {
  switch (B.kind) {
    case "audio":
      return new LocalAudioTrack(B, U, !1, void 0, F);
    case "video":
      return new LocalVideoTrack(B, U, !1, F);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(B.kind));
  }
}
const presets169 = Object.values(VideoPresets),
  presets43 = Object.values(VideoPresets43),
  presetsScreenShare = Object.values(ScreenSharePresets),
  defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360],
  defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360],
  computeDefaultScreenShareSimulcastPresets = (B) =>
    [{ scaleResolutionDownBy: 2, fps: B.encoding.maxFramerate }].map((F) => {
      var q, j;
      return new VideoPreset(
        Math.floor(B.width / F.scaleResolutionDownBy),
        Math.floor(B.height / F.scaleResolutionDownBy),
        Math.max(
          15e4,
          Math.floor(
            B.encoding.maxBitrate /
              (Math.pow(F.scaleResolutionDownBy, 2) *
                (((q = B.encoding.maxFramerate) !== null && q !== void 0
                  ? q
                  : 30) /
                  ((j = F.fps) !== null && j !== void 0 ? j : 30)))
          )
        ),
        F.fps,
        B.encoding.priority
      );
    }),
  videoRids = ["q", "h", "f"];
function computeVideoEncodings(B, U, F, q) {
  var j, V;
  let $ = q == null ? void 0 : q.videoEncoding;
  B && ($ = q == null ? void 0 : q.screenShareEncoding);
  const W = q == null ? void 0 : q.simulcast,
    K = q == null ? void 0 : q.scalabilityMode,
    G = q == null ? void 0 : q.videoCodec;
  if ((!$ && !W && !K) || !U || !F) return [{}];
  $ ||
    (($ = determineAppropriateEncoding(B, U, F, G)),
    livekitLogger.debug("using video encoding", $));
  const H = $.maxFramerate,
    Q = new VideoPreset(U, F, $.maxBitrate, $.maxFramerate, $.priority);
  if (K && isSVCCodec(G)) {
    const X = new ScalabilityMode(K),
      Z = [];
    if (X.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(K));
    const se = getBrowser();
    if (
      isSafari() ||
      isReactNative() ||
      ((se == null ? void 0 : se.name) === "Chrome" &&
        compareVersions(se == null ? void 0 : se.version, "113") < 0)
    ) {
      const ee = X.suffix == "h" ? 2 : 3;
      for (let ie = 0; ie < X.spatial; ie += 1)
        Z.push({
          rid: videoRids[2 - ie],
          maxBitrate: $.maxBitrate / Math.pow(ee, ie),
          maxFramerate: Q.encoding.maxFramerate,
        });
      Z[0].scalabilityMode = K;
    } else
      Z.push({
        maxBitrate: $.maxBitrate,
        maxFramerate: Q.encoding.maxFramerate,
        scalabilityMode: K,
      });
    return (
      Q.encoding.priority &&
        ((Z[0].priority = Q.encoding.priority),
        (Z[0].networkPriority = Q.encoding.priority)),
      livekitLogger.debug("using svc encoding", { encodings: Z }),
      Z
    );
  }
  if (!W) return [$];
  let z = [];
  B
    ? (z =
        (j = sortPresets(q == null ? void 0 : q.screenShareSimulcastLayers)) !==
          null && j !== void 0
          ? j
          : defaultSimulcastLayers(B, Q))
    : (z =
        (V = sortPresets(q == null ? void 0 : q.videoSimulcastLayers)) !==
          null && V !== void 0
          ? V
          : defaultSimulcastLayers(B, Q));
  let Y;
  if (z.length > 0) {
    const X = z[0];
    z.length > 1 && ([, Y] = z);
    const Z = Math.max(U, F);
    if (Z >= 960 && Y) return encodingsFromPresets(U, F, [X, Y, Q], H);
    if (Z >= 480) return encodingsFromPresets(U, F, [X, Q], H);
  }
  return encodingsFromPresets(U, F, [Q]);
}
function computeTrackBackupEncodings(B, U, F) {
  var q, j, V, $;
  if (
    !F.backupCodec ||
    F.backupCodec === !0 ||
    F.backupCodec.codec === F.videoCodec
  )
    return;
  U !== F.backupCodec.codec &&
    livekitLogger.warn("requested a different codec than specified as backup", {
      serverRequested: U,
      backup: F.backupCodec.codec,
    }),
    (F.videoCodec = U),
    (F.videoEncoding = F.backupCodec.encoding);
  const W = B.mediaStreamTrack.getSettings(),
    K =
      (q = W.width) !== null && q !== void 0
        ? q
        : (j = B.dimensions) === null || j === void 0
        ? void 0
        : j.width,
    G =
      (V = W.height) !== null && V !== void 0
        ? V
        : ($ = B.dimensions) === null || $ === void 0
        ? void 0
        : $.height;
  return (
    B.source === Track.Source.ScreenShare && F.simulcast && (F.simulcast = !1),
    computeVideoEncodings(B.source === Track.Source.ScreenShare, K, G, F)
  );
}
function determineAppropriateEncoding(B, U, F, q) {
  const j = presetsForResolution(B, U, F);
  let { encoding: V } = j[0];
  const $ = Math.max(U, F);
  for (let W = 0; W < j.length; W += 1) {
    const K = j[W];
    if (((V = K.encoding), K.width >= $)) break;
  }
  if (q)
    switch (q) {
      case "av1":
        (V = Object.assign({}, V)), (V.maxBitrate = V.maxBitrate * 0.7);
        break;
      case "vp9":
        (V = Object.assign({}, V)), (V.maxBitrate = V.maxBitrate * 0.85);
        break;
    }
  return V;
}
function presetsForResolution(B, U, F) {
  if (B) return presetsScreenShare;
  const q = U > F ? U / F : F / U;
  return Math.abs(q - 16 / 9) < Math.abs(q - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(B, U) {
  if (B) return computeDefaultScreenShareSimulcastPresets(U);
  const { width: F, height: q } = U,
    j = F > q ? F / q : q / F;
  return Math.abs(j - 16 / 9) < Math.abs(j - 4 / 3)
    ? defaultSimulcastPresets169
    : defaultSimulcastPresets43;
}
function encodingsFromPresets(B, U, F, q) {
  const j = [];
  if (
    (F.forEach((V, $) => {
      if ($ >= videoRids.length) return;
      const W = Math.min(B, U),
        G = {
          rid: videoRids[$],
          scaleResolutionDownBy: Math.max(1, W / Math.min(V.width, V.height)),
          maxBitrate: V.encoding.maxBitrate,
        },
        H =
          q && V.encoding.maxFramerate
            ? Math.min(q, V.encoding.maxFramerate)
            : V.encoding.maxFramerate;
      H && (G.maxFramerate = H);
      const Q = isFireFox() || $ === 0;
      V.encoding.priority &&
        Q &&
        ((G.priority = V.encoding.priority),
        (G.networkPriority = V.encoding.priority)),
        j.push(G);
    }),
    isReactNative() && getReactNativeOs() === "ios")
  ) {
    let V;
    j.forEach((W) => {
      V
        ? W.maxFramerate && W.maxFramerate > V && (V = W.maxFramerate)
        : (V = W.maxFramerate);
    });
    let $ = !0;
    j.forEach((W) => {
      var K;
      W.maxFramerate != V &&
        ($ &&
          (($ = !1),
          livekitLogger.info(
            "Simulcast on iOS React-Native requires all encodings to share the same framerate."
          )),
        livekitLogger.info(
          'Setting framerate of encoding "'
            .concat((K = W.rid) !== null && K !== void 0 ? K : "", '" to ')
            .concat(V)
        ),
        (W.maxFramerate = V));
    });
  }
  return j;
}
function sortPresets(B) {
  if (B)
    return B.sort((U, F) => {
      const { encoding: q } = U,
        { encoding: j } = F;
      return q.maxBitrate > j.maxBitrate
        ? 1
        : q.maxBitrate < j.maxBitrate
        ? -1
        : q.maxBitrate === j.maxBitrate && q.maxFramerate && j.maxFramerate
        ? q.maxFramerate > j.maxFramerate
          ? 1
          : -1
        : 0;
    });
}
class ScalabilityMode {
  constructor(U) {
    const F = U.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!F) throw new Error("invalid scalability mode");
    if (
      ((this.spatial = parseInt(F[1])),
      (this.temporal = parseInt(F[2])),
      F.length > 3)
    )
      switch (F[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = F[3];
      }
  }
  toString() {
    var U;
    return "L"
      .concat(this.spatial, "T")
      .concat(this.temporal)
      .concat((U = this.suffix) !== null && U !== void 0 ? U : "");
  }
}
function getDefaultDegradationPreference(B) {
  return B.source === Track.Source.ScreenShare ||
    (B.constraints.height && unwrapConstraint(B.constraints.height) >= 1080)
    ? "maintain-resolution"
    : "balanced";
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  get sender() {
    return this._sender;
  }
  set sender(U) {
    (this._sender = U),
      this.degradationPreference &&
        this.setDegradationPreference(this.degradationPreference);
  }
  constructor(U, F) {
    let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
      j = arguments.length > 3 ? arguments[3] : void 0;
    super(U, Track.Kind.Video, F, q, j),
      (this.simulcastCodecs = new Map()),
      (this.degradationPreference = "balanced"),
      (this.monitorSender = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.sender) {
            this._currentBitrate = 0;
            return;
          }
          let V;
          try {
            V = yield this.getSenderStats();
          } catch (W) {
            this.log.error(
              "could not get audio sender stats",
              Object.assign(Object.assign({}, this.logContext), { error: W })
            );
            return;
          }
          const $ = new Map(V.map((W) => [W.rid, W]));
          if (this.prevStats) {
            let W = 0;
            $.forEach((K, G) => {
              var H;
              const Q =
                (H = this.prevStats) === null || H === void 0
                  ? void 0
                  : H.get(G);
              W += computeBitrate(K, Q);
            }),
              (this._currentBitrate = W);
          }
          this.prevStats = $;
        })),
      (this.senderLock = new _$1());
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  startMonitor(U) {
    var F;
    if (((this.signalClient = U), !isWeb())) return;
    const q =
      (F = this.sender) === null || F === void 0 ? void 0 : F.getParameters();
    q && (this.encodings = q.encodings),
      !this.monitorInterval &&
        (this.monitorInterval = setInterval(() => {
          this.monitorSender();
        }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(),
      this.simulcastCodecs.forEach((U) => {
        U.mediaStreamTrack.stop();
      }),
      super.stop();
  }
  pauseUpstream() {
    const U = Object.create(null, {
      pauseUpstream: { get: () => super.pauseUpstream },
    });
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j, V, $;
      yield U.pauseUpstream.call(this);
      try {
        for (
          var W = !0, K = __asyncValues(this.simulcastCodecs.values()), G;
          (G = yield K.next()), (F = G.done), !F;
          W = !0
        )
          (V = G.value),
            (W = !1),
            yield ($ = V.sender) === null || $ === void 0
              ? void 0
              : $.replaceTrack(null);
      } catch (H) {
        q = { error: H };
      } finally {
        try {
          !W && !F && (j = K.return) && (yield j.call(K));
        } finally {
          if (q) throw q.error;
        }
      }
    });
  }
  resumeUpstream() {
    const U = Object.create(null, {
      resumeUpstream: { get: () => super.resumeUpstream },
    });
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j, V, $;
      yield U.resumeUpstream.call(this);
      try {
        for (
          var W = !0, K = __asyncValues(this.simulcastCodecs.values()), G;
          (G = yield K.next()), (F = G.done), !F;
          W = !0
        ) {
          (V = G.value), (W = !1);
          const H = V;
          yield ($ = H.sender) === null || $ === void 0
            ? void 0
            : $.replaceTrack(H.mediaStreamTrack);
        }
      } catch (H) {
        q = { error: H };
      } finally {
        try {
          !W && !F && (j = K.return) && (yield j.call(K));
        } finally {
          if (q) throw q.error;
        }
      }
    });
  }
  mute() {
    const U = Object.create(null, { mute: { get: () => super.mute } });
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = yield this.muteLock.lock();
      try {
        return this.isMuted
          ? (this.log.debug("Track already muted", this.logContext), this)
          : (this.source === Track.Source.Camera &&
              !this.isUserProvided &&
              (this.log.debug("stopping camera track", this.logContext),
              this._mediaStreamTrack.stop()),
            yield U.mute.call(this),
            this);
      } finally {
        F();
      }
    });
  }
  unmute() {
    const U = Object.create(null, { unmute: { get: () => super.unmute } });
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = yield this.muteLock.lock();
      try {
        return this.isMuted
          ? (this.source === Track.Source.Camera &&
              !this.isUserProvided &&
              (this.log.debug("reacquiring camera track", this.logContext),
              yield this.restartTrack()),
            yield U.unmute.call(this),
            this)
          : (this.log.debug("Track already unmuted", this.logContext), this);
      } finally {
        F();
      }
    });
  }
  setTrackMuted(U) {
    super.setTrackMuted(U);
    for (const F of this.simulcastCodecs.values())
      F.mediaStreamTrack.enabled = !U;
  }
  getSenderStats() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      if (!(!((U = this.sender) === null || U === void 0) && U.getStats))
        return [];
      const F = [],
        q = yield this.sender.getStats();
      return (
        q.forEach((j) => {
          var V;
          if (j.type === "outbound-rtp") {
            const $ = {
                type: "video",
                streamId: j.id,
                frameHeight: j.frameHeight,
                frameWidth: j.frameWidth,
                framesPerSecond: j.framesPerSecond,
                framesSent: j.framesSent,
                firCount: j.firCount,
                pliCount: j.pliCount,
                nackCount: j.nackCount,
                packetsSent: j.packetsSent,
                bytesSent: j.bytesSent,
                qualityLimitationReason: j.qualityLimitationReason,
                qualityLimitationDurations: j.qualityLimitationDurations,
                qualityLimitationResolutionChanges:
                  j.qualityLimitationResolutionChanges,
                rid: (V = j.rid) !== null && V !== void 0 ? V : j.id,
                retransmittedPacketsSent: j.retransmittedPacketsSent,
                targetBitrate: j.targetBitrate,
                timestamp: j.timestamp,
              },
              W = q.get(j.remoteId);
            W &&
              (($.jitter = W.jitter),
              ($.packetsLost = W.packetsLost),
              ($.roundTripTime = W.roundTripTime)),
              F.push($);
          }
        }),
        F.sort((j, V) => {
          var $, W;
          return (
            (($ = V.frameWidth) !== null && $ !== void 0 ? $ : 0) -
            ((W = j.frameWidth) !== null && W !== void 0 ? W : 0)
          );
        }),
        F
      );
    });
  }
  setPublishingQuality(U) {
    const F = [];
    for (let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1)
      F.push(new SubscribedQuality({ quality: q, enabled: q <= U }));
    this.log.debug(
      "setting publishing quality. max quality ".concat(U),
      this.logContext
    ),
      this.setPublishingLayers(F);
  }
  restartTrack(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j, V, $;
      let W;
      if (U) {
        const Q = constraintsForOptions({ video: U });
        typeof Q.video != "boolean" && (W = Q.video);
      }
      yield this.restart(W);
      try {
        for (
          var K = !0, G = __asyncValues(this.simulcastCodecs.values()), H;
          (H = yield G.next()), (F = H.done), !F;
          K = !0
        ) {
          (V = H.value), (K = !1);
          const Q = V;
          Q.sender &&
            (($ = Q.sender.transport) === null || $ === void 0
              ? void 0
              : $.state) !== "closed" &&
            ((Q.mediaStreamTrack = this.mediaStreamTrack.clone()),
            yield Q.sender.replaceTrack(Q.mediaStreamTrack));
        }
      } catch (Q) {
        q = { error: Q };
      } finally {
        try {
          !K && !F && (j = G.return) && (yield j.call(G));
        } finally {
          if (q) throw q.error;
        }
      }
    });
  }
  setProcessor(U) {
    const F = Object.create(null, {
      setProcessor: { get: () => super.setProcessor },
    });
    return __awaiter$b(this, arguments, void 0, function (q) {
      var j = this;
      let V =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return (function* () {
        var $, W, K, G, H, Q;
        if (
          (yield F.setProcessor.call(j, q, V),
          !((H = j.processor) === null || H === void 0) && H.processedTrack)
        )
          try {
            for (
              var z = !0, Y = __asyncValues(j.simulcastCodecs.values()), X;
              (X = yield Y.next()), ($ = X.done), !$;
              z = !0
            )
              (G = X.value),
                (z = !1),
                yield (Q = G.sender) === null || Q === void 0
                  ? void 0
                  : Q.replaceTrack(j.processor.processedTrack);
          } catch (Z) {
            W = { error: Z };
          } finally {
            try {
              !z && !$ && (K = Y.return) && (yield K.call(Y));
            } finally {
              if (W) throw W.error;
            }
          }
      })();
    });
  }
  setDegradationPreference(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (((this.degradationPreference = U), this.sender))
        try {
          this.log.debug(
            "setting degradationPreference to ".concat(U),
            this.logContext
          );
          const F = this.sender.getParameters();
          (F.degradationPreference = U), this.sender.setParameters(F);
        } catch (F) {
          this.log.warn(
            "failed to set degradationPreference",
            Object.assign({ error: F }, this.logContext)
          );
        }
    });
  }
  addSimulcastTrack(U, F) {
    if (this.simulcastCodecs.has(U)) {
      this.log.error(
        "".concat(U, " already added, skipping adding simulcast codec"),
        this.logContext
      );
      return;
    }
    const q = {
      codec: U,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: F,
    };
    return this.simulcastCodecs.set(U, q), q;
  }
  setSimulcastTrackSender(U, F) {
    const q = this.simulcastCodecs.get(U);
    q &&
      ((q.sender = F),
      setTimeout(() => {
        this.subscribedCodecs &&
          this.setPublishingCodecs(this.subscribedCodecs);
      }, refreshSubscribedCodecAfterNewCodec));
  }
  setPublishingCodecs(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j, V, $, W, K;
      if (
        (this.log.debug(
          "setting publishing codecs",
          Object.assign(Object.assign({}, this.logContext), {
            codecs: U,
            currentCodec: this.codec,
          })
        ),
        !this.codec && U.length > 0)
      )
        return yield this.setPublishingLayers(U[0].qualities), [];
      this.subscribedCodecs = U;
      const G = [];
      try {
        for (
          F = !0, q = __asyncValues(U);
          (j = yield q.next()), (V = j.done), !V;
          F = !0
        ) {
          (K = j.value), (F = !1);
          const H = K;
          if (!this.codec || this.codec === H.codec)
            yield this.setPublishingLayers(H.qualities);
          else {
            const Q = this.simulcastCodecs.get(H.codec);
            if (
              (this.log.debug(
                "try setPublishingCodec for ".concat(H.codec),
                Object.assign(Object.assign({}, this.logContext), {
                  simulcastCodecInfo: Q,
                })
              ),
              !Q || !Q.sender)
            ) {
              for (const z of H.qualities)
                if (z.enabled) {
                  G.push(H.codec);
                  break;
                }
            } else
              Q.encodings &&
                (this.log.debug(
                  "try setPublishingLayersForSender ".concat(H.codec),
                  this.logContext
                ),
                yield setPublishingLayersForSender(
                  Q.sender,
                  Q.encodings,
                  H.qualities,
                  this.senderLock,
                  this.log,
                  this.logContext
                ));
          }
        }
      } catch (H) {
        $ = { error: H };
      } finally {
        try {
          !F && !V && (W = q.return) && (yield W.call(q));
        } finally {
          if ($) throw $.error;
        }
      }
      return G;
    });
  }
  setPublishingLayers(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.log.debug(
        "setting publishing layers",
        Object.assign(Object.assign({}, this.logContext), { qualities: U })
      ),
        !(!this.sender || !this.encodings) &&
          (yield setPublishingLayersForSender(
            this.sender,
            this.encodings,
            U,
            this.senderLock,
            this.log,
            this.logContext
          ));
    });
  }
  handleAppVisibilityChanged() {
    const U = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged,
      },
    });
    return __awaiter$b(this, void 0, void 0, function* () {
      yield U.handleAppVisibilityChanged.call(this),
        isMobile() &&
          this.isInBackground &&
          this.source === Track.Source.Camera &&
          (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(B, U, F, q, j, V) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const $ = yield q.lock();
    j.debug(
      "setPublishingLayersForSender",
      Object.assign(Object.assign({}, V), {
        sender: B,
        qualities: F,
        senderEncodings: U,
      })
    );
    try {
      const W = B.getParameters(),
        { encodings: K } = W;
      if (!K) return;
      if (K.length !== U.length) {
        j.warn(
          "cannot set publishing layers, encodings mismatch",
          Object.assign(Object.assign({}, V), {
            encodings: K,
            senderEncodings: U,
          })
        );
        return;
      }
      let G = !1;
      const H = getBrowser();
      if (
        (H == null ? void 0 : H.name) === "Chrome" &&
        compareVersions(H == null ? void 0 : H.version, "133") > 0 &&
        K[0].scalabilityMode
      ) {
        const z = K[0],
          Y = new ScalabilityMode(z.scalabilityMode);
        let X = VideoQuality$1.OFF;
        if (
          (F.forEach((Z) => {
            Z.enabled &&
              (X === VideoQuality$1.OFF || Z.quality > X) &&
              (X = Z.quality);
          }),
          X === VideoQuality$1.OFF)
        )
          z.active && ((z.active = !1), (G = !0));
        else if (!z.active || Y.spatial !== X + 1) {
          (G = !0), (z.active = !0);
          const Z = new ScalabilityMode(U[0].scalabilityMode);
          (Y.spatial = X + 1),
            (Y.suffix = Z.suffix),
            Y.spatial === 1 && (Y.suffix = void 0),
            (z.scalabilityMode = Y.toString()),
            (z.scaleResolutionDownBy = Math.pow(2, 2 - X)),
            U[0].maxBitrate &&
              (z.maxBitrate =
                U[0].maxBitrate /
                (z.scaleResolutionDownBy * z.scaleResolutionDownBy));
        }
      } else
        K.forEach((z, Y) => {
          var X;
          let Z = (X = z.rid) !== null && X !== void 0 ? X : "";
          Z === "" && (Z = "q");
          const se = videoQualityForRid(Z),
            ee = F.find((ie) => ie.quality === se);
          ee &&
            z.active !== ee.enabled &&
            ((G = !0),
            (z.active = ee.enabled),
            j.debug(
              "setting layer "
                .concat(ee.quality, " to ")
                .concat(z.active ? "enabled" : "disabled"),
              V
            ),
            isFireFox() &&
              (ee.enabled
                ? ((z.scaleResolutionDownBy = U[Y].scaleResolutionDownBy),
                  (z.maxBitrate = U[Y].maxBitrate),
                  (z.maxFrameRate = U[Y].maxFrameRate))
                : ((z.scaleResolutionDownBy = 4),
                  (z.maxBitrate = 10),
                  (z.maxFrameRate = 2))));
        });
      G &&
        ((W.encodings = K),
        j.debug(
          "setting encodings",
          Object.assign(Object.assign({}, V), { encodings: W.encodings })
        ),
        yield B.setParameters(W));
    } finally {
      $();
    }
  });
}
function videoQualityForRid(B) {
  switch (B) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(B, U, F, q) {
  if (!F)
    return [
      new VideoLayer({
        quality: VideoQuality.HIGH,
        width: B,
        height: U,
        bitrate: 0,
        ssrc: 0,
      }),
    ];
  if (q) {
    const j = F[0].scalabilityMode,
      V = new ScalabilityMode(j),
      $ = [],
      W = V.suffix == "h" ? 1.5 : 2,
      K = V.suffix == "h" ? 2 : 3;
    for (let G = 0; G < V.spatial; G += 1)
      $.push(
        new VideoLayer({
          quality: Math.min(VideoQuality.HIGH, V.spatial - 1) - G,
          width: Math.ceil(B / Math.pow(W, G)),
          height: Math.ceil(U / Math.pow(W, G)),
          bitrate: F[0].maxBitrate
            ? Math.ceil(F[0].maxBitrate / Math.pow(K, G))
            : 0,
          ssrc: 0,
        })
      );
    return $;
  }
  return F.map((j) => {
    var V, $, W;
    const K = (V = j.scaleResolutionDownBy) !== null && V !== void 0 ? V : 1;
    let G = videoQualityForRid(($ = j.rid) !== null && $ !== void 0 ? $ : "");
    return new VideoLayer({
      quality: G,
      width: Math.ceil(B / K),
      height: Math.ceil(U / K),
      bitrate: (W = j.maxBitrate) !== null && W !== void 0 ? W : 0,
      ssrc: 0,
    });
  });
}
const lossyDataChannel = "_lossy",
  reliableDataChannel = "_reliable",
  minReconnectWait = 2 * 1e3,
  leaveReconnect = "leave-reconnect";
var PCState;
(function (B) {
  (B[(B.New = 0)] = "New"),
    (B[(B.Connected = 1)] = "Connected"),
    (B[(B.Disconnected = 2)] = "Disconnected"),
    (B[(B.Reconnecting = 3)] = "Reconnecting"),
    (B[(B.Closed = 4)] = "Closed");
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports$1.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(U) {
    var F;
    super(),
      (this.options = U),
      (this.rtcConfig = {}),
      (this.peerConnectionTimeout =
        roomConnectOptionDefaults.peerConnectionTimeout),
      (this.fullReconnectOnNext = !1),
      (this.subscriberPrimary = !1),
      (this.pcState = PCState.New),
      (this._isClosed = !0),
      (this.pendingTrackResolvers = {}),
      (this.reconnectAttempts = 0),
      (this.reconnectStart = 0),
      (this.attemptingReconnect = !1),
      (this.joinAttempts = 0),
      (this.maxJoinAttempts = 1),
      (this.shouldFailNext = !1),
      (this.log = livekitLogger),
      (this.handleDataChannel = (q) =>
        __awaiter$b(this, [q], void 0, function (j) {
          var V = this;
          let { channel: $ } = j;
          return (function* () {
            if ($) {
              if ($.label === reliableDataChannel) V.reliableDCSub = $;
              else if ($.label === lossyDataChannel) V.lossyDCSub = $;
              else return;
              V.log.debug(
                "on data channel ".concat($.id, ", ").concat($.label),
                V.logContext
              ),
                ($.onmessage = V.handleDataMessage);
            }
          })();
        })),
      (this.handleDataMessage = (q) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var j, V;
          const $ = yield this.dataProcessLock.lock();
          try {
            let W;
            if (q.data instanceof ArrayBuffer) W = q.data;
            else if (q.data instanceof Blob) W = yield q.data.arrayBuffer();
            else {
              this.log.error(
                "unsupported data type",
                Object.assign(Object.assign({}, this.logContext), {
                  data: q.data,
                })
              );
              return;
            }
            const K = DataPacket.fromBinary(new Uint8Array(W));
            ((j = K.value) === null || j === void 0 ? void 0 : j.case) ===
            "speaker"
              ? this.emit(
                  EngineEvent.ActiveSpeakersUpdate,
                  K.value.value.speakers
                )
              : (((V = K.value) === null || V === void 0 ? void 0 : V.case) ===
                  "user" && applyUserDataCompat(K, K.value.value),
                this.emit(EngineEvent.DataPacketReceived, K));
          } finally {
            $();
          }
        })),
      (this.handleDataError = (q) => {
        const V = q.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
        if (q instanceof ErrorEvent && q.error) {
          const { error: $ } = q.error;
          this.log.error(
            "DataChannel error on ".concat(V, ": ").concat(q.message),
            Object.assign(Object.assign({}, this.logContext), { error: $ })
          );
        } else
          this.log.error(
            "Unknown DataChannel error on ".concat(V),
            Object.assign(Object.assign({}, this.logContext), { event: q })
          );
      }),
      (this.handleBufferedAmountLow = (q) => {
        const V =
          q.currentTarget.maxRetransmits === 0
            ? DataPacket_Kind.LOSSY
            : DataPacket_Kind.RELIABLE;
        this.updateAndEmitDCBufferStatus(V);
      }),
      (this.handleDisconnect = (q, j) => {
        if (this._isClosed) return;
        this.log.warn("".concat(q, " disconnected"), this.logContext),
          this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
        const V = (K) => {
            this.log.warn(
              "could not recover connection after "
                .concat(this.reconnectAttempts, " attempts, ")
                .concat(K, "ms. giving up"),
              this.logContext
            ),
              this.emit(EngineEvent.Disconnected),
              this.close();
          },
          $ = Date.now() - this.reconnectStart;
        let W = this.getNextRetryDelay({
          elapsedMs: $,
          retryCount: this.reconnectAttempts,
        });
        if (W === null) {
          V($);
          return;
        }
        q === leaveReconnect && (W = 0),
          this.log.debug("reconnecting in ".concat(W, "ms"), this.logContext),
          this.clearReconnectTimeout(),
          this.token &&
            this.regionUrlProvider &&
            this.regionUrlProvider.updateToken(this.token),
          (this.reconnectTimeout = CriticalTimers.setTimeout(
            () =>
              this.attemptReconnect(j).finally(
                () => (this.reconnectTimeout = void 0)
              ),
            W
          ));
      }),
      (this.waitForRestarted = () =>
        new Promise((q, j) => {
          this.pcState === PCState.Connected && q();
          const V = () => {
              this.off(EngineEvent.Disconnected, $), q();
            },
            $ = () => {
              this.off(EngineEvent.Restarted, V), j();
            };
          this.once(EngineEvent.Restarted, V),
            this.once(EngineEvent.Disconnected, $);
        })),
      (this.updateAndEmitDCBufferStatus = (q) => {
        const j = this.isBufferStatusLow(q);
        typeof j < "u" &&
          j !== this.dcBufferStatus.get(q) &&
          (this.dcBufferStatus.set(q, j),
          this.emit(EngineEvent.DCBufferStatusChanged, j, q));
      }),
      (this.isBufferStatusLow = (q) => {
        const j = this.dataChannelForKind(q);
        if (j) return j.bufferedAmount <= j.bufferedAmountLowThreshold;
      }),
      (this.handleBrowserOnLine = () => {
        this.client.currentState === SignalConnectionState.RECONNECTING &&
          (this.clearReconnectTimeout(),
          this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
      }),
      (this.log = getLogger(
        (F = U.loggerName) !== null && F !== void 0 ? F : LoggerNames.Engine
      )),
      (this.loggerOptions = {
        loggerName: U.loggerName,
        loggerContextCb: () => this.logContext,
      }),
      (this.client = new SignalClient(void 0, this.loggerOptions)),
      (this.client.signalLatency = this.options.expSignalLatency),
      (this.reconnectPolicy = this.options.reconnectPolicy),
      this.registerOnLineListener(),
      (this.closingLock = new _$1()),
      (this.dataProcessLock = new _$1()),
      (this.dcBufferStatus = new Map([
        [DataPacket_Kind.LOSSY, !0],
        [DataPacket_Kind.RELIABLE, !0],
      ])),
      (this.client.onParticipantUpdate = (q) =>
        this.emit(EngineEvent.ParticipantUpdate, q)),
      (this.client.onConnectionQuality = (q) =>
        this.emit(EngineEvent.ConnectionQualityUpdate, q)),
      (this.client.onRoomUpdate = (q) => this.emit(EngineEvent.RoomUpdate, q)),
      (this.client.onSubscriptionError = (q) =>
        this.emit(EngineEvent.SubscriptionError, q)),
      (this.client.onSubscriptionPermissionUpdate = (q) =>
        this.emit(EngineEvent.SubscriptionPermissionUpdate, q)),
      (this.client.onSpeakersChanged = (q) =>
        this.emit(EngineEvent.SpeakersChanged, q)),
      (this.client.onStreamStateUpdate = (q) =>
        this.emit(EngineEvent.StreamStateChanged, q)),
      (this.client.onRequestResponse = (q) =>
        this.emit(EngineEvent.SignalRequestResponse, q));
  }
  get logContext() {
    var U, F, q, j, V, $, W, K;
    return {
      room:
        (F =
          (U = this.latestJoinResponse) === null || U === void 0
            ? void 0
            : U.room) === null || F === void 0
          ? void 0
          : F.name,
      roomID:
        (j =
          (q = this.latestJoinResponse) === null || q === void 0
            ? void 0
            : q.room) === null || j === void 0
          ? void 0
          : j.sid,
      participant:
        ($ =
          (V = this.latestJoinResponse) === null || V === void 0
            ? void 0
            : V.participant) === null || $ === void 0
          ? void 0
          : $.identity,
      pID:
        (K =
          (W = this.latestJoinResponse) === null || W === void 0
            ? void 0
            : W.participant) === null || K === void 0
          ? void 0
          : K.sid,
    };
  }
  join(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.url = U),
        (this.token = F),
        (this.signalOpts = q),
        (this.maxJoinAttempts = q.maxRetries);
      try {
        (this.joinAttempts += 1), this.setupSignalClientCallbacks();
        const V = yield this.client.join(U, F, q, j);
        return (
          (this._isClosed = !1),
          (this.latestJoinResponse = V),
          (this.subscriberPrimary = V.subscriberPrimary),
          this.pcManager || (yield this.configure(V)),
          (!this.subscriberPrimary || V.fastPublish) && this.negotiate(),
          (this.clientConfiguration = V.clientConfiguration),
          setTimeout(() => {
            this.emit(EngineEvent.SignalConnected);
          }, 10),
          V
        );
      } catch (V) {
        if (
          V instanceof ConnectionError &&
          V.reason === ConnectionErrorReason.ServerUnreachable &&
          (this.log.warn(
            "Couldn't connect to server, attempt "
              .concat(this.joinAttempts, " of ")
              .concat(this.maxJoinAttempts),
            this.logContext
          ),
          this.joinAttempts < this.maxJoinAttempts)
        )
          return this.join(U, F, q, j);
        throw V;
      }
    });
  }
  close() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const U = yield this.closingLock.lock();
      if (this.isClosed) {
        U();
        return;
      }
      try {
        (this._isClosed = !0),
          (this.joinAttempts = 0),
          this.emit(EngineEvent.Closing),
          this.removeAllListeners(),
          this.deregisterOnLineListener(),
          this.clearPendingReconnect(),
          yield this.cleanupPeerConnections(),
          yield this.cleanupClient();
      } finally {
        U();
      }
    });
  }
  cleanupPeerConnections() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      yield (U = this.pcManager) === null || U === void 0 ? void 0 : U.close(),
        (this.pcManager = void 0);
      const F = (q) => {
        q &&
          (q.close(),
          (q.onbufferedamountlow = null),
          (q.onclose = null),
          (q.onclosing = null),
          (q.onerror = null),
          (q.onmessage = null),
          (q.onopen = null));
      };
      F(this.lossyDC),
        F(this.lossyDCSub),
        F(this.reliableDC),
        F(this.reliableDCSub),
        (this.lossyDC = void 0),
        (this.lossyDCSub = void 0),
        (this.reliableDC = void 0),
        (this.reliableDCSub = void 0);
    });
  }
  cleanupClient() {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(U) {
    if (this.pendingTrackResolvers[U.cid])
      throw new TrackInvalidError(
        "a track with the same ID has already been published"
      );
    return new Promise((F, q) => {
      const j = setTimeout(() => {
        delete this.pendingTrackResolvers[U.cid],
          q(
            new ConnectionError(
              "publication of local track timed out, no response from server",
              ConnectionErrorReason.InternalError
            )
          );
      }, 1e4);
      (this.pendingTrackResolvers[U.cid] = {
        resolve: (V) => {
          clearTimeout(j), F(V);
        },
        reject: () => {
          clearTimeout(j),
            q(new Error("Cancelled publication by calling unpublish"));
        },
      }),
        this.client.sendAddTrack(U);
    });
  }
  removeTrack(U) {
    if (U.track && this.pendingTrackResolvers[U.track.id]) {
      const { reject: F } = this.pendingTrackResolvers[U.track.id];
      F && F(), delete this.pendingTrackResolvers[U.track.id];
    }
    try {
      return this.pcManager.removeTrack(U), !0;
    } catch (F) {
      this.log.warn(
        "failed to remove track",
        Object.assign(Object.assign({}, this.logContext), { error: F })
      );
    }
    return !1;
  }
  updateMuteStatus(U, F) {
    this.client.sendMuteTrack(U, F);
  }
  get dataSubscriberReadyState() {
    var U;
    return (U = this.reliableDCSub) === null || U === void 0
      ? void 0
      : U.readyState;
  }
  getConnectedServerAddress() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      return (U = this.pcManager) === null || U === void 0
        ? void 0
        : U.getConnectedAddress();
    });
  }
  setRegionUrlProvider(U) {
    this.regionUrlProvider = U;
  }
  configure(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q;
      if (
        this.pcManager &&
        this.pcManager.currentState !== PCTransportState.NEW
      )
        return;
      this.participantSid =
        (F = U.participant) === null || F === void 0 ? void 0 : F.sid;
      const j = this.makeRTCConfiguration(U);
      (this.pcManager = new PCTransportManager(
        j,
        U.subscriberPrimary,
        this.loggerOptions
      )),
        this.emit(
          EngineEvent.TransportsCreated,
          this.pcManager.publisher,
          this.pcManager.subscriber
        ),
        (this.pcManager.onIceCandidate = (V, $) => {
          this.client.sendIceCandidate(V, $);
        }),
        (this.pcManager.onPublisherOffer = (V) => {
          this.client.sendOffer(V);
        }),
        (this.pcManager.onDataChannel = this.handleDataChannel),
        (this.pcManager.onStateChange = (V, $, W) =>
          __awaiter$b(this, void 0, void 0, function* () {
            if (
              (this.log.debug(
                "primary PC state changed ".concat(V),
                this.logContext
              ),
              ["closed", "disconnected", "failed"].includes($) &&
                (this.publisherConnectionPromise = void 0),
              V === PCTransportState.CONNECTED)
            ) {
              const H = this.pcState === PCState.New;
              (this.pcState = PCState.Connected),
                H && this.emit(EngineEvent.Connected, U);
            } else V === PCTransportState.FAILED && this.pcState === PCState.Connected && ((this.pcState = PCState.Disconnected), this.handleDisconnect("peerconnection failed", W === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
            const K =
                this.client.isDisconnected ||
                this.client.currentState === SignalConnectionState.RECONNECTING,
              G = [
                PCTransportState.FAILED,
                PCTransportState.CLOSING,
                PCTransportState.CLOSED,
              ].includes(V);
            K && G && !this._isClosed && this.emit(EngineEvent.Offline);
          })),
        (this.pcManager.onTrack = (V) => {
          this.emit(
            EngineEvent.MediaTrackAdded,
            V.track,
            V.streams[0],
            V.receiver
          );
        }),
        supportOptionalDatachannel(
          (q = U.serverInfo) === null || q === void 0 ? void 0 : q.protocol
        ) || this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    (this.client.onAnswer = (U) =>
      __awaiter$b(this, void 0, void 0, function* () {
        this.pcManager &&
          (this.log.debug(
            "received server answer",
            Object.assign(Object.assign({}, this.logContext), {
              RTCSdpType: U.type,
            })
          ),
          yield this.pcManager.setPublisherAnswer(U));
      })),
      (this.client.onTrickle = (U, F) => {
        this.pcManager &&
          (this.log.debug(
            "got ICE candidate from peer",
            Object.assign(Object.assign({}, this.logContext), {
              candidate: U,
              target: F,
            })
          ),
          this.pcManager.addIceCandidate(U, F));
      }),
      (this.client.onOffer = (U) =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.pcManager) return;
          const F = yield this.pcManager.createSubscriberAnswerFromOffer(U);
          this.client.sendAnswer(F);
        })),
      (this.client.onLocalTrackPublished = (U) => {
        var F;
        if (
          (this.log.debug(
            "received trackPublishedResponse",
            Object.assign(Object.assign({}, this.logContext), {
              cid: U.cid,
              track: (F = U.track) === null || F === void 0 ? void 0 : F.sid,
            })
          ),
          !this.pendingTrackResolvers[U.cid])
        ) {
          this.log.error(
            "missing track resolver for ".concat(U.cid),
            Object.assign(Object.assign({}, this.logContext), { cid: U.cid })
          );
          return;
        }
        const { resolve: q } = this.pendingTrackResolvers[U.cid];
        delete this.pendingTrackResolvers[U.cid], q(U.track);
      }),
      (this.client.onLocalTrackUnpublished = (U) => {
        this.emit(EngineEvent.LocalTrackUnpublished, U);
      }),
      (this.client.onLocalTrackSubscribed = (U) => {
        this.emit(EngineEvent.LocalTrackSubscribed, U);
      }),
      (this.client.onTokenRefresh = (U) => {
        this.token = U;
      }),
      (this.client.onRemoteMuteChanged = (U, F) => {
        this.emit(EngineEvent.RemoteMute, U, F);
      }),
      (this.client.onSubscribedQualityUpdate = (U) => {
        this.emit(EngineEvent.SubscribedQualityUpdate, U);
      }),
      (this.client.onClose = () => {
        this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
      }),
      (this.client.onLeave = (U) => {
        switch (
          (this.log.debug(
            "client leave request",
            Object.assign(Object.assign({}, this.logContext), {
              reason: U == null ? void 0 : U.reason,
            })
          ),
          U.regions &&
            this.regionUrlProvider &&
            (this.log.debug("updating regions", this.logContext),
            this.regionUrlProvider.setServerReportedRegions(U.regions)),
          U.action)
        ) {
          case LeaveRequest_Action.DISCONNECT:
            this.emit(EngineEvent.Disconnected, U == null ? void 0 : U.reason),
              this.close();
            break;
          case LeaveRequest_Action.RECONNECT:
            (this.fullReconnectOnNext = !0),
              this.handleDisconnect(leaveReconnect);
            break;
          case LeaveRequest_Action.RESUME:
            this.handleDisconnect(leaveReconnect);
        }
      });
  }
  makeRTCConfiguration(U) {
    var F;
    const q = Object.assign({}, this.rtcConfig);
    if (
      (!((F = this.signalOpts) === null || F === void 0) &&
        F.e2eeEnabled &&
        (this.log.debug(
          "E2EE - setting up transports with insertable streams",
          this.logContext
        ),
        (q.encodedInsertableStreams = !0)),
      U.iceServers && !q.iceServers)
    ) {
      const j = [];
      U.iceServers.forEach((V) => {
        const $ = { urls: V.urls };
        V.username && ($.username = V.username),
          V.credential && ($.credential = V.credential),
          j.push($);
      }),
        (q.iceServers = j);
    }
    return (
      U.clientConfiguration &&
        U.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED &&
        (q.iceTransportPolicy = "relay"),
      (q.sdpSemantics = "unified-plan"),
      (q.continualGatheringPolicy = "gather_continually"),
      q
    );
  }
  createDataChannels() {
    this.pcManager &&
      (this.lossyDC &&
        ((this.lossyDC.onmessage = null), (this.lossyDC.onerror = null)),
      this.reliableDC &&
        ((this.reliableDC.onmessage = null), (this.reliableDC.onerror = null)),
      (this.lossyDC = this.pcManager.createPublisherDataChannel(
        lossyDataChannel,
        { ordered: !0, maxRetransmits: 0 }
      )),
      (this.reliableDC = this.pcManager.createPublisherDataChannel(
        reliableDataChannel,
        { ordered: !0 }
      )),
      (this.lossyDC.onmessage = this.handleDataMessage),
      (this.reliableDC.onmessage = this.handleDataMessage),
      (this.lossyDC.onerror = this.handleDataError),
      (this.reliableDC.onerror = this.handleDataError),
      (this.lossyDC.bufferedAmountLowThreshold = 65535),
      (this.reliableDC.bufferedAmountLowThreshold = 65535),
      (this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow),
      (this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow));
  }
  createSender(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(U, F, q);
      if (supportsAddTrack())
        return (
          this.log.warn("using add-track fallback", this.logContext),
          yield this.createRTCRtpSender(U.mediaStreamTrack)
        );
      throw new UnexpectedConnectionState(
        "Required webRTC APIs not supported on this device"
      );
    });
  }
  createSimulcastSender(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(U, F, q, j);
      if (supportsAddTrack())
        return (
          this.log.debug("using add-track fallback", this.logContext),
          this.createRTCRtpSender(U.mediaStreamTrack)
        );
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const j = [];
      U.mediaStream && j.push(U.mediaStream),
        isVideoTrack(U) && (U.codec = F.videoCodec);
      const V = { direction: "sendonly", streams: j };
      return (
        q && (V.sendEncodings = q),
        (yield this.pcManager.addPublisherTransceiver(U.mediaStreamTrack, V))
          .sender
      );
    });
  }
  createSimulcastTransceiverSender(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const V = { direction: "sendonly" };
      j && (V.sendEncodings = j);
      const $ = yield this.pcManager.addPublisherTransceiver(
        F.mediaStreamTrack,
        V
      );
      if (q.videoCodec)
        return U.setSimulcastTrackSender(q.videoCodec, $.sender), $.sender;
    });
  }
  createRTCRtpSender(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(U);
    });
  }
  attemptReconnect(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j;
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn(
            "already attempting reconnect, returning early",
            this.logContext
          );
          return;
        }
        (((F = this.clientConfiguration) === null || F === void 0
          ? void 0
          : F.resumeConnection) === ClientConfigSetting.DISABLED ||
          ((j =
            (q = this.pcManager) === null || q === void 0
              ? void 0
              : q.currentState) !== null && j !== void 0
            ? j
            : PCTransportState.NEW) === PCTransportState.NEW) &&
          (this.fullReconnectOnNext = !0);
        try {
          (this.attemptingReconnect = !0),
            this.fullReconnectOnNext
              ? yield this.restartConnection()
              : yield this.resumeConnection(U),
            this.clearPendingReconnect(),
            (this.fullReconnectOnNext = !1);
        } catch (V) {
          this.reconnectAttempts += 1;
          let $ = !0;
          V instanceof UnexpectedConnectionState
            ? (this.log.debug(
                "received unrecoverable error",
                Object.assign(Object.assign({}, this.logContext), { error: V })
              ),
              ($ = !1))
            : V instanceof SignalReconnectError ||
              (this.fullReconnectOnNext = !0),
            $
              ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN)
              : (this.log.info(
                  "could not recover connection after "
                    .concat(this.reconnectAttempts, " attempts, ")
                    .concat(Date.now() - this.reconnectStart, "ms. giving up"),
                  this.logContext
                ),
                this.emit(EngineEvent.Disconnected),
                yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(U) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(U);
    } catch (F) {
      this.log.warn(
        "encountered error in reconnect policy",
        Object.assign(Object.assign({}, this.logContext), { error: F })
      );
    }
    return null;
  }
  restartConnection(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j;
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState(
            "could not reconnect, url or token not saved"
          );
        this.log.info(
          "reconnecting, attempt: ".concat(this.reconnectAttempts),
          this.logContext
        ),
          this.emit(EngineEvent.Restarting),
          this.client.isDisconnected || (yield this.client.sendLeave()),
          yield this.cleanupPeerConnections(),
          yield this.cleanupClient();
        let V;
        try {
          if (!this.signalOpts)
            throw (
              (this.log.warn(
                "attempted connection restart, without signal options present",
                this.logContext
              ),
              new SignalReconnectError())
            );
          V = yield this.join(U ?? this.url, this.token, this.signalOpts);
        } catch ($) {
          throw $ instanceof ConnectionError &&
            $.reason === ConnectionErrorReason.NotAllowed
            ? new UnexpectedConnectionState(
                "could not reconnect, token might be expired"
              )
            : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw ((this.shouldFailNext = !1), new Error("simulated failure"));
        if (
          (this.client.setReconnected(),
          this.emit(EngineEvent.SignalRestarted, V),
          yield this.waitForPCReconnected(),
          this.client.currentState !== SignalConnectionState.CONNECTED)
        )
          throw new SignalReconnectError(
            "Signal connection got severed during reconnect"
          );
        (F = this.regionUrlProvider) === null ||
          F === void 0 ||
          F.resetAttempts(),
          this.emit(EngineEvent.Restarted);
      } catch (V) {
        const $ = yield (q = this.regionUrlProvider) === null || q === void 0
          ? void 0
          : q.getNextBestRegionUrl();
        if ($) {
          yield this.restartConnection($);
          return;
        } else throw ((j = this.regionUrlProvider) === null || j === void 0 || j.resetAttempts(), V);
      }
    });
  }
  resumeConnection(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F;
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState(
          "could not reconnect, url or token not saved"
        );
      if (!this.pcManager)
        throw new UnexpectedConnectionState(
          "publisher and subscriber connections unset"
        );
      this.log.info(
        "resuming signal connection, attempt ".concat(this.reconnectAttempts),
        this.logContext
      ),
        this.emit(EngineEvent.Resuming);
      let q;
      try {
        this.setupSignalClientCallbacks(),
          (q = yield this.client.reconnect(
            this.url,
            this.token,
            this.participantSid,
            U
          ));
      } catch (j) {
        let V = "";
        throw (
          (j instanceof Error &&
            ((V = j.message),
            this.log.error(
              j.message,
              Object.assign(Object.assign({}, this.logContext), { error: j })
            )),
          j instanceof ConnectionError &&
          j.reason === ConnectionErrorReason.NotAllowed
            ? new UnexpectedConnectionState(
                "could not reconnect, token might be expired"
              )
            : j instanceof ConnectionError &&
              j.reason === ConnectionErrorReason.LeaveRequest
            ? j
            : new SignalReconnectError(V))
        );
      }
      if ((this.emit(EngineEvent.SignalResumed), q)) {
        const j = this.makeRTCConfiguration(q);
        this.pcManager.updateConfiguration(j);
      } else this.log.warn("Did not receive reconnect response", this.logContext);
      if (this.shouldFailNext)
        throw ((this.shouldFailNext = !1), new Error("simulated failure"));
      if (
        (yield this.pcManager.triggerIceRestart(),
        yield this.waitForPCReconnected(),
        this.client.currentState !== SignalConnectionState.CONNECTED)
      )
        throw new SignalReconnectError(
          "Signal connection got severed during reconnect"
        );
      this.client.setReconnected(),
        ((F = this.reliableDC) === null || F === void 0
          ? void 0
          : F.readyState) === "open" &&
          this.reliableDC.id === null &&
          this.createDataChannels(),
        this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(F, U);
    });
  }
  waitForPCReconnected() {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.pcState = PCState.Reconnecting),
        this.log.debug(
          "waiting for peer connection to reconnect",
          this.logContext
        );
      try {
        if ((yield sleep$1(minReconnectWait), !this.pcManager))
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(
          void 0,
          this.peerConnectionTimeout
        ),
          (this.pcState = PCState.Connected);
      } catch (U) {
        throw (
          ((this.pcState = PCState.Disconnected),
          new ConnectionError(
            "could not establish PC connection, ".concat(U.message),
            ConnectionErrorReason.InternalError
          ))
        );
      }
    });
  }
  publishRpcResponse(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const V = new DataPacket({
        destinationIdentities: [U],
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "rpcResponse",
          value: new RpcResponse({
            requestId: F,
            value: j
              ? { case: "error", value: j.toProto() }
              : { case: "payload", value: q ?? "" },
          }),
        },
      });
      yield this.sendDataPacket(V, DataPacket_Kind.RELIABLE);
    });
  }
  publishRpcAck(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = new DataPacket({
        destinationIdentities: [U],
        kind: DataPacket_Kind.RELIABLE,
        value: { case: "rpcAck", value: new RpcAck({ requestId: F }) },
      });
      yield this.sendDataPacket(q, DataPacket_Kind.RELIABLE);
    });
  }
  sendDataPacket(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = U.toBinary();
      yield this.ensurePublisherConnected(F);
      const j = this.dataChannelForKind(F);
      j && j.send(q), this.updateAndEmitDCBufferStatus(F);
    });
  }
  waitForBufferStatusLow(U) {
    return new Promise((F, q) =>
      __awaiter$b(this, void 0, void 0, function* () {
        if (this.isBufferStatusLow(U)) F();
        else {
          const j = () => q("Engine closed");
          for (this.once(EngineEvent.Closing, j); !this.dcBufferStatus.get(U); )
            yield sleep$1(10);
          this.off(EngineEvent.Closing, j), F();
        }
      })
    );
  }
  ensureDataTransportConnected(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : this.subscriberPrimary;
      return (function* () {
        var V;
        if (!q.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        const $ = j ? q.pcManager.subscriber : q.pcManager.publisher,
          W = j ? "Subscriber" : "Publisher";
        if (!$)
          throw new ConnectionError(
            "".concat(W, " connection not set"),
            ConnectionErrorReason.InternalError
          );
        let K = !1;
        !j && !q.dataChannelForKind(F, j) && (q.createDataChannels(), (K = !0)),
          !K &&
            !j &&
            !q.pcManager.publisher.isICEConnected &&
            q.pcManager.publisher.getICEConnectionState() !== "checking" &&
            (K = !0),
          K && q.negotiate();
        const G = q.dataChannelForKind(F, j);
        if ((G == null ? void 0 : G.readyState) === "open") return;
        const H = new Date().getTime() + q.peerConnectionTimeout;
        for (; new Date().getTime() < H; ) {
          if (
            $.isICEConnected &&
            ((V = q.dataChannelForKind(F, j)) === null || V === void 0
              ? void 0
              : V.readyState) === "open"
          )
            return;
          yield sleep$1(50);
        }
        throw new ConnectionError(
          "could not establish "
            .concat(W, " connection, state: ")
            .concat($.getICEConnectionState()),
          ConnectionErrorReason.InternalError
        );
      })();
    });
  }
  ensurePublisherConnected(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.publisherConnectionPromise ||
        (this.publisherConnectionPromise = this.ensureDataTransportConnected(
          U,
          !1
        )),
        yield this.publisherConnectionPromise;
    });
  }
  verifyTransport() {
    return !(
      !this.pcManager ||
      this.pcManager.currentState !== PCTransportState.CONNECTED ||
      !this.client.ws ||
      this.client.ws.readyState === WebSocket.CLOSED
    );
  }
  negotiate() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return new Promise((U, F) =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.pcManager) {
            F(new NegotiationError("PC manager is closed"));
            return;
          }
          this.pcManager.requirePublisher(),
            this.pcManager.publisher.getTransceivers().length == 0 &&
              !this.lossyDC &&
              !this.reliableDC &&
              this.createDataChannels();
          const q = new AbortController(),
            j = () => {
              q.abort(),
                this.log.debug(
                  "engine disconnected while negotiation was ongoing",
                  this.logContext
                ),
                U();
            };
          this.isClosed && F("cannot negotiate on closed engine"),
            this.on(EngineEvent.Closing, j),
            this.pcManager.publisher.once(
              PCEvents.RTPVideoPayloadTypes,
              (V) => {
                const $ = new Map();
                V.forEach((W) => {
                  const K = W.codec.toLowerCase();
                  isVideoCodec(K) && $.set(W.payload, K);
                }),
                  this.emit(EngineEvent.RTPVideoMapUpdate, $);
              }
            );
          try {
            yield this.pcManager.negotiate(q), U();
          } catch (V) {
            V instanceof NegotiationError && (this.fullReconnectOnNext = !0),
              this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN),
              F(V);
          } finally {
            this.off(EngineEvent.Closing, j);
          }
        })
      );
    });
  }
  dataChannelForKind(U, F) {
    if (F) {
      if (U === DataPacket_Kind.LOSSY) return this.lossyDCSub;
      if (U === DataPacket_Kind.RELIABLE) return this.reliableDCSub;
    } else {
      if (U === DataPacket_Kind.LOSSY) return this.lossyDC;
      if (U === DataPacket_Kind.RELIABLE) return this.reliableDC;
    }
  }
  sendSyncState(U, F) {
    var q, j;
    if (!this.pcManager) {
      this.log.warn(
        "sync state cannot be sent without peer connection setup",
        this.logContext
      );
      return;
    }
    const V = this.pcManager.subscriber.getLocalDescription(),
      $ = this.pcManager.subscriber.getRemoteDescription(),
      W =
        (j =
          (q = this.signalOpts) === null || q === void 0
            ? void 0
            : q.autoSubscribe) !== null && j !== void 0
          ? j
          : !0,
      K = new Array(),
      G = new Array();
    U.forEach((H) => {
      H.isDesired !== W && K.push(H.trackSid),
        H.isEnabled || G.push(H.trackSid);
    }),
      this.client.sendSyncState(
        new SyncState({
          answer: V
            ? toProtoSessionDescription({ sdp: V.sdp, type: V.type })
            : void 0,
          offer: $
            ? toProtoSessionDescription({ sdp: $.sdp, type: $.type })
            : void 0,
          subscription: new UpdateSubscription({
            trackSids: K,
            subscribe: !W,
            participantTracks: [],
          }),
          publishTracks: getTrackPublicationInfo(F),
          dataChannels: this.dataChannelsInfo(),
          trackSidsDisabled: G,
        })
      );
  }
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const U = [],
      F = (q, j) => {
        (q == null ? void 0 : q.id) !== void 0 &&
          q.id !== null &&
          U.push(new DataChannelInfo({ label: q.label, id: q.id, target: j }));
      };
    return (
      F(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER),
      F(
        this.dataChannelForKind(DataPacket_Kind.RELIABLE),
        SignalTarget.PUBLISHER
      ),
      F(
        this.dataChannelForKind(DataPacket_Kind.LOSSY, !0),
        SignalTarget.SUBSCRIBER
      ),
      F(
        this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0),
        SignalTarget.SUBSCRIBER
      ),
      U
    );
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), (this.reconnectAttempts = 0);
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {}
function supportOptionalDatachannel(B) {
  return B !== void 0 && B > 13;
}
function applyUserDataCompat(B, U) {
  const F = B.participantIdentity
    ? B.participantIdentity
    : U.participantIdentity;
  (B.participantIdentity = F), (U.participantIdentity = F);
  const q =
    B.destinationIdentities.length !== 0
      ? B.destinationIdentities
      : U.destinationIdentities;
  (B.destinationIdentities = q), (U.destinationIdentities = q);
}
class RegionUrlProvider {
  constructor(U, F) {
    (this.lastUpdateAt = 0),
      (this.settingsCacheTime = 3e3),
      (this.attemptedRegions = []),
      (this.serverUrl = new URL(U)),
      (this.token = F);
  }
  updateToken(U) {
    this.token = U;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error(
          "region availability is only supported for LiveKit Cloud domains"
        );
      (!this.regionSettings ||
        Date.now() - this.lastUpdateAt > this.settingsCacheTime) &&
        (this.regionSettings = yield this.fetchRegionSettings(U));
      const F = this.regionSettings.regions.filter(
        (q) => !this.attemptedRegions.find((j) => j.url === q.url)
      );
      if (F.length > 0) {
        const q = F[0];
        return (
          this.attemptedRegions.push(q),
          livekitLogger.debug("next region: ".concat(q.region)),
          q.url
        );
      } else return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  fetchRegionSettings(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = yield fetch(
        "".concat(getCloudConfigUrl(this.serverUrl), "/regions"),
        { headers: { authorization: "Bearer ".concat(this.token) }, signal: U }
      );
      if (F.ok) {
        const q = yield F.json();
        return (this.lastUpdateAt = Date.now()), q;
      } else throw new ConnectionError("Could not fetch region settings: ".concat(F.statusText), F.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, F.status);
    });
  }
  setServerReportedRegions(U) {
    (this.regionSettings = U), (this.lastUpdateAt = Date.now());
  }
}
function getCloudConfigUrl(B) {
  return ""
    .concat(B.protocol.replace("ws", "http"), "//")
    .concat(B.host, "/settings");
}
class BaseStreamReader {
  get info() {
    return this._info;
  }
  constructor(U, F, q) {
    (this.reader = F),
      (this.totalByteSize = q),
      (this._info = U),
      (this.bytesReceived = 0);
  }
}
class ByteStreamReader extends BaseStreamReader {
  handleChunkReceived(U) {
    var F;
    this.bytesReceived += U.content.byteLength;
    const q = this.totalByteSize
      ? this.bytesReceived / this.totalByteSize
      : void 0;
    (F = this.onProgress) === null || F === void 0 || F.call(this, q);
  }
  [Symbol.asyncIterator]() {
    const U = this.reader.getReader();
    return {
      next: () =>
        __awaiter$b(this, void 0, void 0, function* () {
          try {
            const { done: F, value: q } = yield U.read();
            return F
              ? { done: !0, value: void 0 }
              : (this.handleChunkReceived(q), { done: !1, value: q.content });
          } catch {
            return { done: !0, value: void 0 };
          }
        }),
      return() {
        return __awaiter$b(this, void 0, void 0, function* () {
          return U.releaseLock(), { done: !0, value: void 0 };
        });
      },
    };
  }
  readAll() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U, F, q, j;
      let V = new Set();
      try {
        for (
          var $ = !0, W = __asyncValues(this), K;
          (K = yield W.next()), (U = K.done), !U;
          $ = !0
        ) {
          (j = K.value), ($ = !1);
          const G = j;
          V.add(G);
        }
      } catch (G) {
        F = { error: G };
      } finally {
        try {
          !$ && !U && (q = W.return) && (yield q.call(W));
        } finally {
          if (F) throw F.error;
        }
      }
      return Array.from(V);
    });
  }
}
class TextStreamReader extends BaseStreamReader {
  constructor(U, F, q) {
    super(U, F, q), (this.receivedChunks = new Map());
  }
  handleChunkReceived(U) {
    var F;
    const q = bigIntToNumber(U.chunkIndex),
      j = this.receivedChunks.get(q);
    if (j && j.version > U.version) return;
    this.receivedChunks.set(q, U), (this.bytesReceived += U.content.byteLength);
    const V = this.totalByteSize
      ? this.bytesReceived / this.totalByteSize
      : void 0;
    (F = this.onProgress) === null || F === void 0 || F.call(this, V);
  }
  [Symbol.asyncIterator]() {
    const U = this.reader.getReader(),
      F = new TextDecoder();
    return {
      next: () =>
        __awaiter$b(this, void 0, void 0, function* () {
          try {
            const { done: q, value: j } = yield U.read();
            return q
              ? { done: !0, value: void 0 }
              : (this.handleChunkReceived(j),
                { done: !1, value: F.decode(j.content) });
          } catch {
            return { done: !0, value: void 0 };
          }
        }),
      return() {
        return __awaiter$b(this, void 0, void 0, function* () {
          return U.releaseLock(), { done: !0, value: void 0 };
        });
      },
    };
  }
  readAll() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U, F, q, j;
      let V = "";
      try {
        for (
          var $ = !0, W = __asyncValues(this), K;
          (K = yield W.next()), (U = K.done), !U;
          $ = !0
        )
          (j = K.value), ($ = !1), (V += j);
      } catch (G) {
        F = { error: G };
      } finally {
        try {
          !$ && !U && (q = W.return) && (yield q.call(W));
        } finally {
          if (F) throw F.error;
        }
      }
      return V;
    });
  }
}
class BaseStreamWriter {
  constructor(U, F, q) {
    (this.writableStream = U),
      (this.defaultWriter = U.getWriter()),
      (this.onClose = q),
      (this.info = F);
  }
  write(U) {
    return this.defaultWriter.write(U);
  }
  close() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      yield this.defaultWriter.close(),
        this.defaultWriter.releaseLock(),
        (U = this.onClose) === null || U === void 0 || U.call(this);
    });
  }
}
class TextStreamWriter extends BaseStreamWriter {}
class ByteStreamWriter extends BaseStreamWriter {}
class RemoteTrack extends Track {
  constructor(U, F, q, j, V) {
    super(U, q, V), (this.sid = F), (this.receiver = j);
  }
  get isLocal() {
    return !1;
  }
  setMuted(U) {
    this.isMuted !== U &&
      ((this.isMuted = U),
      (this._mediaStreamTrack.enabled = !U),
      this.emit(U ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  setMediaStream(U) {
    this.mediaStream = U;
    const F = (q) => {
      q.track === this._mediaStreamTrack &&
        (U.removeEventListener("removetrack", F),
        this.receiver &&
          "playoutDelayHint" in this.receiver &&
          (this.receiver.playoutDelayHint = void 0),
        (this.receiver = void 0),
        (this._currentBitrate = 0),
        this.emit(TrackEvent.Ended, this));
    };
    U.addEventListener("removetrack", F);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  getRTCStatsReport() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      return !((U = this.receiver) === null || U === void 0) && U.getStats
        ? yield this.receiver.getStats()
        : void 0;
    });
  }
  setPlayoutDelay(U) {
    this.receiver
      ? "playoutDelayHint" in this.receiver
        ? (this.receiver.playoutDelayHint = U)
        : this.log.warn("Playout delay not supported in this browser")
      : this.log.warn("Cannot set playout delay, track already ended");
  }
  getPlayoutDelay() {
    if (this.receiver) {
      if ("playoutDelayHint" in this.receiver)
        return this.receiver.playoutDelayHint;
      this.log.warn("Playout delay not supported in this browser");
    } else this.log.warn("Cannot get playout delay, track already ended");
    return 0;
  }
  startMonitor() {
    this.monitorInterval ||
      (this.monitorInterval = setInterval(
        () => this.monitorReceiver(),
        monitorFrequency
      )),
      supportsSynchronizationSources() && this.registerTimeSyncUpdate();
  }
  registerTimeSyncUpdate() {
    const U = () => {
      var F;
      this.timeSyncHandle = requestAnimationFrame(() => U());
      const q =
        (F = this.receiver) === null || F === void 0
          ? void 0
          : F.getSynchronizationSources()[0];
      if (q) {
        const { timestamp: j, rtpTimestamp: V } = q;
        V &&
          this.rtpTimestamp !== V &&
          (this.emit(TrackEvent.TimeSyncUpdate, {
            timestamp: j,
            rtpTimestamp: V,
          }),
          (this.rtpTimestamp = V));
      }
    };
    U();
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(U, F, q, j, V, $) {
    super(U, F, Track.Kind.Audio, q, $),
      (this.monitorReceiver = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.receiver) {
            this._currentBitrate = 0;
            return;
          }
          const W = yield this.getReceiverStats();
          W &&
            this.prevStats &&
            this.receiver &&
            (this._currentBitrate = computeBitrate(W, this.prevStats)),
            (this.prevStats = W);
        })),
      (this.audioContext = j),
      (this.webAudioPluginNodes = []),
      V && (this.sinkId = V.deviceId);
  }
  setVolume(U) {
    var F;
    for (const q of this.attachedElements)
      this.audioContext
        ? (F = this.gainNode) === null ||
          F === void 0 ||
          F.gain.setTargetAtTime(U, 0, 0.1)
        : (q.volume = U);
    isReactNative() && this._mediaStreamTrack._setVolume(U),
      (this.elementVolume = U);
  }
  getVolume() {
    if (this.elementVolume) return this.elementVolume;
    if (isReactNative()) return 1;
    let U = 0;
    return (
      this.attachedElements.forEach((F) => {
        F.volume > U && (U = F.volume);
      }),
      U
    );
  }
  setSinkId(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.sinkId = U),
        yield Promise.all(
          this.attachedElements.map((F) => {
            if (supportsSetSinkId(F)) return F.setSinkId(U);
          })
        );
    });
  }
  attach(U) {
    const F = this.attachedElements.length === 0;
    return (
      U ? super.attach(U) : (U = super.attach()),
      this.sinkId && supportsSetSinkId(U) && U.setSinkId(this.sinkId),
      this.audioContext &&
        F &&
        (this.log.debug("using audio context mapping", this.logContext),
        this.connectWebAudio(this.audioContext, U),
        (U.volume = 0),
        (U.muted = !0)),
      this.elementVolume && this.setVolume(this.elementVolume),
      U
    );
  }
  detach(U) {
    let F;
    return (
      U
        ? ((F = super.detach(U)),
          this.audioContext &&
            (this.attachedElements.length > 0
              ? this.connectWebAudio(
                  this.audioContext,
                  this.attachedElements[0]
                )
              : this.disconnectWebAudio()))
        : ((F = super.detach()), this.disconnectWebAudio()),
      F
    );
  }
  setAudioContext(U) {
    (this.audioContext = U),
      U && this.attachedElements.length > 0
        ? this.connectWebAudio(U, this.attachedElements[0])
        : U || this.disconnectWebAudio();
  }
  setWebAudioPlugins(U) {
    (this.webAudioPluginNodes = U),
      this.attachedElements.length > 0 &&
        this.audioContext &&
        this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(U, F) {
    this.disconnectWebAudio(),
      (this.sourceNode = U.createMediaStreamSource(F.srcObject));
    let q = this.sourceNode;
    this.webAudioPluginNodes.forEach((j) => {
      q.connect(j), (q = j);
    }),
      (this.gainNode = U.createGain()),
      q.connect(this.gainNode),
      this.gainNode.connect(U.destination),
      this.elementVolume &&
        this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1),
      U.state !== "running" &&
        U.resume()
          .then(() => {
            U.state !== "running" &&
              this.emit(
                TrackEvent.AudioPlaybackFailed,
                new Error("Audio Context couldn't be started automatically")
              );
          })
          .catch((j) => {
            this.emit(TrackEvent.AudioPlaybackFailed, j);
          });
  }
  disconnectWebAudio() {
    var U, F;
    (U = this.gainNode) === null || U === void 0 || U.disconnect(),
      (F = this.sourceNode) === null || F === void 0 || F.disconnect(),
      (this.gainNode = void 0),
      (this.sourceNode = void 0);
  }
  getReceiverStats() {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats) return;
      const U = yield this.receiver.getStats();
      let F;
      return (
        U.forEach((q) => {
          q.type === "inbound-rtp" &&
            (F = {
              type: "audio",
              streamId: q.id,
              timestamp: q.timestamp,
              jitter: q.jitter,
              bytesReceived: q.bytesReceived,
              concealedSamples: q.concealedSamples,
              concealmentEvents: q.concealmentEvents,
              silentConcealedSamples: q.silentConcealedSamples,
              silentConcealmentEvents: q.silentConcealmentEvents,
              totalAudioEnergy: q.totalAudioEnergy,
              totalSamplesDuration: q.totalSamplesDuration,
            });
        }),
        F
      );
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(U, F, q, j, V) {
    super(U, F, Track.Kind.Video, q, V),
      (this.elementInfos = []),
      (this.monitorReceiver = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (!this.receiver) {
            this._currentBitrate = 0;
            return;
          }
          const $ = yield this.getReceiverStats();
          $ &&
            this.prevStats &&
            this.receiver &&
            (this._currentBitrate = computeBitrate($, this.prevStats)),
            (this.prevStats = $);
        })),
      (this.debouncedHandleResize = r$1(() => {
        this.updateDimensions();
      }, REACTION_DELAY)),
      (this.adaptiveStreamSettings = j);
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  setMuted(U) {
    super.setMuted(U),
      this.attachedElements.forEach((F) => {
        U
          ? detachTrack(this._mediaStreamTrack, F)
          : attachToElement(this._mediaStreamTrack, F);
      });
  }
  attach(U) {
    if (
      (U ? super.attach(U) : (U = super.attach()),
      this.adaptiveStreamSettings &&
        this.elementInfos.find((F) => F.element === U) === void 0)
    ) {
      const F = new HTMLElementInfo(U);
      this.observeElementInfo(F);
    }
    return U;
  }
  observeElementInfo(U) {
    this.adaptiveStreamSettings &&
    this.elementInfos.find((F) => F === U) === void 0
      ? ((U.handleResize = () => {
          this.debouncedHandleResize();
        }),
        (U.handleVisibilityChanged = () => {
          this.updateVisibility();
        }),
        this.elementInfos.push(U),
        U.observe(),
        this.debouncedHandleResize(),
        this.updateVisibility())
      : this.log.warn(
          "visibility resize observer not triggered",
          this.logContext
        );
  }
  stopObservingElementInfo(U) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const F = this.elementInfos.filter((q) => q === U);
    for (const q of F) q.stopObserving();
    (this.elementInfos = this.elementInfos.filter((q) => q !== U)),
      this.updateVisibility(),
      this.debouncedHandleResize();
  }
  detach(U) {
    let F = [];
    if (U) return this.stopObservingElement(U), super.detach(U);
    F = super.detach();
    for (const q of F) this.stopObservingElement(q);
    return F;
  }
  getDecoderImplementation() {
    var U;
    return (U = this.prevStats) === null || U === void 0
      ? void 0
      : U.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats) return;
      const U = yield this.receiver.getStats();
      let F,
        q = "",
        j = new Map();
      return (
        U.forEach((V) => {
          V.type === "inbound-rtp"
            ? ((q = V.codecId),
              (F = {
                type: "video",
                streamId: V.id,
                framesDecoded: V.framesDecoded,
                framesDropped: V.framesDropped,
                framesReceived: V.framesReceived,
                packetsReceived: V.packetsReceived,
                packetsLost: V.packetsLost,
                frameWidth: V.frameWidth,
                frameHeight: V.frameHeight,
                pliCount: V.pliCount,
                firCount: V.firCount,
                nackCount: V.nackCount,
                jitter: V.jitter,
                timestamp: V.timestamp,
                bytesReceived: V.bytesReceived,
                decoderImplementation: V.decoderImplementation,
              }))
            : V.type === "codec" && j.set(V.id, V);
        }),
        F && q !== "" && j.get(q) && (F.mimeType = j.get(q).mimeType),
        F
      );
    });
  }
  stopObservingElement(U) {
    const F = this.elementInfos.filter((q) => q.element === U);
    for (const q of F) this.stopObservingElementInfo(q);
  }
  handleAppVisibilityChanged() {
    const U = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged,
      },
    });
    return __awaiter$b(this, void 0, void 0, function* () {
      yield U.handleAppVisibilityChanged.call(this),
        this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var U, F;
    const q = this.elementInfos.reduce(
        (W, K) => Math.max(W, K.visibilityChangedAt || 0),
        0
      ),
      j =
        !(
          (F =
            (U = this.adaptiveStreamSettings) === null || U === void 0
              ? void 0
              : U.pauseVideoInBackground) !== null && F !== void 0
        ) || F
          ? this.isInBackground
          : !1,
      V = this.elementInfos.some((W) => W.pictureInPicture),
      $ = (this.elementInfos.some((W) => W.visible) && !j) || V;
    if (this.lastVisible !== $) {
      if (!$ && Date.now() - q < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      (this.lastVisible = $), this.emit(TrackEvent.VisibilityChanged, $, this);
    }
  }
  updateDimensions() {
    var U, F;
    let q = 0,
      j = 0;
    const V = this.getPixelDensity();
    for (const $ of this.elementInfos) {
      const W = $.width() * V,
        K = $.height() * V;
      W + K > q + j && ((q = W), (j = K));
    }
    (((U = this.lastDimensions) === null || U === void 0 ? void 0 : U.width) ===
      q &&
      ((F = this.lastDimensions) === null || F === void 0
        ? void 0
        : F.height) === j) ||
      ((this.lastDimensions = { width: q, height: j }),
      this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var U;
    const F =
      (U = this.adaptiveStreamSettings) === null || U === void 0
        ? void 0
        : U.pixelDensity;
    return F === "screen"
      ? getDevicePixelRatio()
      : F || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(U, F) {
    (this.onVisibilityChanged = (q) => {
      var j;
      const { target: V, isIntersecting: $ } = q;
      V === this.element &&
        ((this.isIntersecting = $),
        (this.isPiP = isElementInPiP(this.element)),
        (this.visibilityChangedAt = Date.now()),
        (j = this.handleVisibilityChanged) === null ||
          j === void 0 ||
          j.call(this));
    }),
      (this.onEnterPiP = () => {
        var q, j, V;
        (j =
          (q = window.documentPictureInPicture) === null || q === void 0
            ? void 0
            : q.window) === null ||
          j === void 0 ||
          j.addEventListener("pagehide", this.onLeavePiP),
          (this.isPiP = isElementInPiP(this.element)),
          (V = this.handleVisibilityChanged) === null ||
            V === void 0 ||
            V.call(this);
      }),
      (this.onLeavePiP = () => {
        var q;
        (this.isPiP = isElementInPiP(this.element)),
          (q = this.handleVisibilityChanged) === null ||
            q === void 0 ||
            q.call(this);
      }),
      (this.element = U),
      (this.isIntersecting = F ?? isElementInViewport(U)),
      (this.isPiP = isWeb() && isElementInPiP(U)),
      (this.visibilityChangedAt = 0);
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    var U, F, q;
    (this.isIntersecting = isElementInViewport(this.element)),
      (this.isPiP = isElementInPiP(this.element)),
      (this.element.handleResize = () => {
        var j;
        (j = this.handleResize) === null || j === void 0 || j.call(this);
      }),
      (this.element.handleVisibilityChanged = this.onVisibilityChanged),
      getIntersectionObserver().observe(this.element),
      getResizeObserver().observe(this.element),
      this.element.addEventListener("enterpictureinpicture", this.onEnterPiP),
      this.element.addEventListener("leavepictureinpicture", this.onLeavePiP),
      (U = window.documentPictureInPicture) === null ||
        U === void 0 ||
        U.addEventListener("enter", this.onEnterPiP),
      (q =
        (F = window.documentPictureInPicture) === null || F === void 0
          ? void 0
          : F.window) === null ||
        q === void 0 ||
        q.addEventListener("pagehide", this.onLeavePiP);
  }
  stopObserving() {
    var U, F, q, j, V;
    (U = getIntersectionObserver()) === null ||
      U === void 0 ||
      U.unobserve(this.element),
      (F = getResizeObserver()) === null ||
        F === void 0 ||
        F.unobserve(this.element),
      this.element.removeEventListener(
        "enterpictureinpicture",
        this.onEnterPiP
      ),
      this.element.removeEventListener(
        "leavepictureinpicture",
        this.onLeavePiP
      ),
      (q = window.documentPictureInPicture) === null ||
        q === void 0 ||
        q.removeEventListener("enter", this.onEnterPiP),
      (V =
        (j = window.documentPictureInPicture) === null || j === void 0
          ? void 0
          : j.window) === null ||
        V === void 0 ||
        V.removeEventListener("pagehide", this.onLeavePiP);
  }
}
function isElementInPiP(B) {
  var U, F;
  return document.pictureInPictureElement === B
    ? !0
    : !((U = window.documentPictureInPicture) === null || U === void 0) &&
      U.window
    ? isElementInViewport(
        B,
        (F = window.documentPictureInPicture) === null || F === void 0
          ? void 0
          : F.window
      )
    : !1;
}
function isElementInViewport(B, U) {
  const F = U || window;
  let q = B.offsetTop,
    j = B.offsetLeft;
  const V = B.offsetWidth,
    $ = B.offsetHeight,
    { hidden: W } = B,
    { display: K } = getComputedStyle(B);
  for (; B.offsetParent; )
    (B = B.offsetParent), (q += B.offsetTop), (j += B.offsetLeft);
  return (
    q < F.pageYOffset + F.innerHeight &&
    j < F.pageXOffset + F.innerWidth &&
    q + $ > F.pageYOffset &&
    j + V > F.pageXOffset &&
    !W &&
    K !== "none"
  );
}
class TrackPublication extends eventsExports$1.EventEmitter {
  constructor(U, F, q, j) {
    var V;
    super(),
      (this.metadataMuted = !1),
      (this.encryption = Encryption_Type.NONE),
      (this.log = livekitLogger),
      (this.handleMuted = () => {
        this.emit(TrackEvent.Muted);
      }),
      (this.handleUnmuted = () => {
        this.emit(TrackEvent.Unmuted);
      }),
      (this.log = getLogger(
        (V = j == null ? void 0 : j.loggerName) !== null && V !== void 0
          ? V
          : LoggerNames.Publication
      )),
      (this.loggerContextCb = this.loggerContextCb),
      this.setMaxListeners(100),
      (this.kind = U),
      (this.trackSid = F),
      (this.trackName = q),
      (this.source = Track.Source.Unknown);
  }
  setTrack(U) {
    this.track &&
      (this.track.off(TrackEvent.Muted, this.handleMuted),
      this.track.off(TrackEvent.Unmuted, this.handleUnmuted)),
      (this.track = U),
      U &&
        (U.on(TrackEvent.Muted, this.handleMuted),
        U.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var U;
    return Object.assign(
      Object.assign(
        {},
        (U = this.loggerContextCb) === null || U === void 0
          ? void 0
          : U.call(this)
      ),
      getLogContextFromTrack(this)
    );
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  get audioTrack() {
    if (isAudioTrack(this.track)) return this.track;
  }
  get videoTrack() {
    if (isVideoTrack(this.track)) return this.track;
  }
  updateInfo(U) {
    (this.trackSid = U.sid),
      (this.trackName = U.name),
      (this.source = Track.sourceFromProto(U.source)),
      (this.mimeType = U.mimeType),
      this.kind === Track.Kind.Video &&
        U.width > 0 &&
        ((this.dimensions = { width: U.width, height: U.height }),
        (this.simulcasted = U.simulcast)),
      (this.encryption = U.encryption),
      (this.trackInfo = U),
      this.log.debug(
        "update publication info",
        Object.assign(Object.assign({}, this.logContext), { info: U })
      );
  }
}
(function (B) {
  (function (U) {
    (U.Desired = "desired"),
      (U.Subscribed = "subscribed"),
      (U.Unsubscribed = "unsubscribed");
  })(B.SubscriptionStatus || (B.SubscriptionStatus = {})),
    (function (U) {
      (U.Allowed = "allowed"), (U.NotAllowed = "not_allowed");
    })(B.PermissionStatus || (B.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var U;
    return (U = this.track) === null || U === void 0
      ? void 0
      : U.isUpstreamPaused;
  }
  constructor(U, F, q, j) {
    super(U, F.sid, F.name, j),
      (this.track = void 0),
      (this.handleTrackEnded = () => {
        this.emit(TrackEvent.Ended);
      }),
      this.updateInfo(F),
      this.setTrack(q);
  }
  setTrack(U) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded),
      super.setTrack(U),
      U && U.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  get isLocal() {
    return !0;
  }
  mute() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      return (U = this.track) === null || U === void 0 ? void 0 : U.mute();
    });
  }
  unmute() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      return (U = this.track) === null || U === void 0 ? void 0 : U.unmute();
    });
  }
  pauseUpstream() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      yield (U = this.track) === null || U === void 0
        ? void 0
        : U.pauseUpstream();
    });
  }
  resumeUpstream() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      yield (U = this.track) === null || U === void 0
        ? void 0
        : U.resumeUpstream();
    });
  }
  getTrackFeatures() {
    var U;
    if (isAudioTrack(this.track)) {
      const F = this.track.getSourceTrackSettings(),
        q = new Set();
      return (
        F.autoGainControl && q.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL),
        F.echoCancellation && q.add(AudioTrackFeature.TF_ECHO_CANCELLATION),
        F.noiseSuppression && q.add(AudioTrackFeature.TF_NOISE_SUPPRESSION),
        F.channelCount &&
          F.channelCount > 1 &&
          q.add(AudioTrackFeature.TF_STEREO),
        (!((U = this.options) === null || U === void 0) && U.dtx) ||
          q.add(AudioTrackFeature.TF_NO_DTX),
        this.track.enhancedNoiseCancellation &&
          q.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION),
        Array.from(q.values())
      );
    } else return [];
  }
}
function createLocalTracks(B, U) {
  return __awaiter$b(this, void 0, void 0, function* () {
    B ?? (B = {});
    let F = !1;
    const {
      audioProcessor: q,
      videoProcessor: j,
      optionsWithoutProcessor: V,
    } = extractProcessorsFromOptions(B);
    let $ = V.audio,
      W = V.video;
    if (
      (q && typeof V.audio == "object" && (V.audio.processor = q),
      j && typeof V.video == "object" && (V.video.processor = j),
      B.audio &&
        typeof V.audio == "object" &&
        typeof V.audio.deviceId == "string")
    ) {
      const Q = V.audio.deviceId;
      (V.audio.deviceId = { exact: Q }),
        (F = !0),
        ($ = Object.assign(Object.assign({}, V.audio), {
          deviceId: { ideal: Q },
        }));
    }
    if (
      V.video &&
      typeof V.video == "object" &&
      typeof V.video.deviceId == "string"
    ) {
      const Q = V.video.deviceId;
      (V.video.deviceId = { exact: Q }),
        (F = !0),
        (W = Object.assign(Object.assign({}, V.video), {
          deviceId: { ideal: Q },
        }));
    }
    (V.audio === !0 || (typeof V.audio == "object" && !V.audio.deviceId)) &&
      (V.audio = { deviceId: "default" }),
      (V.video === !0 || (typeof V.video == "object" && !V.video.deviceId)) &&
        (V.video = { deviceId: "default" });
    const K = mergeDefaultOptions(V, audioDefaults, videoDefaults),
      G = constraintsForOptions(K),
      H = navigator.mediaDevices.getUserMedia(G);
    V.audio &&
      (DeviceManager.userMediaPromiseMap.set("audioinput", H),
      H.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))),
      V.video &&
        (DeviceManager.userMediaPromiseMap.set("videoinput", H),
        H.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    try {
      const Q = yield H;
      return yield Promise.all(
        Q.getTracks().map((z) =>
          __awaiter$b(this, void 0, void 0, function* () {
            const Y = z.kind === "audio";
            let X = Y ? K.audio : K.video;
            (typeof X == "boolean" || !X) && (X = {});
            let Z;
            const se = Y ? G.audio : G.video;
            typeof se != "boolean" && (Z = se);
            const ee = z.getSettings().deviceId;
            Z != null && Z.deviceId && unwrapConstraint(Z.deviceId) !== ee
              ? (Z.deviceId = ee)
              : Z || (Z = { deviceId: ee });
            const ie = mediaTrackToLocalTrack(z, Z, U);
            return (
              ie.kind === Track.Kind.Video
                ? (ie.source = Track.Source.Camera)
                : ie.kind === Track.Kind.Audio &&
                  (ie.source = Track.Source.Microphone),
              (ie.mediaStream = Q),
              isAudioTrack(ie) && q
                ? yield ie.setProcessor(q)
                : isVideoTrack(ie) && j && (yield ie.setProcessor(j)),
              ie
            );
          })
        )
      );
    } catch (Q) {
      if (!F) throw Q;
      return createLocalTracks(
        Object.assign(Object.assign({}, B), { audio: $, video: W }),
        U
      );
    }
  });
}
function createLocalVideoTrack(B) {
  return __awaiter$b(this, void 0, void 0, function* () {
    return (yield createLocalTracks({ audio: !1, video: !0 }))[0];
  });
}
function createLocalAudioTrack(B) {
  return __awaiter$b(this, void 0, void 0, function* () {
    return (yield createLocalTracks({ audio: B ?? !0, video: !1 }))[0];
  });
}
var ConnectionQuality$2;
(function (B) {
  (B.Excellent = "excellent"),
    (B.Good = "good"),
    (B.Poor = "poor"),
    (B.Lost = "lost"),
    (B.Unknown = "unknown");
})(ConnectionQuality$2 || (ConnectionQuality$2 = {}));
function qualityFromProto(B) {
  switch (B) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality$2.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality$2.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality$2.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality$2.Lost;
    default:
      return ConnectionQuality$2.Unknown;
  }
}
class Participant extends eventsExports$1.EventEmitter {
  get logContext() {
    var U, F;
    return Object.assign(
      {},
      (F =
        (U = this.loggerOptions) === null || U === void 0
          ? void 0
          : U.loggerContextCb) === null || F === void 0
        ? void 0
        : F.call(U)
    );
  }
  get isEncrypted() {
    return (
      this.trackPublications.size > 0 &&
      Array.from(this.trackPublications.values()).every((U) => U.isEncrypted)
    );
  }
  get isAgent() {
    var U;
    return (
      ((U = this.permissions) === null || U === void 0 ? void 0 : U.agent) ||
      this.kind === ParticipantInfo_Kind.AGENT
    );
  }
  get kind() {
    return this._kind;
  }
  get attributes() {
    return Object.freeze(Object.assign({}, this._attributes));
  }
  constructor(U, F, q, j, V, $) {
    let W =
      arguments.length > 6 && arguments[6] !== void 0
        ? arguments[6]
        : ParticipantInfo_Kind.STANDARD;
    var K;
    super(),
      (this.audioLevel = 0),
      (this.isSpeaking = !1),
      (this._connectionQuality = ConnectionQuality$2.Unknown),
      (this.log = livekitLogger),
      (this.log = getLogger(
        (K = $ == null ? void 0 : $.loggerName) !== null && K !== void 0
          ? K
          : LoggerNames.Participant
      )),
      (this.loggerOptions = $),
      this.setMaxListeners(100),
      (this.sid = U),
      (this.identity = F),
      (this.name = q),
      (this.metadata = j),
      (this.audioTrackPublications = new Map()),
      (this.videoTrackPublications = new Map()),
      (this.trackPublications = new Map()),
      (this._kind = W),
      (this._attributes = V ?? {});
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  getTrackPublication(U) {
    for (const [, F] of this.trackPublications) if (F.source === U) return F;
  }
  getTrackPublicationByName(U) {
    for (const [, F] of this.trackPublications) if (F.trackName === U) return F;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var U;
    const F = this.getTrackPublication(Track.Source.Camera);
    return !(
      !((U = F == null ? void 0 : F.isMuted) !== null && U !== void 0) || U
    );
  }
  get isMicrophoneEnabled() {
    var U;
    const F = this.getTrackPublication(Track.Source.Microphone);
    return !(
      !((U = F == null ? void 0 : F.isMuted) !== null && U !== void 0) || U
    );
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  get joinedAt() {
    return this.participantInfo
      ? new Date(
          Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3
        )
      : new Date();
  }
  updateInfo(U) {
    return this.participantInfo &&
      this.participantInfo.sid === U.sid &&
      this.participantInfo.version > U.version
      ? !1
      : ((this.identity = U.identity),
        (this.sid = U.sid),
        this._setName(U.name),
        this._setMetadata(U.metadata),
        this._setAttributes(U.attributes),
        U.permission && this.setPermissions(U.permission),
        (this.participantInfo = U),
        this.log.trace(
          "update participant info",
          Object.assign(Object.assign({}, this.logContext), { info: U })
        ),
        !0);
  }
  _setMetadata(U) {
    const F = this.metadata !== U,
      q = this.metadata;
    (this.metadata = U),
      F && this.emit(ParticipantEvent.ParticipantMetadataChanged, q);
  }
  _setName(U) {
    const F = this.name !== U;
    (this.name = U), F && this.emit(ParticipantEvent.ParticipantNameChanged, U);
  }
  _setAttributes(U) {
    const F = diffAttributes(this.attributes, U);
    (this._attributes = U),
      Object.keys(F).length > 0 &&
        this.emit(ParticipantEvent.AttributesChanged, F);
  }
  setPermissions(U) {
    var F, q, j, V, $, W;
    const K = this.permissions,
      G =
        U.canPublish !==
          ((F = this.permissions) === null || F === void 0
            ? void 0
            : F.canPublish) ||
        U.canSubscribe !==
          ((q = this.permissions) === null || q === void 0
            ? void 0
            : q.canSubscribe) ||
        U.canPublishData !==
          ((j = this.permissions) === null || j === void 0
            ? void 0
            : j.canPublishData) ||
        U.hidden !==
          ((V = this.permissions) === null || V === void 0
            ? void 0
            : V.hidden) ||
        U.recorder !==
          (($ = this.permissions) === null || $ === void 0
            ? void 0
            : $.recorder) ||
        U.canPublishSources.length !==
          this.permissions.canPublishSources.length ||
        U.canPublishSources.some((H, Q) => {
          var z;
          return (
            H !==
            ((z = this.permissions) === null || z === void 0
              ? void 0
              : z.canPublishSources[Q])
          );
        }) ||
        U.canSubscribeMetrics !==
          ((W = this.permissions) === null || W === void 0
            ? void 0
            : W.canSubscribeMetrics);
    return (
      (this.permissions = U),
      G && this.emit(ParticipantEvent.ParticipantPermissionsChanged, K),
      G
    );
  }
  setIsSpeaking(U) {
    U !== this.isSpeaking &&
      ((this.isSpeaking = U),
      U && (this.lastSpokeAt = new Date()),
      this.emit(ParticipantEvent.IsSpeakingChanged, U));
  }
  setConnectionQuality(U) {
    const F = this._connectionQuality;
    (this._connectionQuality = qualityFromProto(U)),
      F !== this._connectionQuality &&
        this.emit(
          ParticipantEvent.ConnectionQualityChanged,
          this._connectionQuality
        );
  }
  setAudioContext(U) {
    (this.audioContext = U),
      this.audioTrackPublications.forEach(
        (F) => isAudioTrack(F.track) && F.track.setAudioContext(U)
      );
  }
  addTrackPublication(U) {
    U.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, U);
    }),
      U.on(TrackEvent.Unmuted, () => {
        this.emit(ParticipantEvent.TrackUnmuted, U);
      });
    const F = U;
    switch (
      (F.track && (F.track.sid = U.trackSid),
      this.trackPublications.set(U.trackSid, U),
      U.kind)
    ) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(U.trackSid, U);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(U.trackSid, U);
        break;
    }
  }
}
function trackPermissionToProto(B) {
  var U, F, q;
  if (!B.participantSid && !B.participantIdentity)
    throw new Error(
      "Invalid track permission, must provide at least one of participantIdentity and participantSid"
    );
  return new TrackPermission({
    participantIdentity:
      (U = B.participantIdentity) !== null && U !== void 0 ? U : "",
    participantSid: (F = B.participantSid) !== null && F !== void 0 ? F : "",
    allTracks: (q = B.allowAll) !== null && q !== void 0 ? q : !1,
    trackSids: B.allowedTrackSids || [],
  });
}
const STREAM_CHUNK_SIZE = 15e3;
class LocalParticipant extends Participant {
  constructor(U, F, q, j, V) {
    super(U, F, void 0, void 0, void 0, {
      loggerName: j.loggerName,
      loggerContextCb: () => this.engine.logContext,
    }),
      (this.pendingPublishing = new Set()),
      (this.pendingPublishPromises = new Map()),
      (this.participantTrackPermissions = []),
      (this.allParticipantsAllowedToSubscribe = !0),
      (this.encryptionType = Encryption_Type.NONE),
      (this.enabledPublishVideoCodecs = []),
      (this.pendingAcks = new Map()),
      (this.pendingResponses = new Map()),
      (this.handleReconnecting = () => {
        this.reconnectFuture || (this.reconnectFuture = new Future());
      }),
      (this.handleReconnected = () => {
        var $, W;
        (W =
          ($ = this.reconnectFuture) === null || $ === void 0
            ? void 0
            : $.resolve) === null ||
          W === void 0 ||
          W.call($),
          (this.reconnectFuture = void 0),
          this.updateTrackSubscriptionPermissions();
      }),
      (this.handleDisconnected = () => {
        var $, W;
        this.reconnectFuture &&
          (this.reconnectFuture.promise.catch((K) =>
            this.log.warn(K.message, this.logContext)
          ),
          (W =
            ($ = this.reconnectFuture) === null || $ === void 0
              ? void 0
              : $.reject) === null ||
            W === void 0 ||
            W.call($, "Got disconnected during reconnection attempt"),
          (this.reconnectFuture = void 0));
      }),
      (this.handleSignalRequestResponse = ($) => {
        const { requestId: W, reason: K, message: G } = $,
          H = this.pendingSignalRequests.get(W);
        H &&
          (K !== RequestResponse_Reason.OK &&
            H.reject(new SignalRequestError(G, K)),
          this.pendingSignalRequests.delete(W));
      }),
      (this.handleDataPacket = ($) => {
        switch ($.value.case) {
          case "rpcResponse":
            let W = $.value.value,
              K = null,
              G = null;
            W.value.case === "payload"
              ? (K = W.value.value)
              : W.value.case === "error" &&
                (G = RpcError.fromProto(W.value.value)),
              this.handleIncomingRpcResponse(W.requestId, K, G);
            break;
          case "rpcAck":
            let H = $.value.value;
            this.handleIncomingRpcAck(H.requestId);
            break;
        }
      }),
      (this.updateTrackSubscriptionPermissions = () => {
        this.log.debug(
          "updating track subscription permissions",
          Object.assign(Object.assign({}, this.logContext), {
            allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
            participantTrackPermissions: this.participantTrackPermissions,
          })
        ),
          this.engine.client.sendUpdateSubscriptionPermissions(
            this.allParticipantsAllowedToSubscribe,
            this.participantTrackPermissions.map(($) =>
              trackPermissionToProto($)
            )
          );
      }),
      (this.onTrackUnmuted = ($) => {
        this.onTrackMuted($, $.isUpstreamPaused);
      }),
      (this.onTrackMuted = ($, W) => {
        if ((W === void 0 && (W = !0), !$.sid)) {
          this.log.error(
            "could not update mute status for unpublished track",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack($)
            )
          );
          return;
        }
        this.engine.updateMuteStatus($.sid, W);
      }),
      (this.onTrackUpstreamPaused = ($) => {
        this.log.debug(
          "upstream paused",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack($)
          )
        ),
          this.onTrackMuted($, !0);
      }),
      (this.onTrackUpstreamResumed = ($) => {
        this.log.debug(
          "upstream resumed",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack($)
          )
        ),
          this.onTrackMuted($, $.isMuted);
      }),
      (this.onTrackFeatureUpdate = ($) => {
        const W = this.audioTrackPublications.get($.sid);
        if (!W) {
          this.log.warn(
            "Could not update local audio track settings, missing publication for track ".concat(
              $.sid
            ),
            this.logContext
          );
          return;
        }
        this.engine.client.sendUpdateLocalAudioTrack(
          W.trackSid,
          W.getTrackFeatures()
        );
      }),
      (this.handleSubscribedQualityUpdate = ($) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var W, K, G, H, Q, z;
          if (
            !(!((Q = this.roomOptions) === null || Q === void 0) && Q.dynacast)
          )
            return;
          const Y = this.videoTrackPublications.get($.trackSid);
          if (!Y) {
            this.log.warn(
              "received subscribed quality update for unknown track",
              Object.assign(Object.assign({}, this.logContext), {
                trackSid: $.trackSid,
              })
            );
            return;
          }
          if ($.subscribedCodecs.length > 0) {
            if (!Y.videoTrack) return;
            const ee = yield Y.videoTrack.setPublishingCodecs(
              $.subscribedCodecs
            );
            try {
              for (
                var X = !0, Z = __asyncValues(ee), se;
                (se = yield Z.next()), (W = se.done), !W;
                X = !0
              ) {
                (H = se.value), (X = !1);
                const ie = H;
                isBackupCodec(ie) &&
                  (this.log.debug(
                    "publish ".concat(ie, " for ").concat(Y.videoTrack.sid),
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(Y)
                    )
                  ),
                  yield this.publishAdditionalCodecForTrack(
                    Y.videoTrack,
                    ie,
                    Y.options
                  ));
              }
            } catch (ie) {
              K = { error: ie };
            } finally {
              try {
                !X && !W && (G = Z.return) && (yield G.call(Z));
              } finally {
                if (K) throw K.error;
              }
            }
          } else $.subscribedQualities.length > 0 && (yield (z = Y.videoTrack) === null || z === void 0 ? void 0 : z.setPublishingLayers($.subscribedQualities));
        })),
      (this.handleLocalTrackUnpublished = ($) => {
        const W = this.trackPublications.get($.trackSid);
        if (!W) {
          this.log.warn(
            "received unpublished event for unknown track",
            Object.assign(Object.assign({}, this.logContext), {
              trackSid: $.trackSid,
            })
          );
          return;
        }
        this.unpublishTrack(W.track);
      }),
      (this.handleTrackEnded = ($) =>
        __awaiter$b(this, void 0, void 0, function* () {
          if (
            $.source === Track.Source.ScreenShare ||
            $.source === Track.Source.ScreenShareAudio
          )
            this.log.debug(
              "unpublishing local track due to TrackEnded",
              Object.assign(
                Object.assign({}, this.logContext),
                getLogContextFromTrack($)
              )
            ),
              this.unpublishTrack($);
          else if ($.isUserProvided) yield $.mute();
          else if (isLocalAudioTrack($) || isLocalVideoTrack($))
            try {
              if (isWeb())
                try {
                  const W = yield navigator == null
                    ? void 0
                    : navigator.permissions.query({
                        name:
                          $.source === Track.Source.Camera
                            ? "camera"
                            : "microphone",
                      });
                  if (W && W.state === "denied")
                    throw (
                      (this.log.warn(
                        "user has revoked access to ".concat($.source),
                        Object.assign(
                          Object.assign({}, this.logContext),
                          getLogContextFromTrack($)
                        )
                      ),
                      (W.onchange = () => {
                        W.state !== "denied" &&
                          ($.isMuted || $.restartTrack(), (W.onchange = null));
                      }),
                      new Error("GetUserMedia Permission denied"))
                    );
                } catch {}
              $.isMuted ||
                (this.log.debug(
                  "track ended, attempting to use a different device",
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack($)
                  )
                ),
                isLocalAudioTrack($)
                  ? yield $.restartTrack({ deviceId: "default" })
                  : yield $.restartTrack());
            } catch {
              this.log.warn(
                "could not restart track, muting instead",
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack($)
                )
              ),
                yield $.mute();
            }
        })),
      (this.audioTrackPublications = new Map()),
      (this.videoTrackPublications = new Map()),
      (this.trackPublications = new Map()),
      (this.engine = q),
      (this.roomOptions = j),
      this.setupEngine(q),
      (this.activeDeviceMap = new Map([
        ["audioinput", "default"],
        ["videoinput", "default"],
        ["audiooutput", "default"],
      ])),
      (this.pendingSignalRequests = new Map()),
      (this.rpcHandlers = V);
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(U) {
    const F = super.getTrackPublication(U);
    if (F) return F;
  }
  getTrackPublicationByName(U) {
    const F = super.getTrackPublicationByName(U);
    if (F) return F;
  }
  setupEngine(U) {
    (this.engine = U),
      this.engine.on(EngineEvent.RemoteMute, (F, q) => {
        const j = this.trackPublications.get(F);
        !j || !j.track || (q ? j.mute() : j.unmute());
      }),
      this.engine
        .on(EngineEvent.Connected, this.handleReconnected)
        .on(EngineEvent.SignalRestarted, this.handleReconnected)
        .on(EngineEvent.SignalResumed, this.handleReconnected)
        .on(EngineEvent.Restarting, this.handleReconnecting)
        .on(EngineEvent.Resuming, this.handleReconnecting)
        .on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished)
        .on(
          EngineEvent.SubscribedQualityUpdate,
          this.handleSubscribedQualityUpdate
        )
        .on(EngineEvent.Disconnected, this.handleDisconnected)
        .on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse)
        .on(EngineEvent.DataPacketReceived, this.handleDataPacket);
  }
  setMetadata(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({ metadata: U });
    });
  }
  setName(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({ name: U });
    });
  }
  setAttributes(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.requestMetadataUpdate({ attributes: U });
    });
  }
  requestMetadataUpdate(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let { metadata: j, name: V, attributes: $ } = F;
      return (function* () {
        return new Promise((W, K) =>
          __awaiter$b(q, void 0, void 0, function* () {
            var G, H;
            try {
              let Q = !1;
              const z = yield this.engine.client.sendUpdateLocalMetadata(
                  (G = j ?? this.metadata) !== null && G !== void 0 ? G : "",
                  (H = V ?? this.name) !== null && H !== void 0 ? H : "",
                  $
                ),
                Y = performance.now();
              for (
                this.pendingSignalRequests.set(z, {
                  resolve: W,
                  reject: (X) => {
                    K(X), (Q = !0);
                  },
                  values: { name: V, metadata: j, attributes: $ },
                });
                performance.now() - Y < 5e3 && !Q;

              ) {
                if (
                  (!V || this.name === V) &&
                  (!j || this.metadata === j) &&
                  (!$ ||
                    Object.entries($).every((X) => {
                      let [Z, se] = X;
                      return (
                        this.attributes[Z] === se ||
                        (se === "" && !this.attributes[Z])
                      );
                    }))
                ) {
                  this.pendingSignalRequests.delete(z), W();
                  return;
                }
                yield sleep$1(50);
              }
              K(
                new SignalRequestError(
                  "Request to update local metadata timed out",
                  "TimeoutError"
                )
              );
            } catch (Q) {
              Q instanceof Error && K(Q);
            }
          })
        );
      })();
    });
  }
  setCameraEnabled(U, F, q) {
    return this.setTrackEnabled(Track.Source.Camera, U, F, q);
  }
  setMicrophoneEnabled(U, F, q) {
    return this.setTrackEnabled(Track.Source.Microphone, U, F, q);
  }
  setScreenShareEnabled(U, F, q) {
    return this.setTrackEnabled(Track.Source.ScreenShare, U, F, q);
  }
  setPermissions(U) {
    const F = this.permissions,
      q = super.setPermissions(U);
    return (
      q && F && this.emit(ParticipantEvent.ParticipantPermissionsChanged, F), q
    );
  }
  setE2EEEnabled(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      (this.encryptionType = U ? Encryption_Type.GCM : Encryption_Type.NONE),
        yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(U, F, q, j) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var V, $;
      this.log.debug(
        "setTrackEnabled",
        Object.assign(Object.assign({}, this.logContext), {
          source: U,
          enabled: F,
        })
      ),
        this.republishPromise && (yield this.republishPromise);
      let W = this.getTrackPublication(U);
      if (F)
        if (W) yield W.unmute();
        else {
          let K;
          if (this.pendingPublishing.has(U)) {
            const G = yield this.waitForPendingPublicationOfSource(U);
            return (
              G ||
                this.log.info(
                  "waiting for pending publication promise timed out",
                  Object.assign(Object.assign({}, this.logContext), {
                    source: U,
                  })
                ),
              yield G == null ? void 0 : G.unmute(),
              G
            );
          }
          this.pendingPublishing.add(U);
          try {
            switch (U) {
              case Track.Source.Camera:
                K = yield this.createTracks({
                  video: (V = q) !== null && V !== void 0 ? V : !0,
                });
                break;
              case Track.Source.Microphone:
                K = yield this.createTracks({
                  audio: ($ = q) !== null && $ !== void 0 ? $ : !0,
                });
                break;
              case Track.Source.ScreenShare:
                K = yield this.createScreenTracks(Object.assign({}, q));
                break;
              default:
                throw new TrackInvalidError(U);
            }
          } catch (G) {
            throw (
              (K == null ||
                K.forEach((H) => {
                  H.stop();
                }),
              G instanceof Error &&
                this.emit(ParticipantEvent.MediaDevicesError, G),
              this.pendingPublishing.delete(U),
              G)
            );
          }
          try {
            const G = [];
            for (const Q of K)
              this.log.info(
                "publishing track",
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack(Q)
                )
              ),
                G.push(this.publishTrack(Q, j));
            [W] = yield Promise.all(G);
          } catch (G) {
            throw (
              (K == null ||
                K.forEach((H) => {
                  H.stop();
                }),
              G)
            );
          } finally {
            this.pendingPublishing.delete(U);
          }
        }
      else if (
        (!(W != null && W.track) &&
          this.pendingPublishing.has(U) &&
          ((W = yield this.waitForPendingPublicationOfSource(U)),
          W ||
            this.log.info(
              "waiting for pending publication promise timed out",
              Object.assign(Object.assign({}, this.logContext), { source: U })
            )),
        W && W.track)
      )
        if (U === Track.Source.ScreenShare) {
          W = yield this.unpublishTrack(W.track);
          const K = this.getTrackPublication(Track.Source.ScreenShareAudio);
          K && K.track && this.unpublishTrack(K.track);
        } else yield W.mute();
      return W;
    });
  }
  enableCameraAndMicrophone() {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (
        !(
          this.pendingPublishing.has(Track.Source.Camera) ||
          this.pendingPublishing.has(Track.Source.Microphone)
        )
      ) {
        this.pendingPublishing.add(Track.Source.Camera),
          this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const U = yield this.createTracks({ audio: !0, video: !0 });
          yield Promise.all(U.map((F) => this.publishTrack(F)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera),
            this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  createTracks(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q;
      U ?? (U = {});
      const j = mergeDefaultOptions(
        U,
        (F = this.roomOptions) === null || F === void 0
          ? void 0
          : F.audioCaptureDefaults,
        (q = this.roomOptions) === null || q === void 0
          ? void 0
          : q.videoCaptureDefaults
      );
      try {
        return (yield createLocalTracks(j, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext,
        })).map(
          (W) => (
            isAudioTrack(W) &&
              ((this.microphoneError = void 0),
              W.setAudioContext(this.audioContext),
              (W.source = Track.Source.Microphone),
              this.emit(ParticipantEvent.AudioStreamAcquired)),
            isVideoTrack(W) &&
              ((this.cameraError = void 0), (W.source = Track.Source.Camera)),
            W
          )
        );
      } catch (V) {
        throw (
          (V instanceof Error &&
            (U.audio && (this.microphoneError = V),
            U.video && (this.cameraError = V)),
          V)
        );
      }
    });
  }
  createScreenTracks(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (
        (U === void 0 && (U = {}),
        navigator.mediaDevices.getDisplayMedia === void 0)
      )
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      U.resolution === void 0 &&
        !isSafari17() &&
        (U.resolution = ScreenSharePresets.h1080fps30.resolution);
      const F = screenCaptureToDisplayMediaStreamOptions(U),
        q = yield navigator.mediaDevices.getDisplayMedia(F),
        j = q.getVideoTracks();
      if (j.length === 0) throw new TrackInvalidError("no video track found");
      const V = new LocalVideoTrack(j[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext,
      });
      (V.source = Track.Source.ScreenShare),
        U.contentHint && (V.mediaStreamTrack.contentHint = U.contentHint);
      const $ = [V];
      if (q.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const W = new LocalAudioTrack(
          q.getAudioTracks()[0],
          void 0,
          !1,
          this.audioContext,
          {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext,
          }
        );
        (W.source = Track.Source.ScreenShareAudio), $.push(W);
      }
      return $;
    });
  }
  publishTrack(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.publishOrRepublishTrack(U, F);
    });
  }
  publishOrRepublishTrack(U, F) {
    return __awaiter$b(this, arguments, void 0, function (q, j) {
      var V = this;
      let $ =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return (function* () {
        var W, K, G, H;
        isLocalAudioTrack(q) && q.setAudioContext(V.audioContext),
          yield (W = V.reconnectFuture) === null || W === void 0
            ? void 0
            : W.promise,
          V.republishPromise && !$ && (yield V.republishPromise),
          isLocalTrack(q) &&
            V.pendingPublishPromises.has(q) &&
            (yield V.pendingPublishPromises.get(q));
        let Q;
        if (q instanceof MediaStreamTrack) Q = q.getConstraints();
        else {
          Q = q.constraints;
          let ee;
          switch (q.source) {
            case Track.Source.Microphone:
              ee = "audioinput";
              break;
            case Track.Source.Camera:
              ee = "videoinput";
          }
          ee &&
            V.activeDeviceMap.has(ee) &&
            (Q = Object.assign(Object.assign({}, Q), {
              deviceId: V.activeDeviceMap.get(ee),
            }));
        }
        if (q instanceof MediaStreamTrack)
          switch (q.kind) {
            case "audio":
              q = new LocalAudioTrack(q, Q, !0, V.audioContext, {
                loggerName: V.roomOptions.loggerName,
                loggerContextCb: () => V.logContext,
              });
              break;
            case "video":
              q = new LocalVideoTrack(q, Q, !0, {
                loggerName: V.roomOptions.loggerName,
                loggerContextCb: () => V.logContext,
              });
              break;
            default:
              throw new TrackInvalidError(
                "unsupported MediaStreamTrack kind ".concat(q.kind)
              );
          }
        else
          q.updateLoggerOptions({
            loggerName: V.roomOptions.loggerName,
            loggerContextCb: () => V.logContext,
          });
        let z;
        if (
          (V.trackPublications.forEach((ee) => {
            ee.track && ee.track === q && (z = ee);
          }),
          z)
        )
          return (
            V.log.warn(
              "track has already been published, skipping",
              Object.assign(
                Object.assign({}, V.logContext),
                getLogContextFromTrack(z)
              )
            ),
            z
          );
        const Y =
            ("channelCount" in q.mediaStreamTrack.getSettings() &&
              q.mediaStreamTrack.getSettings().channelCount === 2) ||
            q.mediaStreamTrack.getConstraints().channelCount === 2,
          X =
            (K = j == null ? void 0 : j.forceStereo) !== null && K !== void 0
              ? K
              : Y;
        X &&
          (j || (j = {}),
          j.dtx === void 0 &&
            V.log.info(
              "Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.",
              Object.assign(
                Object.assign({}, V.logContext),
                getLogContextFromTrack(q)
              )
            ),
          j.red === void 0 &&
            V.log.info(
              "Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."
            ),
          ((G = j.dtx) !== null && G !== void 0) || (j.dtx = !1),
          ((H = j.red) !== null && H !== void 0) || (j.red = !1));
        const Z = Object.assign(
          Object.assign({}, V.roomOptions.publishDefaults),
          j
        );
        !isE2EESimulcastSupported() &&
          V.roomOptions.e2ee &&
          (V.log.info(
            "End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2",
            Object.assign({}, V.logContext)
          ),
          (Z.simulcast = !1)),
          Z.source && (q.source = Z.source);
        const se = new Promise((ee, ie) =>
          __awaiter$b(V, void 0, void 0, function* () {
            try {
              if (
                this.engine.client.currentState !==
                SignalConnectionState.CONNECTED
              ) {
                this.log.debug(
                  "deferring track publication until signal is connected",
                  Object.assign(Object.assign({}, this.logContext), {
                    track: getLogContextFromTrack(q),
                  })
                );
                const re = () =>
                  __awaiter$b(this, void 0, void 0, function* () {
                    try {
                      const te = yield this.publish(q, Z, X);
                      ee(te);
                    } catch (te) {
                      ie(te);
                    }
                  });
                setTimeout(() => {
                  this.engine.off(EngineEvent.SignalConnected, re),
                    ie(
                      new PublishTrackError(
                        "publishing rejected as engine not connected within timeout",
                        408
                      )
                    );
                }, 15e3),
                  this.engine.once(EngineEvent.SignalConnected, re),
                  this.engine.on(EngineEvent.Closing, () => {
                    this.engine.off(EngineEvent.SignalConnected, re),
                      ie(
                        new PublishTrackError(
                          "publishing rejected as engine closed",
                          499
                        )
                      );
                  });
              } else
                try {
                  const re = yield this.publish(q, Z, X);
                  ee(re);
                } catch (re) {
                  ie(re);
                }
            } catch (re) {
              ie(re);
            }
          })
        );
        V.pendingPublishPromises.set(q, se);
        try {
          return yield se;
        } catch (ee) {
          throw ee;
        } finally {
          V.pendingPublishPromises.delete(q);
        }
      })();
    });
  }
  hasPermissionsToPublish(U) {
    if (!this.permissions)
      return (
        this.log.warn(
          "no permissions present for publishing track",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(U)
          )
        ),
        !1
      );
    const { canPublish: F, canPublishSources: q } = this.permissions;
    return F &&
      (q.length === 0 ||
        q.map((j) => getTrackSourceFromProto(j)).includes(U.source))
      ? !0
      : (this.log.warn(
          "insufficient permissions to publish",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(U)
          )
        ),
        !1);
  }
  publish(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var j, V, $, W, K, G, H, Q, z, Y;
      if (!this.hasPermissionsToPublish(U))
        throw new PublishTrackError(
          "failed to publish track, insufficient permissions",
          403
        );
      Array.from(this.trackPublications.values()).find(
        (ne) => isLocalTrack(U) && ne.source === U.source
      ) &&
        U.source !== Track.Source.Unknown &&
        this.log.info(
          "publishing a second track with the same source: ".concat(U.source),
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(U)
          )
        ),
        F.stopMicTrackOnMute && isAudioTrack(U) && (U.stopOnMute = !0),
        U.source === Track.Source.ScreenShare &&
          isFireFox() &&
          (F.simulcast = !1),
        F.videoCodec === "av1" && !supportsAV1() && (F.videoCodec = void 0),
        F.videoCodec === "vp9" && !supportsVP9() && (F.videoCodec = void 0),
        F.videoCodec === void 0 && (F.videoCodec = defaultVideoCodec),
        this.enabledPublishVideoCodecs.length > 0 &&
          (this.enabledPublishVideoCodecs.some(
            (ne) => F.videoCodec === mimeTypeToVideoCodecString(ne.mime)
          ) ||
            (F.videoCodec = mimeTypeToVideoCodecString(
              this.enabledPublishVideoCodecs[0].mime
            )));
      const Z = F.videoCodec;
      U.on(TrackEvent.Muted, this.onTrackMuted),
        U.on(TrackEvent.Unmuted, this.onTrackUnmuted),
        U.on(TrackEvent.Ended, this.handleTrackEnded),
        U.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused),
        U.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed),
        U.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
      const se = new AddTrackRequest({
        cid: U.mediaStreamTrack.id,
        name: F.name,
        type: Track.kindToProto(U.kind),
        muted: U.isMuted,
        source: Track.sourceToProto(U.source),
        disableDtx: !(!((j = F.dtx) !== null && j !== void 0) || j),
        encryption: this.encryptionType,
        stereo: q,
        disableRed:
          this.isE2EEEnabled || !(!((V = F.red) !== null && V !== void 0) || V),
        stream: F == null ? void 0 : F.stream,
        backupCodecPolicy: F == null ? void 0 : F.backupCodecPolicy,
      });
      let ee;
      if (U.kind === Track.Kind.Video) {
        let ne = { width: 0, height: 0 };
        try {
          ne = yield U.waitForDimensions();
        } catch {
          const ce =
            (W =
              ($ = this.roomOptions.videoCaptureDefaults) === null ||
              $ === void 0
                ? void 0
                : $.resolution) !== null && W !== void 0
              ? W
              : VideoPresets.h720.resolution;
          (ne = { width: ce.width, height: ce.height }),
            this.log.error(
              "could not determine track dimensions, using defaults",
              Object.assign(
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack(U)
                ),
                { dims: ne }
              )
            );
        }
        (se.width = ne.width),
          (se.height = ne.height),
          isLocalVideoTrack(U) &&
            (isSVCCodec(Z) &&
              (U.source === Track.Source.ScreenShare &&
                ((F.scalabilityMode = "L1T3"),
                "contentHint" in U.mediaStreamTrack &&
                  ((U.mediaStreamTrack.contentHint = "motion"),
                  this.log.info(
                    "forcing contentHint to motion for screenshare with SVC codecs",
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(U)
                    )
                  ))),
              (F.scalabilityMode =
                (K = F.scalabilityMode) !== null && K !== void 0
                  ? K
                  : "L3T3_KEY")),
            (se.simulcastCodecs = [
              new SimulcastCodec({ codec: Z, cid: U.mediaStreamTrack.id }),
            ]),
            F.backupCodec === !0 &&
              (F.backupCodec = { codec: defaultVideoCodec }),
            F.backupCodec &&
              Z !== F.backupCodec.codec &&
              se.encryption === Encryption_Type.NONE &&
              (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0),
              se.simulcastCodecs.push(
                new SimulcastCodec({ codec: F.backupCodec.codec, cid: "" })
              ))),
          (ee = computeVideoEncodings(
            U.source === Track.Source.ScreenShare,
            se.width,
            se.height,
            F
          )),
          (se.layers = videoLayersFromEncodings(
            se.width,
            se.height,
            ee,
            isSVCCodec(F.videoCodec)
          ));
      } else U.kind === Track.Kind.Audio && (ee = [{ maxBitrate: (G = F.audioPreset) === null || G === void 0 ? void 0 : G.maxBitrate, priority: (Q = (H = F.audioPreset) === null || H === void 0 ? void 0 : H.priority) !== null && Q !== void 0 ? Q : "high", networkPriority: (Y = (z = F.audioPreset) === null || z === void 0 ? void 0 : z.priority) !== null && Y !== void 0 ? Y : "high" }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState(
          "cannot publish track when not connected"
        );
      const ie = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          var ne, oe, ce;
          if (!this.engine.pcManager)
            throw new UnexpectedConnectionState("pcManager is not ready");
          if (
            ((U.sender = yield this.engine.createSender(U, F, ee)),
            isLocalVideoTrack(U) &&
              (((ne = F.degradationPreference) !== null && ne !== void 0) ||
                (F.degradationPreference = getDefaultDegradationPreference(U)),
              U.setDegradationPreference(F.degradationPreference)),
            ee)
          )
            if (isFireFox() && U.kind === Track.Kind.Audio) {
              let le;
              for (const he of this.engine.pcManager.publisher.getTransceivers())
                if (he.sender === U.sender) {
                  le = he;
                  break;
                }
              le &&
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  transceiver: le,
                  codec: "opus",
                  maxbr:
                    !((oe = ee[0]) === null || oe === void 0) && oe.maxBitrate
                      ? ee[0].maxBitrate / 1e3
                      : 0,
                });
            } else
              U.codec &&
                isSVCCodec(U.codec) &&
                !((ce = ee[0]) === null || ce === void 0) &&
                ce.maxBitrate &&
                this.engine.pcManager.publisher.setTrackCodecBitrate({
                  cid: se.cid,
                  codec: U.codec,
                  maxbr: ee[0].maxBitrate / 1e3,
                });
          yield this.engine.negotiate();
        });
      let re;
      if (this.enabledPublishVideoCodecs.length > 0)
        re = (yield Promise.all([this.engine.addTrack(se), ie()]))[0];
      else {
        re = yield this.engine.addTrack(se);
        let ne;
        if (
          (re.codecs.forEach((oe) => {
            ne === void 0 && (ne = oe.mimeType);
          }),
          ne && U.kind === Track.Kind.Video)
        ) {
          const oe = mimeTypeToVideoCodecString(ne);
          oe !== Z &&
            (this.log.debug(
              "falling back to server selected codec",
              Object.assign(
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack(U)
                ),
                { codec: oe }
              )
            ),
            (F.videoCodec = oe),
            (ee = computeVideoEncodings(
              U.source === Track.Source.ScreenShare,
              se.width,
              se.height,
              F
            )));
        }
        yield ie();
      }
      const te = new LocalTrackPublication(U.kind, re, U, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext,
      });
      return (
        (te.options = F),
        (U.sid = re.sid),
        this.log.debug(
          "publishing ".concat(U.kind, " with encodings"),
          Object.assign(Object.assign({}, this.logContext), {
            encodings: ee,
            trackInfo: re,
          })
        ),
        isLocalVideoTrack(U)
          ? U.startMonitor(this.engine.client)
          : isLocalAudioTrack(U) && U.startMonitor(),
        this.addTrackPublication(te),
        this.emit(ParticipantEvent.LocalTrackPublished, te),
        te
      );
    });
  }
  get isLocal() {
    return !0;
  }
  publishAdditionalCodecForTrack(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var j;
      if (this.encryptionType !== Encryption_Type.NONE) return;
      let V;
      if (
        (this.trackPublications.forEach((Y) => {
          Y.track && Y.track === U && (V = Y);
        }),
        !V)
      )
        throw new TrackInvalidError("track is not published");
      if (!isLocalVideoTrack(U))
        throw new TrackInvalidError("track is not a video track");
      const $ = Object.assign(
          Object.assign(
            {},
            (j = this.roomOptions) === null || j === void 0
              ? void 0
              : j.publishDefaults
          ),
          q
        ),
        W = computeTrackBackupEncodings(U, F, $);
      if (!W) {
        this.log.info(
          "backup codec has been disabled, ignoring request to add additional codec for track",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(U)
          )
        );
        return;
      }
      const K = U.addSimulcastTrack(F, W);
      if (!K) return;
      const G = new AddTrackRequest({
        cid: K.mediaStreamTrack.id,
        type: Track.kindToProto(U.kind),
        muted: U.isMuted,
        source: Track.sourceToProto(U.source),
        sid: U.sid,
        simulcastCodecs: [{ codec: $.videoCodec, cid: K.mediaStreamTrack.id }],
      });
      if (
        ((G.layers = videoLayersFromEncodings(G.width, G.height, W)),
        !this.engine || this.engine.isClosed)
      )
        throw new UnexpectedConnectionState(
          "cannot publish track when not connected"
        );
      const H = () =>
          __awaiter$b(this, void 0, void 0, function* () {
            yield this.engine.createSimulcastSender(U, K, $, W),
              yield this.engine.negotiate();
          }),
        z = (yield Promise.all([this.engine.addTrack(G), H()]))[0];
      this.log.debug(
        "published ".concat(F, " for track ").concat(U.sid),
        Object.assign(Object.assign({}, this.logContext), {
          encodings: W,
          trackInfo: z,
        })
      );
    });
  }
  unpublishTrack(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var q, j;
      if (isLocalTrack(U)) {
        const G = this.pendingPublishPromises.get(U);
        G &&
          (this.log.info(
            "awaiting publish promise before attempting to unpublish",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(U)
            )
          ),
          yield G);
      }
      const V = this.getPublicationForTrack(U),
        $ = V ? getLogContextFromTrack(V) : void 0;
      if (
        (this.log.debug(
          "unpublishing track",
          Object.assign(Object.assign({}, this.logContext), $)
        ),
        !V || !V.track)
      ) {
        this.log.warn(
          "track was not unpublished because no publication was found",
          Object.assign(Object.assign({}, this.logContext), $)
        );
        return;
      }
      (U = V.track),
        U.off(TrackEvent.Muted, this.onTrackMuted),
        U.off(TrackEvent.Unmuted, this.onTrackUnmuted),
        U.off(TrackEvent.Ended, this.handleTrackEnded),
        U.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused),
        U.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed),
        U.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate),
        F === void 0 &&
          (F =
            (j =
              (q = this.roomOptions) === null || q === void 0
                ? void 0
                : q.stopLocalTrackOnUnpublish) !== null && j !== void 0
              ? j
              : !0),
        F ? U.stop() : U.stopMonitor();
      let W = !1;
      const K = U.sender;
      if (
        ((U.sender = void 0),
        this.engine.pcManager &&
          this.engine.pcManager.currentState < PCTransportState.FAILED &&
          K)
      )
        try {
          for (const G of this.engine.pcManager.publisher.getTransceivers())
            G.sender === K && ((G.direction = "inactive"), (W = !0));
          if ((this.engine.removeTrack(K) && (W = !0), isLocalVideoTrack(U))) {
            for (const [, G] of U.simulcastCodecs)
              G.sender &&
                (this.engine.removeTrack(G.sender) && (W = !0),
                (G.sender = void 0));
            U.simulcastCodecs.clear();
          }
        } catch (G) {
          this.log.warn(
            "failed to unpublish track",
            Object.assign(
              Object.assign(Object.assign({}, this.logContext), $),
              { error: G }
            )
          );
        }
      switch ((this.trackPublications.delete(V.trackSid), V.kind)) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(V.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(V.trackSid);
          break;
      }
      return (
        this.emit(ParticipantEvent.LocalTrackUnpublished, V),
        V.setTrack(void 0),
        W && (yield this.engine.negotiate()),
        V
      );
    });
  }
  unpublishTracks(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return (yield Promise.all(U.map((q) => this.unpublishTrack(q)))).filter(
        (q) => !!q
      );
    });
  }
  republishAllTracks(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return (function* () {
        q.republishPromise && (yield q.republishPromise),
          (q.republishPromise = new Promise((V, $) =>
            __awaiter$b(q, void 0, void 0, function* () {
              try {
                const W = [];
                this.trackPublications.forEach((K) => {
                  K.track &&
                    (F &&
                      (K.options = Object.assign(
                        Object.assign({}, K.options),
                        F
                      )),
                    W.push(K));
                }),
                  yield Promise.all(
                    W.map((K) =>
                      __awaiter$b(this, void 0, void 0, function* () {
                        const G = K.track;
                        yield this.unpublishTrack(G, !1),
                          j &&
                            !G.isMuted &&
                            G.source !== Track.Source.ScreenShare &&
                            G.source !== Track.Source.ScreenShareAudio &&
                            (isLocalAudioTrack(G) || isLocalVideoTrack(G)) &&
                            !G.isUserProvided &&
                            (this.log.debug(
                              "restarting existing track",
                              Object.assign(
                                Object.assign({}, this.logContext),
                                { track: K.trackSid }
                              )
                            ),
                            yield G.restartTrack()),
                          yield this.publishOrRepublishTrack(G, K.options, !0);
                      })
                    )
                  ),
                  V();
              } catch (W) {
                $(W);
              } finally {
                this.republishPromise = void 0;
              }
            })
          )),
          yield q.republishPromise;
      })();
    });
  }
  publishData(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let j =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return (function* () {
        const V = j.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY,
          $ = j.destinationIdentities,
          W = j.topic,
          K = new DataPacket({
            kind: V,
            value: {
              case: "user",
              value: new UserPacket({
                participantIdentity: q.identity,
                payload: F,
                destinationIdentities: $,
                topic: W,
              }),
            },
          });
        yield q.engine.sendDataPacket(K, V);
      })();
    });
  }
  publishDtmf(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = new DataPacket({
        kind: DataPacket_Kind.RELIABLE,
        value: { case: "sipDtmf", value: new SipDTMF({ code: U, digit: F }) },
      });
      yield this.engine.sendDataPacket(q, DataPacket_Kind.RELIABLE);
    });
  }
  sendChatMessage(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = {
          id: crypto.randomUUID(),
          message: U,
          timestamp: Date.now(),
          attachedFiles: F == null ? void 0 : F.attachments,
        },
        j = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(
              Object.assign(Object.assign({}, q), {
                timestamp: protoInt64.parse(q.timestamp),
              })
            ),
          },
        });
      return (
        yield this.engine.sendDataPacket(j, DataPacket_Kind.RELIABLE),
        this.emit(ParticipantEvent.ChatMessage, q),
        q
      );
    });
  }
  editChatMessage(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = Object.assign(Object.assign({}, F), {
          message: U,
          editTimestamp: Date.now(),
        }),
        j = new DataPacket({
          value: {
            case: "chatMessage",
            value: new ChatMessage(
              Object.assign(Object.assign({}, q), {
                timestamp: protoInt64.parse(q.timestamp),
                editTimestamp: protoInt64.parse(q.editTimestamp),
              })
            ),
          },
        });
      return (
        yield this.engine.sendDataPacket(j, DataPacket_Kind.RELIABLE),
        this.emit(ParticipantEvent.ChatMessage, q),
        q
      );
    });
  }
  sendText(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var q;
      const j = crypto.randomUUID(),
        $ = new TextEncoder().encode(U).byteLength,
        W =
          (q = F == null ? void 0 : F.attachments) === null || q === void 0
            ? void 0
            : q.map(() => crypto.randomUUID()),
        K = new Array(W ? W.length + 1 : 1).fill(0),
        G = (Q, z) => {
          var Y;
          K[z] = Q;
          const X = K.reduce((Z, se) => Z + se, 0);
          (Y = F == null ? void 0 : F.onProgress) === null ||
            Y === void 0 ||
            Y.call(F, X);
        },
        H = yield this.streamText({
          streamId: j,
          totalSize: $,
          destinationIdentities: F == null ? void 0 : F.destinationIdentities,
          topic: F == null ? void 0 : F.topic,
          attachedStreamIds: W,
          attributes: F == null ? void 0 : F.attributes,
        });
      return (
        yield H.write(U),
        G(1, 0),
        yield H.close(),
        F != null &&
          F.attachments &&
          W &&
          (yield Promise.all(
            F.attachments.map((Q, z) =>
              __awaiter$b(this, void 0, void 0, function* () {
                return this._sendFile(W[z], Q, {
                  topic: F.topic,
                  mimeType: Q.type,
                  onProgress: (Y) => {
                    G(Y, z + 1);
                  },
                });
              })
            )
          )),
        H.info
      );
    });
  }
  streamText(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q;
      const j =
          (F = U == null ? void 0 : U.streamId) !== null && F !== void 0
            ? F
            : crypto.randomUUID(),
        V = {
          id: j,
          mimeType: "text/plain",
          timestamp: Date.now(),
          topic:
            (q = U == null ? void 0 : U.topic) !== null && q !== void 0
              ? q
              : "",
          size: U == null ? void 0 : U.totalSize,
          attributes: U == null ? void 0 : U.attributes,
        },
        $ = new DataStream_Header({
          streamId: j,
          mimeType: V.mimeType,
          topic: V.topic,
          timestamp: numberToBigInt(V.timestamp),
          totalLength: numberToBigInt(U == null ? void 0 : U.totalSize),
          attributes: V.attributes,
          contentHeader: {
            case: "textHeader",
            value: new DataStream_TextHeader({
              version: U == null ? void 0 : U.version,
              attachedStreamIds: U == null ? void 0 : U.attachedStreamIds,
              replyToStreamId: U == null ? void 0 : U.replyToStreamId,
              operationType:
                (U == null ? void 0 : U.type) === "update"
                  ? DataStream_OperationType.UPDATE
                  : DataStream_OperationType.CREATE,
            }),
          },
        }),
        W = U == null ? void 0 : U.destinationIdentities,
        K = new DataPacket({
          destinationIdentities: W,
          value: { case: "streamHeader", value: $ },
        });
      yield this.engine.sendDataPacket(K, DataPacket_Kind.RELIABLE);
      let G = 0;
      const H = this,
        Q = new WritableStream({
          write(X) {
            return __awaiter$b(this, void 0, void 0, function* () {
              for (const Z of splitUtf8(X, STREAM_CHUNK_SIZE)) {
                yield H.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                const se = new DataStream_Chunk({
                    content: Z,
                    streamId: j,
                    chunkIndex: numberToBigInt(G),
                  }),
                  ee = new DataPacket({
                    destinationIdentities: W,
                    value: { case: "streamChunk", value: se },
                  });
                yield H.engine.sendDataPacket(ee, DataPacket_Kind.RELIABLE),
                  (G += 1);
              }
            });
          },
          close() {
            return __awaiter$b(this, void 0, void 0, function* () {
              const X = new DataStream_Trailer({ streamId: j }),
                Z = new DataPacket({
                  destinationIdentities: W,
                  value: { case: "streamTrailer", value: X },
                });
              yield H.engine.sendDataPacket(Z, DataPacket_Kind.RELIABLE);
            });
          },
          abort(X) {
            console.log("Sink error:", X);
          },
        });
      let z = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          yield Y.close();
        });
      H.engine.once(EngineEvent.Closing, z);
      const Y = new TextStreamWriter(Q, V, () =>
        this.engine.off(EngineEvent.Closing, z)
      );
      return Y;
    });
  }
  sendFile(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = crypto.randomUUID();
      return yield this._sendFile(q, U, F), { id: q };
    });
  }
  _sendFile(U, F, q) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var j;
      const V = yield this.streamBytes({
          streamId: U,
          totalSize: F.size,
          name: F.name,
          mimeType:
            (j = q == null ? void 0 : q.mimeType) !== null && j !== void 0
              ? j
              : F.type,
          topic: q == null ? void 0 : q.topic,
          destinationIdentities: q == null ? void 0 : q.destinationIdentities,
        }),
        $ = F.stream().getReader();
      for (;;) {
        const { done: W, value: K } = yield $.read();
        if (W) break;
        yield V.write(K);
      }
      return yield V.close(), V.info;
    });
  }
  streamBytes(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q, j, V, $;
      const W =
          (F = U == null ? void 0 : U.streamId) !== null && F !== void 0
            ? F
            : crypto.randomUUID(),
        K = U == null ? void 0 : U.destinationIdentities,
        G = {
          id: W,
          mimeType:
            (q = U == null ? void 0 : U.mimeType) !== null && q !== void 0
              ? q
              : "application/octet-stream",
          topic:
            (j = U == null ? void 0 : U.topic) !== null && j !== void 0
              ? j
              : "",
          timestamp: Date.now(),
          attributes: U == null ? void 0 : U.attributes,
          size: U == null ? void 0 : U.totalSize,
          name:
            (V = U == null ? void 0 : U.name) !== null && V !== void 0
              ? V
              : "unknown",
        },
        H = new DataStream_Header({
          totalLength: numberToBigInt(
            ($ = G.size) !== null && $ !== void 0 ? $ : 0
          ),
          mimeType: G.mimeType,
          streamId: W,
          topic: G.topic,
          timestamp: numberToBigInt(Date.now()),
          contentHeader: {
            case: "byteHeader",
            value: new DataStream_ByteHeader({ name: G.name }),
          },
        }),
        Q = new DataPacket({
          destinationIdentities: K,
          value: { case: "streamHeader", value: H },
        });
      yield this.engine.sendDataPacket(Q, DataPacket_Kind.RELIABLE);
      let z = 0;
      const Y = new _$1(),
        X = this.engine,
        Z = this.log,
        se = new WritableStream({
          write(ie) {
            return __awaiter$b(this, void 0, void 0, function* () {
              const re = yield Y.lock();
              let te = 0;
              try {
                for (; te < ie.byteLength; ) {
                  const ne = ie.slice(te, te + STREAM_CHUNK_SIZE);
                  yield X.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                  const oe = new DataPacket({
                    destinationIdentities: K,
                    value: {
                      case: "streamChunk",
                      value: new DataStream_Chunk({
                        content: ne,
                        streamId: W,
                        chunkIndex: numberToBigInt(z),
                      }),
                    },
                  });
                  yield X.sendDataPacket(oe, DataPacket_Kind.RELIABLE),
                    (z += 1),
                    (te += ne.byteLength);
                }
              } finally {
                re();
              }
            });
          },
          close() {
            return __awaiter$b(this, void 0, void 0, function* () {
              const ie = new DataStream_Trailer({ streamId: W }),
                re = new DataPacket({
                  destinationIdentities: K,
                  value: { case: "streamTrailer", value: ie },
                });
              yield X.sendDataPacket(re, DataPacket_Kind.RELIABLE);
            });
          },
          abort(ie) {
            Z.error("Sink error:", ie);
          },
        });
      return new ByteStreamWriter(se, G);
    });
  }
  performRpc(U) {
    return __awaiter$b(this, arguments, void 0, function (F) {
      var q = this;
      let {
        destinationIdentity: j,
        method: V,
        payload: $,
        responseTimeout: W = 1e4,
      } = F;
      return (function* () {
        return new Promise((G, H) =>
          __awaiter$b(q, void 0, void 0, function* () {
            var Q, z, Y, X;
            if (byteLength($) > MAX_PAYLOAD_BYTES) {
              H(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
              return;
            }
            if (
              !(
                (z =
                  (Q = this.engine.latestJoinResponse) === null || Q === void 0
                    ? void 0
                    : Q.serverInfo) === null || z === void 0
              ) &&
              z.version &&
              compareVersions(
                (X =
                  (Y = this.engine.latestJoinResponse) === null || Y === void 0
                    ? void 0
                    : Y.serverInfo) === null || X === void 0
                  ? void 0
                  : X.version,
                "1.8.0"
              ) < 0
            ) {
              H(RpcError.builtIn("UNSUPPORTED_SERVER"));
              return;
            }
            const Z = crypto.randomUUID();
            yield this.publishRpcRequest(j, Z, V, $, W - 2e3);
            const se = setTimeout(() => {
              this.pendingAcks.delete(Z),
                H(RpcError.builtIn("CONNECTION_TIMEOUT")),
                this.pendingResponses.delete(Z),
                clearTimeout(ee);
            }, 2e3);
            this.pendingAcks.set(Z, {
              resolve: () => {
                clearTimeout(se);
              },
              participantIdentity: j,
            });
            const ee = setTimeout(() => {
              this.pendingResponses.delete(Z),
                H(RpcError.builtIn("RESPONSE_TIMEOUT"));
            }, W);
            this.pendingResponses.set(Z, {
              resolve: (ie, re) => {
                clearTimeout(ee),
                  this.pendingAcks.has(Z) &&
                    (console.warn("RPC response received before ack", Z),
                    this.pendingAcks.delete(Z),
                    clearTimeout(se)),
                  re ? H(re) : G(ie ?? "");
              },
              participantIdentity: j,
            });
          })
        );
      })();
    });
  }
  registerRpcMethod(U, F) {
    this.rpcHandlers.has(U) &&
      this.log.warn(
        "you're overriding the RPC handler for method ".concat(
          U,
          ", in the future this will throw an error"
        )
      ),
      this.rpcHandlers.set(U, F);
  }
  unregisterRpcMethod(U) {
    this.rpcHandlers.delete(U);
  }
  setTrackSubscriptionPermissions(U) {
    let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    (this.participantTrackPermissions = F),
      (this.allParticipantsAllowedToSubscribe = U),
      this.engine.client.isDisconnected ||
        this.updateTrackSubscriptionPermissions();
  }
  handleIncomingRpcAck(U) {
    const F = this.pendingAcks.get(U);
    F
      ? (F.resolve(), this.pendingAcks.delete(U))
      : console.error("Ack received for unexpected RPC request", U);
  }
  handleIncomingRpcResponse(U, F, q) {
    const j = this.pendingResponses.get(U);
    j
      ? (j.resolve(F, q), this.pendingResponses.delete(U))
      : console.error("Response received for unexpected RPC request", U);
  }
  publishRpcRequest(U, F, q, j, V) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const $ = new DataPacket({
        destinationIdentities: [U],
        kind: DataPacket_Kind.RELIABLE,
        value: {
          case: "rpcRequest",
          value: new RpcRequest({
            id: F,
            method: q,
            payload: j,
            responseTimeoutMs: V,
            version: 1,
          }),
        },
      });
      yield this.engine.sendDataPacket($, DataPacket_Kind.RELIABLE);
    });
  }
  handleParticipantDisconnected(U) {
    for (const [F, { participantIdentity: q }] of this.pendingAcks)
      q === U && this.pendingAcks.delete(F);
    for (const [F, { participantIdentity: q, resolve: j }] of this
      .pendingResponses)
      q === U &&
        (j(null, RpcError.builtIn("RECIPIENT_DISCONNECTED")),
        this.pendingResponses.delete(F));
  }
  setEnabledPublishCodecs(U) {
    this.enabledPublishVideoCodecs = U.filter(
      (F) => F.mime.split("/")[0].toLowerCase() === "video"
    );
  }
  updateInfo(U) {
    return U.sid !== this.sid || !super.updateInfo(U)
      ? !1
      : (U.tracks.forEach((F) => {
          var q, j;
          const V = this.trackPublications.get(F.sid);
          if (V) {
            const $ =
              V.isMuted ||
              ((j =
                (q = V.track) === null || q === void 0
                  ? void 0
                  : q.isUpstreamPaused) !== null && j !== void 0
                ? j
                : !1);
            $ !== F.muted &&
              (this.log.debug(
                "updating server mute state after reconcile",
                Object.assign(
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(V)
                  ),
                  { mutedOnServer: $ }
                )
              ),
              this.engine.client.sendMuteTrack(F.sid, $));
          }
        }),
        !0);
  }
  getPublicationForTrack(U) {
    let F;
    return (
      this.trackPublications.forEach((q) => {
        const j = q.track;
        j &&
          (U instanceof MediaStreamTrack
            ? (isLocalAudioTrack(j) || isLocalVideoTrack(j)) &&
              j.mediaStreamTrack === U &&
              (F = q)
            : U === j && (F = q));
      }),
      F
    );
  }
  waitForPendingPublicationOfSource(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const q = Date.now();
      for (; Date.now() < q + 1e4; ) {
        const j = Array.from(this.pendingPublishPromises.entries()).find(
          (V) => {
            let [$] = V;
            return $.source === U;
          }
        );
        if (j) return j[1];
        yield sleep$1(20);
      }
    });
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(U, F, q, j) {
    super(U, F.sid, F.name, j),
      (this.track = void 0),
      (this.allowed = !0),
      (this.disabled = !1),
      (this.currentVideoQuality = VideoQuality.HIGH),
      (this.handleEnded = (V) => {
        this.setTrack(void 0), this.emit(TrackEvent.Ended, V);
      }),
      (this.handleVisibilityChange = (V) => {
        this.log.debug(
          "adaptivestream video visibility "
            .concat(this.trackSid, ", visible=")
            .concat(V),
          this.logContext
        ),
          (this.disabled = !V),
          this.emitTrackUpdate();
      }),
      (this.handleVideoDimensionsChange = (V) => {
        this.log.debug(
          "adaptivestream video dimensions "
            .concat(V.width, "x")
            .concat(V.height),
          this.logContext
        ),
          (this.videoDimensions = V),
          this.emitTrackUpdate();
      }),
      (this.subscribed = q),
      this.updateInfo(F);
  }
  setSubscribed(U) {
    const F = this.subscriptionStatus,
      q = this.permissionStatus;
    (this.subscribed = U), U && (this.allowed = !0);
    const j = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [
        new ParticipantTracks({
          participantSid: "",
          trackSids: [this.trackSid],
        }),
      ],
    });
    this.emit(TrackEvent.UpdateSubscription, j),
      this.emitSubscriptionUpdateIfChanged(F),
      this.emitPermissionUpdateIfChanged(q);
  }
  get subscriptionStatus() {
    return this.subscribed === !1
      ? TrackPublication.SubscriptionStatus.Unsubscribed
      : super.isSubscribed
      ? TrackPublication.SubscriptionStatus.Subscribed
      : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed
      ? TrackPublication.PermissionStatus.Allowed
      : TrackPublication.PermissionStatus.NotAllowed;
  }
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  get isLocal() {
    return !1;
  }
  setEnabled(U) {
    !this.isManualOperationAllowed() ||
      this.disabled === !U ||
      ((this.disabled = !U), this.emitTrackUpdate());
  }
  setVideoQuality(U) {
    !this.isManualOperationAllowed() ||
      this.currentVideoQuality === U ||
      ((this.currentVideoQuality = U),
      (this.videoDimensions = void 0),
      this.emitTrackUpdate());
  }
  setVideoDimensions(U) {
    var F, q;
    this.isManualOperationAllowed() &&
      ((((F = this.videoDimensions) === null || F === void 0
        ? void 0
        : F.width) === U.width &&
        ((q = this.videoDimensions) === null || q === void 0
          ? void 0
          : q.height) === U.height) ||
        (isRemoteVideoTrack(this.track) && (this.videoDimensions = U),
        (this.currentVideoQuality = void 0),
        this.emitTrackUpdate()));
  }
  setVideoFPS(U) {
    this.isManualOperationAllowed() &&
      isRemoteVideoTrack(this.track) &&
      this.fps !== U &&
      ((this.fps = U), this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  setTrack(U) {
    const F = this.subscriptionStatus,
      q = this.permissionStatus,
      j = this.track;
    j !== U &&
      (j &&
        (j.off(
          TrackEvent.VideoDimensionsChanged,
          this.handleVideoDimensionsChange
        ),
        j.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange),
        j.off(TrackEvent.Ended, this.handleEnded),
        j.detach(),
        j.stopMonitor(),
        this.emit(TrackEvent.Unsubscribed, j)),
      super.setTrack(U),
      U &&
        ((U.sid = this.trackSid),
        U.on(
          TrackEvent.VideoDimensionsChanged,
          this.handleVideoDimensionsChange
        ),
        U.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange),
        U.on(TrackEvent.Ended, this.handleEnded),
        this.emit(TrackEvent.Subscribed, U)),
      this.emitPermissionUpdateIfChanged(q),
      this.emitSubscriptionUpdateIfChanged(F));
  }
  setAllowed(U) {
    const F = this.subscriptionStatus,
      q = this.permissionStatus;
    (this.allowed = U),
      this.emitPermissionUpdateIfChanged(q),
      this.emitSubscriptionUpdateIfChanged(F);
  }
  setSubscriptionError(U) {
    this.emit(TrackEvent.SubscriptionFailed, U);
  }
  updateInfo(U) {
    super.updateInfo(U);
    const F = this.metadataMuted;
    (this.metadataMuted = U.muted),
      this.track
        ? this.track.setMuted(U.muted)
        : F !== U.muted &&
          this.emit(U.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(U) {
    const F = this.subscriptionStatus;
    U !== F && this.emit(TrackEvent.SubscriptionStatusChanged, F, U);
  }
  emitPermissionUpdateIfChanged(U) {
    this.permissionStatus !== U &&
      this.emit(
        TrackEvent.SubscriptionPermissionChanged,
        this.permissionStatus,
        U
      );
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream
      ? (this.log.warn(
          "adaptive stream is enabled, cannot change video track settings",
          this.logContext
        ),
        !1)
      : this.isDesired
      ? !0
      : (this.log.warn(
          "cannot update track settings when not subscribed",
          this.logContext
        ),
        !1);
  }
  get isAdaptiveStream() {
    return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
  }
  emitTrackUpdate() {
    const U = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps,
    });
    this.videoDimensions
      ? ((U.width = Math.ceil(this.videoDimensions.width)),
        (U.height = Math.ceil(this.videoDimensions.height)))
      : this.currentVideoQuality !== void 0
      ? (U.quality = this.currentVideoQuality)
      : (U.quality = VideoQuality.HIGH),
      this.emit(TrackEvent.UpdateSettings, U);
  }
}
class RemoteParticipant extends Participant {
  static fromParticipantInfo(U, F, q) {
    return new RemoteParticipant(
      U,
      F.sid,
      F.identity,
      F.name,
      F.metadata,
      F.attributes,
      q,
      F.kind
    );
  }
  get logContext() {
    return Object.assign(Object.assign({}, super.logContext), {
      rpID: this.sid,
      remoteParticipant: this.identity,
    });
  }
  constructor(U, F, q, j, V, $, W) {
    let K =
      arguments.length > 7 && arguments[7] !== void 0
        ? arguments[7]
        : ParticipantInfo_Kind.STANDARD;
    super(F, q || "", j, V, $, W, K),
      (this.signalClient = U),
      (this.trackPublications = new Map()),
      (this.audioTrackPublications = new Map()),
      (this.videoTrackPublications = new Map()),
      (this.volumeMap = new Map());
  }
  addTrackPublication(U) {
    super.addTrackPublication(U),
      U.on(TrackEvent.UpdateSettings, (F) => {
        this.log.debug(
          "send update settings",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(U)
          )
        ),
          this.signalClient.sendUpdateTrackSettings(F);
      }),
      U.on(TrackEvent.UpdateSubscription, (F) => {
        F.participantTracks.forEach((q) => {
          q.participantSid = this.sid;
        }),
          this.signalClient.sendUpdateSubscription(F);
      }),
      U.on(TrackEvent.SubscriptionPermissionChanged, (F) => {
        this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, U, F);
      }),
      U.on(TrackEvent.SubscriptionStatusChanged, (F) => {
        this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, U, F);
      }),
      U.on(TrackEvent.Subscribed, (F) => {
        this.emit(ParticipantEvent.TrackSubscribed, F, U);
      }),
      U.on(TrackEvent.Unsubscribed, (F) => {
        this.emit(ParticipantEvent.TrackUnsubscribed, F, U);
      }),
      U.on(TrackEvent.SubscriptionFailed, (F) => {
        this.emit(ParticipantEvent.TrackSubscriptionFailed, U.trackSid, F);
      });
  }
  getTrackPublication(U) {
    const F = super.getTrackPublication(U);
    if (F) return F;
  }
  getTrackPublicationByName(U) {
    const F = super.getTrackPublicationByName(U);
    if (F) return F;
  }
  setVolume(U) {
    let F =
      arguments.length > 1 && arguments[1] !== void 0
        ? arguments[1]
        : Track.Source.Microphone;
    this.volumeMap.set(F, U);
    const q = this.getTrackPublication(F);
    q && q.track && q.track.setVolume(U);
  }
  getVolume() {
    let U =
      arguments.length > 0 && arguments[0] !== void 0
        ? arguments[0]
        : Track.Source.Microphone;
    const F = this.getTrackPublication(U);
    return F && F.track ? F.track.getVolume() : this.volumeMap.get(U);
  }
  addSubscribedMediaTrack(U, F, q, j, V, $) {
    let W = this.getTrackPublicationBySid(F);
    if (
      (W ||
        F.startsWith("TR") ||
        this.trackPublications.forEach((H) => {
          !W && U.kind === H.kind.toString() && (W = H);
        }),
      !W)
    ) {
      if ($ === 0) {
        this.log.error(
          "could not find published track",
          Object.assign(Object.assign({}, this.logContext), { trackSid: F })
        ),
          this.emit(ParticipantEvent.TrackSubscriptionFailed, F);
        return;
      }
      $ === void 0 && ($ = 20),
        setTimeout(() => {
          this.addSubscribedMediaTrack(U, F, q, j, V, $ - 1);
        }, 150);
      return;
    }
    if (U.readyState === "ended") {
      this.log.error(
        "unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()",
        Object.assign(
          Object.assign({}, this.logContext),
          getLogContextFromTrack(W)
        )
      ),
        this.emit(ParticipantEvent.TrackSubscriptionFailed, F);
      return;
    }
    const K = U.kind === "video";
    let G;
    return (
      K
        ? (G = new RemoteVideoTrack(U, F, j, V))
        : (G = new RemoteAudioTrack(
            U,
            F,
            j,
            this.audioContext,
            this.audioOutput
          )),
      (G.source = W.source),
      (G.isMuted = W.isMuted),
      G.setMediaStream(q),
      G.start(),
      W.setTrack(G),
      this.volumeMap.has(W.source) &&
        isRemoteTrack(G) &&
        isAudioTrack(G) &&
        G.setVolume(this.volumeMap.get(W.source)),
      W
    );
  }
  get hasMetadata() {
    return !!this.participantInfo;
  }
  getTrackPublicationBySid(U) {
    return this.trackPublications.get(U);
  }
  updateInfo(U) {
    if (!super.updateInfo(U)) return !1;
    const F = new Map(),
      q = new Map();
    return (
      U.tracks.forEach((j) => {
        var V, $;
        let W = this.getTrackPublicationBySid(j.sid);
        if (W) W.updateInfo(j);
        else {
          const K = Track.kindFromProto(j.type);
          if (!K) return;
          (W = new RemoteTrackPublication(
            K,
            j,
            (V = this.signalClient.connectOptions) === null || V === void 0
              ? void 0
              : V.autoSubscribe,
            {
              loggerContextCb: () => this.logContext,
              loggerName:
                ($ = this.loggerOptions) === null || $ === void 0
                  ? void 0
                  : $.loggerName,
            }
          )),
            W.updateInfo(j),
            q.set(j.sid, W);
          const G = Array.from(this.trackPublications.values()).find(
            (H) => H.source === (W == null ? void 0 : W.source)
          );
          G &&
            W.source !== Track.Source.Unknown &&
            this.log.debug(
              "received a second track publication for "
                .concat(this.identity, " with the same source: ")
                .concat(W.source),
              Object.assign(Object.assign({}, this.logContext), {
                oldTrack: getLogContextFromTrack(G),
                newTrack: getLogContextFromTrack(W),
              })
            ),
            this.addTrackPublication(W);
        }
        F.set(j.sid, W);
      }),
      this.trackPublications.forEach((j) => {
        F.has(j.trackSid) ||
          (this.log.trace(
            "detected removed track on remote participant, unpublishing",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(j)
            )
          ),
          this.unpublishTrack(j.trackSid, !0));
      }),
      q.forEach((j) => {
        this.emit(ParticipantEvent.TrackPublished, j);
      }),
      !0
    );
  }
  unpublishTrack(U, F) {
    const q = this.trackPublications.get(U);
    if (!q) return;
    const { track: j } = q;
    switch (
      (j && (j.stop(), q.setTrack(void 0)),
      this.trackPublications.delete(U),
      q.kind)
    ) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(U);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(U);
        break;
    }
    F && this.emit(ParticipantEvent.TrackUnpublished, q);
  }
  setAudioOutput(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.audioOutput = U;
      const F = [];
      this.audioTrackPublications.forEach((q) => {
        var j;
        isAudioTrack(q.track) &&
          isRemoteTrack(q.track) &&
          F.push(
            q.track.setSinkId(
              (j = U.deviceId) !== null && j !== void 0 ? j : "default"
            )
          );
      }),
        yield Promise.all(F);
    });
  }
  emit(U) {
    for (
      var F = arguments.length, q = new Array(F > 1 ? F - 1 : 0), j = 1;
      j < F;
      j++
    )
      q[j - 1] = arguments[j];
    return (
      this.log.trace(
        "participant event",
        Object.assign(Object.assign({}, this.logContext), { event: U, args: q })
      ),
      super.emit(U, ...q)
    );
  }
}
var ConnectionState;
(function (B) {
  (B.Disconnected = "disconnected"),
    (B.Connecting = "connecting"),
    (B.Connected = "connected"),
    (B.Reconnecting = "reconnecting"),
    (B.SignalReconnecting = "signalReconnecting");
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 4 * 1e3;
class Room extends eventsExports$1.EventEmitter {
  constructor(U) {
    var F, q, j, V;
    if (
      (super(),
      (F = this),
      (this.state = ConnectionState.Disconnected),
      (this.activeSpeakers = []),
      (this.isE2EEEnabled = !1),
      (this.audioEnabled = !0),
      (this.isVideoPlaybackBlocked = !1),
      (this.log = livekitLogger),
      (this.bufferedEvents = []),
      (this.isResuming = !1),
      (this.byteStreamControllers = new Map()),
      (this.textStreamControllers = new Map()),
      (this.byteStreamHandlers = new Map()),
      (this.textStreamHandlers = new Map()),
      (this.rpcHandlers = new Map()),
      (this.connect = ($, W, K) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var G;
          if (!isBrowserSupported())
            throw isReactNative()
              ? Error("WebRTC isn't detected, have you called registerGlobals?")
              : Error(
                  "LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC."
                );
          const H = yield this.disconnectLock.lock();
          if (this.state === ConnectionState.Connected)
            return (
              this.log.info(
                "already connected to room ".concat(this.name),
                this.logContext
              ),
              H(),
              Promise.resolve()
            );
          if (this.connectFuture) return H(), this.connectFuture.promise;
          this.setAndEmitConnectionState(ConnectionState.Connecting),
            ((G = this.regionUrlProvider) === null || G === void 0
              ? void 0
              : G.getServerUrl().toString()) !== $ &&
              ((this.regionUrl = void 0), (this.regionUrlProvider = void 0)),
            isCloud(new URL($)) &&
              (this.regionUrlProvider === void 0
                ? (this.regionUrlProvider = new RegionUrlProvider($, W))
                : this.regionUrlProvider.updateToken(W),
              this.regionUrlProvider
                .fetchRegionSettings()
                .then((Y) => {
                  var X;
                  (X = this.regionUrlProvider) === null ||
                    X === void 0 ||
                    X.setServerReportedRegions(Y);
                })
                .catch((Y) => {
                  this.log.warn(
                    "could not fetch region settings",
                    Object.assign(Object.assign({}, this.logContext), {
                      error: Y,
                    })
                  );
                }));
          const Q = (Y, X, Z) =>
              __awaiter$b(this, void 0, void 0, function* () {
                var se, ee;
                this.abortController && this.abortController.abort();
                const ie = new AbortController();
                (this.abortController = ie), H == null || H();
                try {
                  yield this.attemptConnection(Z ?? $, W, K, ie),
                    (this.abortController = void 0),
                    Y();
                } catch (re) {
                  if (
                    this.regionUrlProvider &&
                    re instanceof ConnectionError &&
                    re.reason !== ConnectionErrorReason.Cancelled &&
                    re.reason !== ConnectionErrorReason.NotAllowed
                  ) {
                    let te = null;
                    try {
                      te = yield this.regionUrlProvider.getNextBestRegionUrl(
                        (se = this.abortController) === null || se === void 0
                          ? void 0
                          : se.signal
                      );
                    } catch (ne) {
                      if (
                        ne instanceof ConnectionError &&
                        (ne.status === 401 ||
                          ne.reason === ConnectionErrorReason.Cancelled)
                      ) {
                        this.handleDisconnect(
                          this.options.stopLocalTrackOnUnpublish
                        ),
                          X(ne);
                        return;
                      }
                    }
                    te &&
                    !(
                      !(
                        (ee = this.abortController) === null || ee === void 0
                      ) && ee.signal.aborted
                    )
                      ? (this.log.info(
                          "Initial connection failed with ConnectionError: "
                            .concat(
                              re.message,
                              ". Retrying with another region: "
                            )
                            .concat(te),
                          this.logContext
                        ),
                        this.recreateEngine(),
                        yield Q(Y, X, te))
                      : (this.handleDisconnect(
                          this.options.stopLocalTrackOnUnpublish,
                          getDisconnectReasonFromConnectionError(re)
                        ),
                        X(re));
                  } else {
                    let te = DisconnectReason.UNKNOWN_REASON;
                    re instanceof ConnectionError &&
                      (te = getDisconnectReasonFromConnectionError(re)),
                      this.handleDisconnect(
                        this.options.stopLocalTrackOnUnpublish,
                        te
                      ),
                      X(re);
                  }
                }
              }),
            z = this.regionUrl;
          return (
            (this.regionUrl = void 0),
            (this.connectFuture = new Future(
              (Y, X) => {
                Q(Y, X, z);
              },
              () => {
                this.clearConnectionFutures();
              }
            )),
            this.connectFuture.promise
          );
        })),
      (this.connectSignal = ($, W, K, G, H, Q) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var z, Y, X;
          const Z = yield K.join(
            $,
            W,
            {
              autoSubscribe: G.autoSubscribe,
              adaptiveStream:
                typeof H.adaptiveStream == "object" ? !0 : H.adaptiveStream,
              maxRetries: G.maxRetries,
              e2eeEnabled: !!this.e2eeManager,
              websocketTimeout: G.websocketTimeout,
            },
            Q.signal
          );
          let se = Z.serverInfo;
          if (
            (se || (se = { version: Z.serverVersion, region: Z.serverRegion }),
            (this.serverInfo = se),
            this.log.debug(
              "connected to Livekit Server ".concat(
                Object.entries(se)
                  .map((ee) => {
                    let [ie, re] = ee;
                    return "".concat(ie, ": ").concat(re);
                  })
                  .join(", ")
              ),
              {
                room: (z = Z.room) === null || z === void 0 ? void 0 : z.name,
                roomSid: (Y = Z.room) === null || Y === void 0 ? void 0 : Y.sid,
                identity:
                  (X = Z.participant) === null || X === void 0
                    ? void 0
                    : X.identity,
              }
            ),
            !se.version)
          )
            throw new UnsupportedServer("unknown server version");
          return (
            se.version === "0.15.1" &&
              this.options.dynacast &&
              (this.log.debug(
                "disabling dynacast due to server version",
                this.logContext
              ),
              (H.dynacast = !1)),
            Z
          );
        })),
      (this.applyJoinResponse = ($) => {
        const W = $.participant;
        if (
          ((this.localParticipant.sid = W.sid),
          (this.localParticipant.identity = W.identity),
          this.localParticipant.setEnabledPublishCodecs($.enabledPublishCodecs),
          this.options.e2ee && this.e2eeManager)
        )
          try {
            this.e2eeManager.setSifTrailer($.sifTrailer);
          } catch (K) {
            this.log.error(
              K instanceof Error ? K.message : "Could not set SifTrailer",
              Object.assign(Object.assign({}, this.logContext), { error: K })
            );
          }
        this.handleParticipantUpdates([W, ...$.otherParticipants]),
          $.room && this.handleRoomUpdate($.room);
      }),
      (this.attemptConnection = ($, W, K, G) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var H, Q;
          this.state === ConnectionState.Reconnecting ||
          this.isResuming ||
          (!((H = this.engine) === null || H === void 0) && H.pendingReconnect)
            ? (this.log.info(
                "Reconnection attempt replaced by new connection attempt",
                this.logContext
              ),
              this.recreateEngine())
            : this.maybeCreateEngine(),
            !((Q = this.regionUrlProvider) === null || Q === void 0) &&
              Q.isCloud() &&
              this.engine.setRegionUrlProvider(this.regionUrlProvider),
            this.acquireAudioContext(),
            (this.connOptions = Object.assign(
              Object.assign({}, roomConnectOptionDefaults),
              K
            )),
            this.connOptions.rtcConfig &&
              (this.engine.rtcConfig = this.connOptions.rtcConfig),
            this.connOptions.peerConnectionTimeout &&
              (this.engine.peerConnectionTimeout =
                this.connOptions.peerConnectionTimeout);
          try {
            const z = yield this.connectSignal(
              $,
              W,
              this.engine,
              this.connOptions,
              this.options,
              G
            );
            this.applyJoinResponse(z),
              this.setupLocalParticipantEvents(),
              this.emit(RoomEvent.SignalConnected);
          } catch (z) {
            yield this.engine.close(), this.recreateEngine();
            const Y = new ConnectionError(
              "could not establish signal connection",
              ConnectionErrorReason.ServerUnreachable
            );
            throw (
              (z instanceof Error &&
                (Y.message = "".concat(Y.message, ": ").concat(z.message)),
              z instanceof ConnectionError &&
                ((Y.reason = z.reason), (Y.status = z.status)),
              this.log.debug(
                "error trying to establish signal connection",
                Object.assign(Object.assign({}, this.logContext), { error: z })
              ),
              Y)
            );
          }
          if (G.signal.aborted)
            throw (
              (yield this.engine.close(),
              this.recreateEngine(),
              new ConnectionError(
                "Connection attempt aborted",
                ConnectionErrorReason.Cancelled
              ))
            );
          try {
            yield this.engine.waitForPCInitialConnection(
              this.connOptions.peerConnectionTimeout,
              G
            );
          } catch (z) {
            throw (yield this.engine.close(), this.recreateEngine(), z);
          }
          isWeb() &&
            this.options.disconnectOnPageLeave &&
            (window.addEventListener("pagehide", this.onPageLeave),
            window.addEventListener("beforeunload", this.onPageLeave)),
            isWeb() && document.addEventListener("freeze", this.onPageLeave),
            this.setAndEmitConnectionState(ConnectionState.Connected),
            this.emit(RoomEvent.Connected),
            this.registerConnectionReconcile();
        })),
      (this.disconnect = function () {
        for (var $ = arguments.length, W = new Array($), K = 0; K < $; K++)
          W[K] = arguments[K];
        return __awaiter$b(F, [...W], void 0, function () {
          var G = this;
          let H =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          return (function* () {
            var Q, z, Y, X;
            const Z = yield G.disconnectLock.lock();
            try {
              if (G.state === ConnectionState.Disconnected) {
                G.log.debug("already disconnected", G.logContext);
                return;
              }
              G.log.info(
                "disconnect from room",
                Object.assign({}, G.logContext)
              ),
                (G.state === ConnectionState.Connecting ||
                  G.state === ConnectionState.Reconnecting ||
                  G.isResuming) &&
                  (G.log.warn("abort connection attempt", G.logContext),
                  (Q = G.abortController) === null || Q === void 0 || Q.abort(),
                  (Y =
                    (z = G.connectFuture) === null || z === void 0
                      ? void 0
                      : z.reject) === null ||
                    Y === void 0 ||
                    Y.call(
                      z,
                      new ConnectionError(
                        "Client initiated disconnect",
                        ConnectionErrorReason.Cancelled
                      )
                    ),
                  (G.connectFuture = void 0)),
                (!((X = G.engine) === null || X === void 0) &&
                  X.client.isDisconnected) ||
                  (yield G.engine.client.sendLeave()),
                G.engine && (yield G.engine.close()),
                G.handleDisconnect(H, DisconnectReason.CLIENT_INITIATED),
                (G.engine = void 0);
            } finally {
              Z();
            }
          })();
        });
      }),
      (this.onPageLeave = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          this.log.info("Page leave detected, disconnecting", this.logContext),
            yield this.disconnect();
        })),
      (this.startAudio = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          const $ = [],
            W = getBrowser();
          if (W && W.os === "iOS") {
            const K = "livekit-dummy-audio-el";
            let G = document.getElementById(K);
            if (!G) {
              (G = document.createElement("audio")),
                (G.id = K),
                (G.autoplay = !0),
                (G.hidden = !0);
              const H = getEmptyAudioStreamTrack();
              H.enabled = !0;
              const Q = new MediaStream([H]);
              (G.srcObject = Q),
                document.addEventListener("visibilitychange", () => {
                  G &&
                    ((G.srcObject = document.hidden ? null : Q),
                    document.hidden ||
                      (this.log.debug(
                        "page visible again, triggering startAudio to resume playback and update playback status",
                        this.logContext
                      ),
                      this.startAudio()));
                }),
                document.body.append(G),
                this.once(RoomEvent.Disconnected, () => {
                  G == null || G.remove(), (G = null);
                });
            }
            $.push(G);
          }
          this.remoteParticipants.forEach((K) => {
            K.audioTrackPublications.forEach((G) => {
              G.track &&
                G.track.attachedElements.forEach((H) => {
                  $.push(H);
                });
            });
          });
          try {
            yield Promise.all([
              this.acquireAudioContext(),
              ...$.map((K) => ((K.muted = !1), K.play())),
            ]),
              this.handleAudioPlaybackStarted();
          } catch (K) {
            throw (this.handleAudioPlaybackFailed(K), K);
          }
        })),
      (this.startVideo = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          const $ = [];
          for (const W of this.remoteParticipants.values())
            W.videoTrackPublications.forEach((K) => {
              var G;
              (G = K.track) === null ||
                G === void 0 ||
                G.attachedElements.forEach((H) => {
                  $.includes(H) || $.push(H);
                });
            });
          yield Promise.all($.map((W) => W.play()))
            .then(() => {
              this.handleVideoPlaybackStarted();
            })
            .catch((W) => {
              W.name === "NotAllowedError"
                ? this.handleVideoPlaybackFailed()
                : this.log.warn(
                    "Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler",
                    this.logContext
                  );
            });
        })),
      (this.handleRestarting = () => {
        this.clearConnectionReconcile(), (this.isResuming = !1);
        for (const $ of this.remoteParticipants.values())
          this.handleParticipantDisconnected($.identity, $);
        this.setAndEmitConnectionState(ConnectionState.Reconnecting) &&
          this.emit(RoomEvent.Reconnecting);
      }),
      (this.handleSignalRestarted = ($) =>
        __awaiter$b(this, void 0, void 0, function* () {
          this.log.debug(
            "signal reconnected to server, region ".concat($.serverRegion),
            Object.assign(Object.assign({}, this.logContext), {
              region: $.serverRegion,
            })
          ),
            (this.bufferedEvents = []),
            this.applyJoinResponse($);
          try {
            yield this.localParticipant.republishAllTracks(void 0, !0);
          } catch (W) {
            this.log.error(
              "error trying to re-publish tracks after reconnection",
              Object.assign(Object.assign({}, this.logContext), { error: W })
            );
          }
          try {
            yield this.engine.waitForRestarted(),
              this.log.debug(
                "fully reconnected to server",
                Object.assign(Object.assign({}, this.logContext), {
                  region: $.serverRegion,
                })
              );
          } catch {
            return;
          }
          this.setAndEmitConnectionState(ConnectionState.Connected),
            this.emit(RoomEvent.Reconnected),
            this.registerConnectionReconcile(),
            this.emitBufferedEvents();
        })),
      (this.handleParticipantUpdates = ($) => {
        $.forEach((W) => {
          var K;
          if (W.identity === this.localParticipant.identity) {
            this.localParticipant.updateInfo(W);
            return;
          }
          W.identity === "" &&
            (W.identity =
              (K = this.sidToIdentity.get(W.sid)) !== null && K !== void 0
                ? K
                : "");
          let G = this.remoteParticipants.get(W.identity);
          W.state === ParticipantInfo_State.DISCONNECTED
            ? this.handleParticipantDisconnected(W.identity, G)
            : (G = this.getOrCreateParticipant(W.identity, W));
        });
      }),
      (this.handleActiveSpeakersUpdate = ($) => {
        const W = [],
          K = {};
        $.forEach((G) => {
          if (((K[G.sid] = !0), G.sid === this.localParticipant.sid))
            (this.localParticipant.audioLevel = G.level),
              this.localParticipant.setIsSpeaking(!0),
              W.push(this.localParticipant);
          else {
            const H = this.getRemoteParticipantBySid(G.sid);
            H && ((H.audioLevel = G.level), H.setIsSpeaking(!0), W.push(H));
          }
        }),
          K[this.localParticipant.sid] ||
            ((this.localParticipant.audioLevel = 0),
            this.localParticipant.setIsSpeaking(!1)),
          this.remoteParticipants.forEach((G) => {
            K[G.sid] || ((G.audioLevel = 0), G.setIsSpeaking(!1));
          }),
          (this.activeSpeakers = W),
          this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, W);
      }),
      (this.handleSpeakersChanged = ($) => {
        const W = new Map();
        this.activeSpeakers.forEach((G) => {
          const H = this.remoteParticipants.get(G.identity);
          (H && H.sid !== G.sid) || W.set(G.sid, G);
        }),
          $.forEach((G) => {
            let H = this.getRemoteParticipantBySid(G.sid);
            G.sid === this.localParticipant.sid && (H = this.localParticipant),
              H &&
                ((H.audioLevel = G.level),
                H.setIsSpeaking(G.active),
                G.active ? W.set(G.sid, H) : W.delete(G.sid));
          });
        const K = Array.from(W.values());
        K.sort((G, H) => H.audioLevel - G.audioLevel),
          (this.activeSpeakers = K),
          this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, K);
      }),
      (this.handleStreamStateUpdate = ($) => {
        $.streamStates.forEach((W) => {
          const K = this.getRemoteParticipantBySid(W.participantSid);
          if (!K) return;
          const G = K.getTrackPublicationBySid(W.trackSid);
          if (!G || !G.track) return;
          const H = Track.streamStateFromProto(W.state);
          H !== G.track.streamState &&
            ((G.track.streamState = H),
            K.emit(
              ParticipantEvent.TrackStreamStateChanged,
              G,
              G.track.streamState
            ),
            this.emitWhenConnected(
              RoomEvent.TrackStreamStateChanged,
              G,
              G.track.streamState,
              K
            ));
        });
      }),
      (this.handleSubscriptionPermissionUpdate = ($) => {
        const W = this.getRemoteParticipantBySid($.participantSid);
        if (!W) return;
        const K = W.getTrackPublicationBySid($.trackSid);
        K && K.setAllowed($.allowed);
      }),
      (this.handleSubscriptionError = ($) => {
        const W = Array.from(this.remoteParticipants.values()).find((G) =>
          G.trackPublications.has($.trackSid)
        );
        if (!W) return;
        const K = W.getTrackPublicationBySid($.trackSid);
        K && K.setSubscriptionError($.err);
      }),
      (this.handleDataPacket = ($) => {
        const W = this.remoteParticipants.get($.participantIdentity);
        if ($.value.case === "user")
          this.handleUserPacket(W, $.value.value, $.kind);
        else if ($.value.case === "transcription")
          this.handleTranscription(W, $.value.value);
        else if ($.value.case === "sipDtmf")
          this.handleSipDtmf(W, $.value.value);
        else if ($.value.case === "chatMessage")
          this.handleChatMessage(W, $.value.value);
        else if ($.value.case === "metrics")
          this.handleMetrics($.value.value, W);
        else if ($.value.case === "streamHeader")
          this.handleStreamHeader($.value.value, $.participantIdentity);
        else if ($.value.case === "streamChunk")
          this.handleStreamChunk($.value.value);
        else if ($.value.case === "streamTrailer")
          this.handleStreamTrailer($.value.value);
        else if ($.value.case === "rpcRequest") {
          const K = $.value.value;
          this.handleIncomingRpcRequest(
            $.participantIdentity,
            K.id,
            K.method,
            K.payload,
            K.responseTimeoutMs,
            K.version
          );
        }
      }),
      (this.handleUserPacket = ($, W, K) => {
        this.emit(RoomEvent.DataReceived, W.payload, $, K, W.topic),
          $ == null || $.emit(ParticipantEvent.DataReceived, W.payload, K);
      }),
      (this.handleSipDtmf = ($, W) => {
        this.emit(RoomEvent.SipDTMFReceived, W, $),
          $ == null || $.emit(ParticipantEvent.SipDTMFReceived, W);
      }),
      (this.bufferedSegments = new Map()),
      (this.handleTranscription = ($, W) => {
        const K =
            W.transcribedParticipantIdentity === this.localParticipant.identity
              ? this.localParticipant
              : this.getParticipantByIdentity(W.transcribedParticipantIdentity),
          G = K == null ? void 0 : K.trackPublications.get(W.trackId),
          H = extractTranscriptionSegments(W, this.transcriptionReceivedTimes);
        G == null || G.emit(TrackEvent.TranscriptionReceived, H),
          K == null || K.emit(ParticipantEvent.TranscriptionReceived, H, G),
          this.emit(RoomEvent.TranscriptionReceived, H, K, G);
      }),
      (this.handleChatMessage = ($, W) => {
        const K = extractChatMessage(W);
        this.emit(RoomEvent.ChatMessage, K, $);
      }),
      (this.handleMetrics = ($, W) => {
        this.emit(RoomEvent.MetricsReceived, $, W);
      }),
      (this.handleAudioPlaybackStarted = () => {
        this.canPlaybackAudio ||
          ((this.audioEnabled = !0),
          this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
      }),
      (this.handleAudioPlaybackFailed = ($) => {
        this.log.warn(
          "could not playback audio",
          Object.assign(Object.assign({}, this.logContext), { error: $ })
        ),
          this.canPlaybackAudio &&
            ((this.audioEnabled = !1),
            this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
      }),
      (this.handleVideoPlaybackStarted = () => {
        this.isVideoPlaybackBlocked &&
          ((this.isVideoPlaybackBlocked = !1),
          this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
      }),
      (this.handleVideoPlaybackFailed = () => {
        this.isVideoPlaybackBlocked ||
          ((this.isVideoPlaybackBlocked = !0),
          this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
      }),
      (this.handleDeviceChange = () =>
        __awaiter$b(this, void 0, void 0, function* () {
          var $, W;
          const K = DeviceManager.getInstance().previousDevices,
            G = yield DeviceManager.getInstance().getDevices(void 0, !1),
            H = getBrowser();
          if ((H == null ? void 0 : H.name) === "Chrome" && H.os !== "iOS")
            for (let z of G) {
              const Y = K.find((X) => X.deviceId === z.deviceId);
              Y &&
                Y.label !== "" &&
                Y.kind === z.kind &&
                Y.label !== z.label &&
                this.getActiveDevice(z.kind) === "default" &&
                this.emit(RoomEvent.ActiveDeviceChanged, z.kind, z.deviceId);
            }
          const Q = ["audiooutput", "audioinput", "videoinput"];
          for (let z of Q) {
            const Y = G.filter((Z) => Z.kind === z),
              X = this.getActiveDevice(z);
            if (
              X ===
                (($ = K.filter((Z) => Z.kind === z)[0]) === null || $ === void 0
                  ? void 0
                  : $.deviceId) &&
              Y.length > 0 &&
              ((W = Y[0]) === null || W === void 0 ? void 0 : W.deviceId) !== X
            ) {
              yield this.switchActiveDevice(z, Y[0].deviceId);
              continue;
            }
            (z === "audioinput" && !isSafari()) ||
              z === "videoinput" ||
              (Y.length > 0 &&
                !Y.find((Z) => Z.deviceId === this.getActiveDevice(z)) &&
                (yield this.switchActiveDevice(z, Y[0].deviceId)));
          }
          this.emit(RoomEvent.MediaDevicesChanged);
        })),
      (this.handleRoomUpdate = ($) => {
        const W = this.roomInfo;
        (this.roomInfo = $),
          W &&
            W.metadata !== $.metadata &&
            this.emitWhenConnected(RoomEvent.RoomMetadataChanged, $.metadata),
          (W == null ? void 0 : W.activeRecording) !== $.activeRecording &&
            this.emitWhenConnected(
              RoomEvent.RecordingStatusChanged,
              $.activeRecording
            );
      }),
      (this.handleConnectionQualityUpdate = ($) => {
        $.updates.forEach((W) => {
          if (W.participantSid === this.localParticipant.sid) {
            this.localParticipant.setConnectionQuality(W.quality);
            return;
          }
          const K = this.getRemoteParticipantBySid(W.participantSid);
          K && K.setConnectionQuality(W.quality);
        });
      }),
      (this.onLocalParticipantMetadataChanged = ($) => {
        this.emit(
          RoomEvent.ParticipantMetadataChanged,
          $,
          this.localParticipant
        );
      }),
      (this.onLocalParticipantNameChanged = ($) => {
        this.emit(RoomEvent.ParticipantNameChanged, $, this.localParticipant);
      }),
      (this.onLocalAttributesChanged = ($) => {
        this.emit(
          RoomEvent.ParticipantAttributesChanged,
          $,
          this.localParticipant
        );
      }),
      (this.onLocalTrackMuted = ($) => {
        this.emit(RoomEvent.TrackMuted, $, this.localParticipant);
      }),
      (this.onLocalTrackUnmuted = ($) => {
        this.emit(RoomEvent.TrackUnmuted, $, this.localParticipant);
      }),
      (this.onTrackProcessorUpdate = ($) => {
        var W;
        (W = $ == null ? void 0 : $.onPublish) === null ||
          W === void 0 ||
          W.call($, this);
      }),
      (this.onLocalTrackPublished = ($) =>
        __awaiter$b(this, void 0, void 0, function* () {
          var W, K, G, H, Q, z;
          (W = $.track) === null ||
            W === void 0 ||
            W.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate),
            (K = $.track) === null ||
              K === void 0 ||
              K.on(TrackEvent.Restarted, this.onLocalTrackRestarted),
            (Q =
              (H =
                (G = $.track) === null || G === void 0
                  ? void 0
                  : G.getProcessor()) === null || H === void 0
                ? void 0
                : H.onPublish) === null ||
              Q === void 0 ||
              Q.call(H, this),
            this.emit(RoomEvent.LocalTrackPublished, $, this.localParticipant),
            isLocalAudioTrack($.track) &&
              (yield $.track.checkForSilence()) &&
              this.emit(RoomEvent.LocalAudioSilenceDetected, $);
          const Y = yield (z = $.track) === null || z === void 0
              ? void 0
              : z.getDeviceId(!1),
            X = sourceToKind($.source);
          X &&
            Y &&
            Y !== this.localParticipant.activeDeviceMap.get(X) &&
            (this.localParticipant.activeDeviceMap.set(X, Y),
            this.emit(RoomEvent.ActiveDeviceChanged, X, Y));
        })),
      (this.onLocalTrackUnpublished = ($) => {
        var W, K;
        (W = $.track) === null ||
          W === void 0 ||
          W.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate),
          (K = $.track) === null ||
            K === void 0 ||
            K.off(TrackEvent.Restarted, this.onLocalTrackRestarted),
          this.emit(RoomEvent.LocalTrackUnpublished, $, this.localParticipant);
      }),
      (this.onLocalTrackRestarted = ($) =>
        __awaiter$b(this, void 0, void 0, function* () {
          const W = yield $.getDeviceId(!1),
            K = sourceToKind($.source);
          K &&
            W &&
            W !== this.localParticipant.activeDeviceMap.get(K) &&
            (this.log.debug(
              "local track restarted, setting "
                .concat(K, " ")
                .concat(W, " active"),
              this.logContext
            ),
            this.localParticipant.activeDeviceMap.set(K, W),
            this.emit(RoomEvent.ActiveDeviceChanged, K, W));
        })),
      (this.onLocalConnectionQualityChanged = ($) => {
        this.emit(RoomEvent.ConnectionQualityChanged, $, this.localParticipant);
      }),
      (this.onMediaDevicesError = ($) => {
        this.emit(RoomEvent.MediaDevicesError, $);
      }),
      (this.onLocalParticipantPermissionsChanged = ($) => {
        this.emit(
          RoomEvent.ParticipantPermissionsChanged,
          $,
          this.localParticipant
        );
      }),
      (this.onLocalChatMessageSent = ($) => {
        this.emit(RoomEvent.ChatMessage, $, this.localParticipant);
      }),
      this.setMaxListeners(100),
      (this.remoteParticipants = new Map()),
      (this.sidToIdentity = new Map()),
      (this.options = Object.assign(Object.assign({}, roomOptionDefaults), U)),
      (this.log = getLogger(
        (q = this.options.loggerName) !== null && q !== void 0
          ? q
          : LoggerNames.Room
      )),
      (this.transcriptionReceivedTimes = new Map()),
      (this.options.audioCaptureDefaults = Object.assign(
        Object.assign({}, audioDefaults),
        U == null ? void 0 : U.audioCaptureDefaults
      )),
      (this.options.videoCaptureDefaults = Object.assign(
        Object.assign({}, videoDefaults),
        U == null ? void 0 : U.videoCaptureDefaults
      )),
      (this.options.publishDefaults = Object.assign(
        Object.assign({}, publishDefaults),
        U == null ? void 0 : U.publishDefaults
      )),
      this.maybeCreateEngine(),
      (this.disconnectLock = new _$1()),
      (this.localParticipant = new LocalParticipant(
        "",
        "",
        this.engine,
        this.options,
        this.rpcHandlers
      )),
      this.options.videoCaptureDefaults.deviceId &&
        this.localParticipant.activeDeviceMap.set(
          "videoinput",
          unwrapConstraint(this.options.videoCaptureDefaults.deviceId)
        ),
      this.options.audioCaptureDefaults.deviceId &&
        this.localParticipant.activeDeviceMap.set(
          "audioinput",
          unwrapConstraint(this.options.audioCaptureDefaults.deviceId)
        ),
      !((j = this.options.audioOutput) === null || j === void 0) &&
        j.deviceId &&
        this.switchActiveDevice(
          "audiooutput",
          unwrapConstraint(this.options.audioOutput.deviceId)
        ).catch(($) =>
          this.log.warn(
            "Could not set audio output: ".concat($.message),
            this.logContext
          )
        ),
      this.options.e2ee && this.setupE2EE(),
      isWeb())
    ) {
      const $ = new AbortController();
      (V = navigator.mediaDevices) === null ||
        V === void 0 ||
        V.addEventListener("devicechange", this.handleDeviceChange, {
          signal: $.signal,
        }),
        Room.cleanupRegistry &&
          Room.cleanupRegistry.register(this, () => {
            $.abort();
          });
    }
  }
  registerTextStreamHandler(U, F) {
    if (this.textStreamHandlers.has(U))
      throw new TypeError(
        'A text stream handler for topic "'.concat(U, '" has already been set.')
      );
    this.textStreamHandlers.set(U, F);
  }
  unregisterTextStreamHandler(U) {
    this.textStreamHandlers.delete(U);
  }
  registerByteStreamHandler(U, F) {
    if (this.byteStreamHandlers.has(U))
      throw new TypeError(
        'A byte stream handler for topic "'.concat(U, '" has already been set.')
      );
    this.byteStreamHandlers.set(U, F);
  }
  unregisterByteStreamHandler(U) {
    this.byteStreamHandlers.delete(U);
  }
  registerRpcMethod(U, F) {
    if (this.rpcHandlers.has(U))
      throw Error(
        "RPC handler already registered for method ".concat(
          U,
          ", unregisterRpcMethod before trying to register again"
        )
      );
    this.rpcHandlers.set(U, F);
  }
  unregisterRpcMethod(U) {
    this.rpcHandlers.delete(U);
  }
  handleIncomingRpcRequest(U, F, q, j, V, $) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if ((yield this.engine.publishRpcAck(U, F), $ !== 1)) {
        yield this.engine.publishRpcResponse(
          U,
          F,
          null,
          RpcError.builtIn("UNSUPPORTED_VERSION")
        );
        return;
      }
      const W = this.rpcHandlers.get(q);
      if (!W) {
        yield this.engine.publishRpcResponse(
          U,
          F,
          null,
          RpcError.builtIn("UNSUPPORTED_METHOD")
        );
        return;
      }
      let K = null,
        G = null;
      try {
        const H = yield W({
          requestId: F,
          callerIdentity: U,
          payload: j,
          responseTimeout: V,
        });
        byteLength(H) > MAX_PAYLOAD_BYTES
          ? ((K = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE")),
            console.warn("RPC Response payload too large for ".concat(q)))
          : (G = H);
      } catch (H) {
        H instanceof RpcError
          ? (K = H)
          : (console.warn(
              "Uncaught error returned by RPC handler for ".concat(
                q,
                ". Returning APPLICATION_ERROR instead."
              ),
              H
            ),
            (K = RpcError.builtIn("APPLICATION_ERROR")));
      }
      yield this.engine.publishRpcResponse(U, F, G, K);
    });
  }
  setE2EEEnabled(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(U)]),
          this.localParticipant.identity !== "" &&
            this.e2eeManager.setParticipantCryptorEnabled(
              U,
              this.localParticipant.identity
            );
      else
        throw Error(
          "e2ee not configured, please set e2ee settings within the room options"
        );
    });
  }
  setupE2EE() {
    var U;
    this.options.e2ee &&
      ("e2eeManager" in this.options.e2ee
        ? (this.e2eeManager = this.options.e2ee.e2eeManager)
        : (this.e2eeManager = new E2EEManager(this.options.e2ee)),
      this.e2eeManager.on(
        EncryptionEvent.ParticipantEncryptionStatusChanged,
        (F, q) => {
          isLocalParticipant(q) && (this.isE2EEEnabled = F),
            this.emit(RoomEvent.ParticipantEncryptionStatusChanged, F, q);
        }
      ),
      this.e2eeManager.on(EncryptionEvent.EncryptionError, (F) =>
        this.emit(RoomEvent.EncryptionError, F)
      ),
      (U = this.e2eeManager) === null || U === void 0 || U.setup(this));
  }
  get logContext() {
    var U;
    return {
      room: this.name,
      roomID: (U = this.roomInfo) === null || U === void 0 ? void 0 : U.sid,
      participant: this.localParticipant.identity,
      pID: this.localParticipant.sid,
    };
  }
  get isRecording() {
    var U, F;
    return (F =
      (U = this.roomInfo) === null || U === void 0
        ? void 0
        : U.activeRecording) !== null && F !== void 0
      ? F
      : !1;
  }
  getSid() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected
        ? ""
        : this.roomInfo && this.roomInfo.sid !== ""
        ? this.roomInfo.sid
        : new Promise((U, F) => {
            const q = (j) => {
              j.sid !== "" &&
                (this.engine.off(EngineEvent.RoomUpdate, q), U(j.sid));
            };
            this.engine.on(EngineEvent.RoomUpdate, q),
              this.once(RoomEvent.Disconnected, () => {
                this.engine.off(EngineEvent.RoomUpdate, q),
                  F("Room disconnected before room server id was available");
              });
          });
    });
  }
  get name() {
    var U, F;
    return (F =
      (U = this.roomInfo) === null || U === void 0 ? void 0 : U.name) !==
      null && F !== void 0
      ? F
      : "";
  }
  get metadata() {
    var U;
    return (U = this.roomInfo) === null || U === void 0 ? void 0 : U.metadata;
  }
  get numParticipants() {
    var U, F;
    return (F =
      (U = this.roomInfo) === null || U === void 0
        ? void 0
        : U.numParticipants) !== null && F !== void 0
      ? F
      : 0;
  }
  get numPublishers() {
    var U, F;
    return (F =
      (U = this.roomInfo) === null || U === void 0
        ? void 0
        : U.numPublishers) !== null && F !== void 0
      ? F
      : 0;
  }
  maybeCreateEngine() {
    (this.engine && !this.engine.isClosed) ||
      ((this.engine = new RTCEngine(this.options)),
      this.engine
        .on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates)
        .on(EngineEvent.RoomUpdate, this.handleRoomUpdate)
        .on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged)
        .on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate)
        .on(
          EngineEvent.ConnectionQualityUpdate,
          this.handleConnectionQualityUpdate
        )
        .on(EngineEvent.SubscriptionError, this.handleSubscriptionError)
        .on(
          EngineEvent.SubscriptionPermissionUpdate,
          this.handleSubscriptionPermissionUpdate
        )
        .on(EngineEvent.MediaTrackAdded, (U, F, q) => {
          this.onTrackAdded(U, F, q);
        })
        .on(EngineEvent.Disconnected, (U) => {
          this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, U);
        })
        .on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate)
        .on(EngineEvent.DataPacketReceived, this.handleDataPacket)
        .on(EngineEvent.Resuming, () => {
          this.clearConnectionReconcile(),
            (this.isResuming = !0),
            this.log.info("Resuming signal connection", this.logContext),
            this.setAndEmitConnectionState(
              ConnectionState.SignalReconnecting
            ) && this.emit(RoomEvent.SignalReconnecting);
        })
        .on(EngineEvent.Resumed, () => {
          this.registerConnectionReconcile(),
            (this.isResuming = !1),
            this.log.info("Resumed signal connection", this.logContext),
            this.updateSubscriptions(),
            this.emitBufferedEvents(),
            this.setAndEmitConnectionState(ConnectionState.Connected) &&
              this.emit(RoomEvent.Reconnected);
        })
        .on(EngineEvent.SignalResumed, () => {
          (this.bufferedEvents = []),
            (this.state === ConnectionState.Reconnecting || this.isResuming) &&
              this.sendSyncState();
        })
        .on(EngineEvent.Restarting, this.handleRestarting)
        .on(EngineEvent.SignalRestarted, this.handleSignalRestarted)
        .on(EngineEvent.Offline, () => {
          this.setAndEmitConnectionState(ConnectionState.Reconnecting) &&
            this.emit(RoomEvent.Reconnecting);
        })
        .on(EngineEvent.DCBufferStatusChanged, (U, F) => {
          this.emit(RoomEvent.DCBufferStatusChanged, U, F);
        })
        .on(EngineEvent.LocalTrackSubscribed, (U) => {
          const F = this.localParticipant.getTrackPublications().find((q) => {
            let { trackSid: j } = q;
            return j === U;
          });
          if (!F) {
            this.log.warn(
              "could not find local track subscription for subscribed event",
              this.logContext
            );
            return;
          }
          this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, F),
            this.emitWhenConnected(
              RoomEvent.LocalTrackSubscribed,
              F,
              this.localParticipant
            );
        }),
      this.localParticipant && this.localParticipant.setupEngine(this.engine),
      this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  static getLocalDevices(U) {
    let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(U, F);
  }
  prepareConnection(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(U), this.logContext);
        try {
          if (isCloud(new URL(U)) && F) {
            this.regionUrlProvider = new RegionUrlProvider(U, F);
            const q = yield this.regionUrlProvider.getNextBestRegionUrl();
            q &&
              this.state === ConnectionState.Disconnected &&
              ((this.regionUrl = q),
              yield fetch(toHttpUrl(q), { method: "HEAD" }),
              this.log.debug(
                "prepared connection to ".concat(q),
                this.logContext
              ));
          } else yield fetch(toHttpUrl(U), { method: "HEAD" });
        } catch (q) {
          this.log.warn(
            "could not prepare connection",
            Object.assign(Object.assign({}, this.logContext), { error: q })
          );
        }
      }
    });
  }
  getParticipantByIdentity(U) {
    return this.localParticipant.identity === U
      ? this.localParticipant
      : this.remoteParticipants.get(U);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  simulateScenario(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let q = () => {},
        j;
      switch (U) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          j = new SimulateScenario({
            scenario: { case: "speakerUpdate", value: 3 },
          });
          break;
        case "node-failure":
          j = new SimulateScenario({
            scenario: { case: "nodeFailure", value: !0 },
          });
          break;
        case "server-leave":
          j = new SimulateScenario({
            scenario: { case: "serverLeave", value: !0 },
          });
          break;
        case "migration":
          j = new SimulateScenario({
            scenario: { case: "migration", value: !0 },
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(),
            yield this.engine.client.handleOnClose(
              "simulate resume-disconnect"
            );
          break;
        case "disconnect-signal-on-resume":
          (q = () =>
            __awaiter$b(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose(
                "simulate resume-disconnect"
              );
            })),
            (j = new SimulateScenario({
              scenario: { case: "disconnectSignalOnResume", value: !0 },
            }));
          break;
        case "disconnect-signal-on-resume-no-messages":
          (q = () =>
            __awaiter$b(this, void 0, void 0, function* () {
              yield this.engine.client.handleOnClose(
                "simulate resume-disconnect"
              );
            })),
            (j = new SimulateScenario({
              scenario: {
                case: "disconnectSignalOnResumeNoMessages",
                value: !0,
              },
            }));
          break;
        case "full-reconnect":
          (this.engine.fullReconnectOnNext = !0),
            yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          (j = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: U === "force-tls" ? 2 : 1,
            },
          })),
            (q = () =>
              __awaiter$b(this, void 0, void 0, function* () {
                const V = this.engine.client.onLeave;
                V &&
                  V(
                    new LeaveRequest({
                      reason: DisconnectReason.CLIENT_INITIATED,
                      action: LeaveRequest_Action.RECONNECT,
                    })
                  );
              }));
          break;
        case "subscriber-bandwidth":
          if (F === void 0 || typeof F != "number")
            throw new Error(
              "subscriber-bandwidth requires a number as argument"
            );
          j = new SimulateScenario({
            scenario: { case: "subscriberBandwidth", value: numberToBigInt(F) },
          });
          break;
        case "leave-full-reconnect":
          j = new SimulateScenario({
            scenario: { case: "leaveRequestFullReconnect", value: !0 },
          });
      }
      j && (yield this.engine.client.sendSimulateScenario(j), yield q());
    });
  }
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(U) {
    return this.localParticipant.activeDeviceMap.get(U);
  }
  switchActiveDevice(U, F) {
    return __awaiter$b(this, arguments, void 0, function (q, j) {
      var V = this;
      let $ =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      return (function* () {
        var W, K, G, H, Q, z, Y, X;
        let Z = !0,
          se = !1;
        const ee = $ ? { exact: j } : j;
        if (q === "audioinput") {
          se = V.localParticipant.audioTrackPublications.size === 0;
          const ie =
            (W = V.getActiveDevice(q)) !== null && W !== void 0
              ? W
              : V.options.audioCaptureDefaults.deviceId;
          V.options.audioCaptureDefaults.deviceId = ee;
          const re = Array.from(
            V.localParticipant.audioTrackPublications.values()
          ).filter((te) => te.source === Track.Source.Microphone);
          try {
            Z = (yield Promise.all(
              re.map((te) => {
                var ne;
                return (ne = te.audioTrack) === null || ne === void 0
                  ? void 0
                  : ne.setDeviceId(ee);
              })
            )).every((te) => te === !0);
          } catch (te) {
            throw ((V.options.audioCaptureDefaults.deviceId = ie), te);
          }
        } else if (q === "videoinput") {
          se = V.localParticipant.videoTrackPublications.size === 0;
          const ie =
            (K = V.getActiveDevice(q)) !== null && K !== void 0
              ? K
              : V.options.videoCaptureDefaults.deviceId;
          V.options.videoCaptureDefaults.deviceId = ee;
          const re = Array.from(
            V.localParticipant.videoTrackPublications.values()
          ).filter((te) => te.source === Track.Source.Camera);
          try {
            Z = (yield Promise.all(
              re.map((te) => {
                var ne;
                return (ne = te.videoTrack) === null || ne === void 0
                  ? void 0
                  : ne.setDeviceId(ee);
              })
            )).every((te) => te === !0);
          } catch (te) {
            throw ((V.options.videoCaptureDefaults.deviceId = ie), te);
          }
        } else if (q === "audiooutput") {
          if (
            (!supportsSetSinkId() && !V.options.webAudioMix) ||
            (V.options.webAudioMix &&
              V.audioContext &&
              !("setSinkId" in V.audioContext))
          )
            throw new Error(
              "cannot switch audio output, setSinkId not supported"
            );
          V.options.webAudioMix &&
            (j =
              (G = yield DeviceManager.getInstance().normalizeDeviceId(
                "audiooutput",
                j
              )) !== null && G !== void 0
                ? G
                : ""),
            ((H = (X = V.options).audioOutput) !== null && H !== void 0) ||
              (X.audioOutput = {});
          const ie =
            (Q = V.getActiveDevice(q)) !== null && Q !== void 0
              ? Q
              : V.options.audioOutput.deviceId;
          V.options.audioOutput.deviceId = j;
          try {
            V.options.webAudioMix &&
              ((z = V.audioContext) === null || z === void 0 || z.setSinkId(j)),
              yield Promise.all(
                Array.from(V.remoteParticipants.values()).map((re) =>
                  re.setAudioOutput({ deviceId: j })
                )
              );
          } catch (re) {
            throw ((V.options.audioOutput.deviceId = ie), re);
          }
        }
        return (
          (se || q === "audiooutput") &&
            (V.localParticipant.activeDeviceMap.set(
              q,
              (q === "audiooutput" &&
                ((Y = V.options.audioOutput) === null || Y === void 0
                  ? void 0
                  : Y.deviceId)) ||
                j
            ),
            V.emit(RoomEvent.ActiveDeviceChanged, q, j)),
          Z
        );
      })();
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant
      .on(
        ParticipantEvent.ParticipantMetadataChanged,
        this.onLocalParticipantMetadataChanged
      )
      .on(
        ParticipantEvent.ParticipantNameChanged,
        this.onLocalParticipantNameChanged
      )
      .on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged)
      .on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
      .on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
      .on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished)
      .on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished)
      .on(
        ParticipantEvent.ConnectionQualityChanged,
        this.onLocalConnectionQualityChanged
      )
      .on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
      .on(ParticipantEvent.AudioStreamAcquired, this.startAudio)
      .on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
      .on(
        ParticipantEvent.ParticipantPermissionsChanged,
        this.onLocalParticipantPermissionsChanged
      );
  }
  recreateEngine() {
    var U;
    (U = this.engine) === null || U === void 0 || U.close(),
      (this.engine = void 0),
      (this.isResuming = !1),
      this.remoteParticipants.clear(),
      this.sidToIdentity.clear(),
      (this.bufferedEvents = []),
      this.maybeCreateEngine();
  }
  onTrackAdded(U, F, q) {
    if (
      this.state === ConnectionState.Connecting ||
      this.state === ConnectionState.Reconnecting
    ) {
      const H = () => {
          this.onTrackAdded(U, F, q), Q();
        },
        Q = () => {
          this.off(RoomEvent.Reconnected, H),
            this.off(RoomEvent.Connected, H),
            this.off(RoomEvent.Disconnected, Q);
        };
      this.once(RoomEvent.Reconnected, H),
        this.once(RoomEvent.Connected, H),
        this.once(RoomEvent.Disconnected, Q);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn(
        "skipping incoming track after Room disconnected",
        this.logContext
      );
      return;
    }
    if (U.readyState === "ended") {
      this.log.info(
        "skipping incoming track as it already ended",
        this.logContext
      );
      return;
    }
    const j = unpackStreamId(F.id),
      V = j[0];
    let $ = j[1],
      W = U.id;
    if (($ && $.startsWith("TR") && (W = $), V === this.localParticipant.sid)) {
      this.log.warn(
        "tried to create RemoteParticipant for local participant",
        this.logContext
      );
      return;
    }
    const K = Array.from(this.remoteParticipants.values()).find(
      (H) => H.sid === V
    );
    if (!K) {
      this.log.error(
        "Tried to add a track for a participant, that's not present. Sid: ".concat(
          V
        ),
        this.logContext
      );
      return;
    }
    let G;
    this.options.adaptiveStream &&
      (typeof this.options.adaptiveStream == "object"
        ? (G = this.options.adaptiveStream)
        : (G = {})),
      K.addSubscribedMediaTrack(U, W, F, q, G);
  }
  handleDisconnect() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0,
      F = arguments.length > 1 ? arguments[1] : void 0;
    var q;
    if (
      (this.clearConnectionReconcile(),
      (this.isResuming = !1),
      (this.bufferedEvents = []),
      this.transcriptionReceivedTimes.clear(),
      this.state !== ConnectionState.Disconnected)
    ) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((j) => {
          j.trackPublications.forEach((V) => {
            j.unpublishTrack(V.trackSid);
          });
        }),
          this.localParticipant.trackPublications.forEach((j) => {
            var V, $, W;
            j.track && this.localParticipant.unpublishTrack(j.track, U),
              U
                ? ((V = j.track) === null || V === void 0 || V.detach(),
                  ($ = j.track) === null || $ === void 0 || $.stop())
                : (W = j.track) === null || W === void 0 || W.stopMonitor();
          }),
          this.localParticipant
            .off(
              ParticipantEvent.ParticipantMetadataChanged,
              this.onLocalParticipantMetadataChanged
            )
            .off(
              ParticipantEvent.ParticipantNameChanged,
              this.onLocalParticipantNameChanged
            )
            .off(
              ParticipantEvent.AttributesChanged,
              this.onLocalAttributesChanged
            )
            .off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
            .off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
            .off(
              ParticipantEvent.LocalTrackPublished,
              this.onLocalTrackPublished
            )
            .off(
              ParticipantEvent.LocalTrackUnpublished,
              this.onLocalTrackUnpublished
            )
            .off(
              ParticipantEvent.ConnectionQualityChanged,
              this.onLocalConnectionQualityChanged
            )
            .off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
            .off(ParticipantEvent.AudioStreamAcquired, this.startAudio)
            .off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
            .off(
              ParticipantEvent.ParticipantPermissionsChanged,
              this.onLocalParticipantPermissionsChanged
            ),
          this.localParticipant.trackPublications.clear(),
          this.localParticipant.videoTrackPublications.clear(),
          this.localParticipant.audioTrackPublications.clear(),
          this.remoteParticipants.clear(),
          this.sidToIdentity.clear(),
          (this.activeSpeakers = []),
          this.audioContext &&
            typeof this.options.webAudioMix == "boolean" &&
            (this.audioContext.close(), (this.audioContext = void 0)),
          isWeb() &&
            (window.removeEventListener("beforeunload", this.onPageLeave),
            window.removeEventListener("pagehide", this.onPageLeave),
            window.removeEventListener("freeze", this.onPageLeave),
            (q = navigator.mediaDevices) === null ||
              q === void 0 ||
              q.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected),
          this.emit(RoomEvent.Disconnected, F);
      }
    }
  }
  handleParticipantDisconnected(U, F) {
    var q;
    this.remoteParticipants.delete(U),
      F &&
        (F.trackPublications.forEach((j) => {
          F.unpublishTrack(j.trackSid, !0);
        }),
        this.emit(RoomEvent.ParticipantDisconnected, F),
        (q = this.localParticipant) === null ||
          q === void 0 ||
          q.handleParticipantDisconnected(F.identity));
  }
  handleStreamHeader(U, F) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var q;
      if (U.contentHeader.case === "byteHeader") {
        const j = this.byteStreamHandlers.get(U.topic);
        if (!j) {
          this.log.debug(
            "ignoring incoming byte stream due to no handler for topic",
            U.topic
          );
          return;
        }
        let V;
        const $ = {
            id: U.streamId,
            name:
              (q = U.contentHeader.value.name) !== null && q !== void 0
                ? q
                : "unknown",
            mimeType: U.mimeType,
            size: U.totalLength ? Number(U.totalLength) : void 0,
            topic: U.topic,
            timestamp: bigIntToNumber(U.timestamp),
            attributes: U.attributes,
          },
          W = new ReadableStream({
            start: (K) => {
              (V = K),
                this.byteStreamControllers.set(U.streamId, {
                  info: $,
                  controller: V,
                  startTime: Date.now(),
                });
            },
          });
        j(new ByteStreamReader($, W, bigIntToNumber(U.totalLength)), {
          identity: F,
        });
      } else if (U.contentHeader.case === "textHeader") {
        const j = this.textStreamHandlers.get(U.topic);
        if (!j) {
          this.log.debug(
            "ignoring incoming text stream due to no handler for topic",
            U.topic
          );
          return;
        }
        let V;
        const $ = {
            id: U.streamId,
            mimeType: U.mimeType,
            size: U.totalLength ? Number(U.totalLength) : void 0,
            topic: U.topic,
            timestamp: Number(U.timestamp),
            attributes: U.attributes,
          },
          W = new ReadableStream({
            start: (K) => {
              (V = K),
                this.textStreamControllers.set(U.streamId, {
                  info: $,
                  controller: V,
                  startTime: Date.now(),
                });
            },
          });
        j(new TextStreamReader($, W, bigIntToNumber(U.totalLength)), {
          identity: F,
        });
      }
    });
  }
  handleStreamChunk(U) {
    const F = this.byteStreamControllers.get(U.streamId);
    F && U.content.length > 0 && F.controller.enqueue(U);
    const q = this.textStreamControllers.get(U.streamId);
    q && U.content.length > 0 && q.controller.enqueue(U);
  }
  handleStreamTrailer(U) {
    const F = this.textStreamControllers.get(U.streamId);
    F &&
      ((F.info.attributes = Object.assign(
        Object.assign({}, F.info.attributes),
        U.attributes
      )),
      F.controller.close(),
      this.textStreamControllers.delete(U.streamId));
    const q = this.byteStreamControllers.get(U.streamId);
    q &&
      ((q.info.attributes = Object.assign(
        Object.assign({}, q.info.attributes),
        U.attributes
      )),
      q.controller.close(),
      this.byteStreamControllers.delete(U.streamId));
  }
  acquireAudioContext() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U, F;
      if (
        (typeof this.options.webAudioMix != "boolean" &&
        this.options.webAudioMix.audioContext
          ? (this.audioContext = this.options.webAudioMix.audioContext)
          : (!this.audioContext || this.audioContext.state === "closed") &&
            (this.audioContext =
              (U = getNewAudioContext()) !== null && U !== void 0 ? U : void 0),
        this.options.webAudioMix &&
          this.remoteParticipants.forEach((j) =>
            j.setAudioContext(this.audioContext)
          ),
        this.localParticipant.setAudioContext(this.audioContext),
        this.audioContext && this.audioContext.state === "suspended")
      )
        try {
          yield Promise.race([this.audioContext.resume(), sleep$1(200)]);
        } catch (j) {
          this.log.warn(
            "Could not resume audio context",
            Object.assign(Object.assign({}, this.logContext), { error: j })
          );
        }
      const q =
        ((F = this.audioContext) === null || F === void 0
          ? void 0
          : F.state) === "running";
      q !== this.canPlaybackAudio &&
        ((this.audioEnabled = q),
        this.emit(RoomEvent.AudioPlaybackStatusChanged, q));
    });
  }
  createParticipant(U, F) {
    var q;
    let j;
    return (
      F
        ? (j = RemoteParticipant.fromParticipantInfo(this.engine.client, F, {
            loggerContextCb: () => this.logContext,
            loggerName: this.options.loggerName,
          }))
        : (j = new RemoteParticipant(
            this.engine.client,
            "",
            U,
            void 0,
            void 0,
            void 0,
            {
              loggerContextCb: () => this.logContext,
              loggerName: this.options.loggerName,
            }
          )),
      this.options.webAudioMix && j.setAudioContext(this.audioContext),
      !((q = this.options.audioOutput) === null || q === void 0) &&
        q.deviceId &&
        j
          .setAudioOutput(this.options.audioOutput)
          .catch((V) =>
            this.log.warn(
              "Could not set audio output: ".concat(V.message),
              this.logContext
            )
          ),
      j
    );
  }
  getOrCreateParticipant(U, F) {
    if (this.remoteParticipants.has(U)) {
      const j = this.remoteParticipants.get(U);
      return (
        F && j.updateInfo(F) && this.sidToIdentity.set(F.sid, F.identity), j
      );
    }
    const q = this.createParticipant(U, F);
    return (
      this.remoteParticipants.set(U, q),
      this.sidToIdentity.set(F.sid, F.identity),
      this.emitWhenConnected(RoomEvent.ParticipantConnected, q),
      q
        .on(ParticipantEvent.TrackPublished, (j) => {
          this.emitWhenConnected(RoomEvent.TrackPublished, j, q);
        })
        .on(ParticipantEvent.TrackSubscribed, (j, V) => {
          j.kind === Track.Kind.Audio
            ? (j.on(
                TrackEvent.AudioPlaybackStarted,
                this.handleAudioPlaybackStarted
              ),
              j.on(
                TrackEvent.AudioPlaybackFailed,
                this.handleAudioPlaybackFailed
              ))
            : j.kind === Track.Kind.Video &&
              (j.on(
                TrackEvent.VideoPlaybackFailed,
                this.handleVideoPlaybackFailed
              ),
              j.on(
                TrackEvent.VideoPlaybackStarted,
                this.handleVideoPlaybackStarted
              )),
            this.emit(RoomEvent.TrackSubscribed, j, V, q);
        })
        .on(ParticipantEvent.TrackUnpublished, (j) => {
          this.emit(RoomEvent.TrackUnpublished, j, q);
        })
        .on(ParticipantEvent.TrackUnsubscribed, (j, V) => {
          this.emit(RoomEvent.TrackUnsubscribed, j, V, q);
        })
        .on(ParticipantEvent.TrackMuted, (j) => {
          this.emitWhenConnected(RoomEvent.TrackMuted, j, q);
        })
        .on(ParticipantEvent.TrackUnmuted, (j) => {
          this.emitWhenConnected(RoomEvent.TrackUnmuted, j, q);
        })
        .on(ParticipantEvent.ParticipantMetadataChanged, (j) => {
          this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, j, q);
        })
        .on(ParticipantEvent.ParticipantNameChanged, (j) => {
          this.emitWhenConnected(RoomEvent.ParticipantNameChanged, j, q);
        })
        .on(ParticipantEvent.AttributesChanged, (j) => {
          this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, j, q);
        })
        .on(ParticipantEvent.ConnectionQualityChanged, (j) => {
          this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, j, q);
        })
        .on(ParticipantEvent.ParticipantPermissionsChanged, (j) => {
          this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, j, q);
        })
        .on(ParticipantEvent.TrackSubscriptionStatusChanged, (j, V) => {
          this.emitWhenConnected(
            RoomEvent.TrackSubscriptionStatusChanged,
            j,
            V,
            q
          );
        })
        .on(ParticipantEvent.TrackSubscriptionFailed, (j, V) => {
          this.emit(RoomEvent.TrackSubscriptionFailed, j, q, V);
        })
        .on(ParticipantEvent.TrackSubscriptionPermissionChanged, (j, V) => {
          this.emitWhenConnected(
            RoomEvent.TrackSubscriptionPermissionChanged,
            j,
            V,
            q
          );
        }),
      F && q.updateInfo(F),
      q
    );
  }
  sendSyncState() {
    const U = Array.from(this.remoteParticipants.values()).reduce(
        (q, j) => (q.push(...j.getTrackPublications()), q),
        []
      ),
      F = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(U, F);
  }
  updateSubscriptions() {
    for (const U of this.remoteParticipants.values())
      for (const F of U.videoTrackPublications.values())
        F.isSubscribed && isRemotePub(F) && F.emitTrackUpdate();
  }
  getRemoteParticipantBySid(U) {
    const F = this.sidToIdentity.get(U);
    if (F) return this.remoteParticipants.get(F);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let U = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      !this.engine || this.engine.isClosed || !this.engine.verifyTransport()
        ? (U++,
          this.log.warn(
            "detected connection state mismatch",
            Object.assign(Object.assign({}, this.logContext), {
              numFailures: U,
              engine: this.engine
                ? {
                    closed: this.engine.isClosed,
                    transportsConnected: this.engine.verifyTransport(),
                  }
                : void 0,
            })
          ),
          U >= 3 &&
            (this.recreateEngine(),
            this.handleDisconnect(
              this.options.stopLocalTrackOnUnpublish,
              DisconnectReason.STATE_MISMATCH
            )))
        : (U = 0);
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval &&
      CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(U) {
    return U === this.state
      ? !1
      : ((this.state = U),
        this.emit(RoomEvent.ConnectionStateChanged, this.state),
        !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((U) => {
      let [F, q] = U;
      this.emit(F, ...q);
    }),
      (this.bufferedEvents = []);
  }
  emitWhenConnected(U) {
    for (
      var F = arguments.length, q = new Array(F > 1 ? F - 1 : 0), j = 1;
      j < F;
      j++
    )
      q[j - 1] = arguments[j];
    if (
      this.state === ConnectionState.Reconnecting ||
      this.isResuming ||
      !this.engine ||
      this.engine.pendingReconnect
    )
      this.bufferedEvents.push([U, q]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(U, ...q);
    return !1;
  }
  simulateParticipants(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q;
      const j = Object.assign(
          { audio: !0, video: !0, useRealTracks: !1 },
          U.publish
        ),
        V = Object.assign(
          { count: 9, audio: !1, video: !0, aspectRatios: [1.66, 1.7, 1.3] },
          U.participants
        );
      if (
        (this.handleDisconnect(),
        (this.roomInfo = new Room$1({
          sid: "RM_SIMULATED",
          name: "simulated-room",
          emptyTimeout: 0,
          maxParticipants: 0,
          creationTime: protoInt64.parse(new Date().getTime()),
          metadata: "",
          numParticipants: 1,
          numPublishers: 1,
          turnPassword: "",
          enabledCodecs: [],
          activeRecording: !1,
        })),
        this.localParticipant.updateInfo(
          new ParticipantInfo({
            identity: "simulated-local",
            name: "local-name",
          })
        ),
        this.setupLocalParticipantEvents(),
        this.emit(RoomEvent.SignalConnected),
        this.emit(RoomEvent.Connected),
        this.setAndEmitConnectionState(ConnectionState.Connected),
        j.video)
      ) {
        const $ = new LocalTrackPublication(
          Track.Kind.Video,
          new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO,
            name: "video-dummy",
          }),
          new LocalVideoTrack(
            j.useRealTracks
              ? (yield window.navigator.mediaDevices.getUserMedia({
                  video: !0,
                })).getVideoTracks()[0]
              : createDummyVideoStreamTrack(
                  160 *
                    ((F = V.aspectRatios[0]) !== null && F !== void 0 ? F : 1),
                  160,
                  !0,
                  !0
                ),
            void 0,
            !1,
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          ),
          {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext,
          }
        );
        this.localParticipant.addTrackPublication($),
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, $);
      }
      if (j.audio) {
        const $ = new LocalTrackPublication(
          Track.Kind.Audio,
          new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO,
          }),
          new LocalAudioTrack(
            j.useRealTracks
              ? (yield navigator.mediaDevices.getUserMedia({
                  audio: !0,
                })).getAudioTracks()[0]
              : getEmptyAudioStreamTrack(),
            void 0,
            !1,
            this.audioContext,
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          ),
          {
            loggerName: this.options.loggerName,
            loggerContextCb: () => this.logContext,
          }
        );
        this.localParticipant.addTrackPublication($),
          this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, $);
      }
      for (let $ = 0; $ < V.count - 1; $ += 1) {
        let W = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat($),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now()),
        });
        const K = this.getOrCreateParticipant(W.identity, W);
        if (V.video) {
          const G = createDummyVideoStreamTrack(
              160 *
                ((q = V.aspectRatios[$ % V.aspectRatios.length]) !== null &&
                q !== void 0
                  ? q
                  : 1),
              160,
              !1,
              !0
            ),
            H = new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO,
            });
          K.addSubscribedMediaTrack(
            G,
            H.sid,
            new MediaStream([G]),
            new RTCRtpReceiver()
          ),
            (W.tracks = [...W.tracks, H]);
        }
        if (V.audio) {
          const G = getEmptyAudioStreamTrack(),
            H = new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO,
            });
          K.addSubscribedMediaTrack(
            G,
            H.sid,
            new MediaStream([G]),
            new RTCRtpReceiver()
          ),
            (W.tracks = [...W.tracks, H]);
        }
        K.updateInfo(W);
      }
    });
  }
  emit(U) {
    for (
      var F = arguments.length, q = new Array(F > 1 ? F - 1 : 0), j = 1;
      j < F;
      j++
    )
      q[j - 1] = arguments[j];
    if (
      U !== RoomEvent.ActiveSpeakersChanged &&
      U !== RoomEvent.TranscriptionReceived
    ) {
      const V = mapArgs(q).filter(($) => $ !== void 0);
      this.log.debug(
        "room event ".concat(U),
        Object.assign(Object.assign({}, this.logContext), { event: U, args: V })
      );
    }
    return super.emit(U, ...q);
  }
}
Room.cleanupRegistry =
  typeof FinalizationRegistry < "u" &&
  new FinalizationRegistry((B) => {
    B();
  });
function mapArgs(B) {
  return B.map((U) => {
    if (U)
      return Array.isArray(U)
        ? mapArgs(U)
        : typeof U == "object"
        ? "logContext" in U
          ? U.logContext
          : void 0
        : U;
  });
}
var CheckStatus;
(function (B) {
  (B[(B.IDLE = 0)] = "IDLE"),
    (B[(B.RUNNING = 1)] = "RUNNING"),
    (B[(B.SKIPPED = 2)] = "SKIPPED"),
    (B[(B.SUCCESS = 3)] = "SUCCESS"),
    (B[(B.FAILED = 4)] = "FAILED");
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports$1.EventEmitter {
  constructor(U, F) {
    let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(),
      (this.status = CheckStatus.IDLE),
      (this.logs = []),
      (this.options = {}),
      (this.url = U),
      (this.token = F),
      (this.name = this.constructor.name),
      (this.room = new Room(q.roomOptions)),
      (this.connectOptions = q.connectOptions),
      (this.options = q);
  }
  run(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (F) {
        F instanceof Error &&
          (this.options.errorsAsWarnings
            ? this.appendWarning(F.message)
            : this.appendError(F.message));
      }
      return (
        yield this.disconnect(),
        yield new Promise((F) => setTimeout(F, 500)),
        this.status !== CheckStatus.SKIPPED &&
          this.setStatus(
            this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED
          ),
        U && U(),
        this.getInfo()
      );
    });
  }
  isSuccess() {
    return !this.logs.some((U) => U.level === "error");
  }
  connect(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected
        ? this.room
        : (U || (U = this.url),
          yield this.room.connect(U, this.token, this.connectOptions),
          this.room);
    });
  }
  disconnect() {
    return __awaiter$b(this, void 0, void 0, function* () {
      this.room &&
        this.room.state !== ConnectionState.Disconnected &&
        (yield this.room.disconnect(),
        yield new Promise((U) => setTimeout(U, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  switchProtocol(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      let F = !1,
        q = !1;
      if (
        (this.room.on(RoomEvent.Reconnecting, () => {
          F = !0;
        }),
        this.room.once(RoomEvent.Reconnected, () => {
          q = !0;
        }),
        this.room.simulateScenario("force-".concat(U)),
        yield new Promise((V) => setTimeout(V, 1e3)),
        !F)
      )
        return;
      const j = Date.now() + 1e4;
      for (; Date.now() < j; ) {
        if (q) return;
        yield sleep$1(100);
      }
      throw new Error(
        "Could not reconnect using ".concat(U, " protocol after 10 seconds")
      );
    });
  }
  appendMessage(U) {
    this.logs.push({ level: "info", message: U }),
      this.emit("update", this.getInfo());
  }
  appendWarning(U) {
    this.logs.push({ level: "warning", message: U }),
      this.emit("update", this.getInfo());
  }
  appendError(U) {
    this.logs.push({ level: "error", message: U }),
      this.emit("update", this.getInfo());
  }
  setStatus(U) {
    (this.status = U), this.emit("update", this.getInfo());
  }
  get engine() {
    var U;
    return (U = this.room) === null || U === void 0 ? void 0 : U.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description,
    };
  }
}
class CloudRegionCheck extends Checker {
  get description() {
    return "Cloud regions";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const U = new RegionUrlProvider(this.url, this.token);
      if (!U.isCloud()) {
        this.skip();
        return;
      }
      const F = [],
        q = new Set();
      for (let V = 0; V < 3; V++) {
        const $ = yield U.getNextBestRegionUrl();
        if (!$) break;
        if (q.has($)) continue;
        q.add($);
        const W = yield this.checkCloudRegion($);
        this.appendMessage(
          ""
            .concat(W.region, " RTT: ")
            .concat(W.rtt, "ms, duration: ")
            .concat(W.duration, "ms")
        ),
          F.push(W);
      }
      F.sort((V, $) => (V.duration - $.duration) * 0.5 + (V.rtt - $.rtt) * 0.5);
      const j = F[0];
      (this.bestStats = j),
        this.appendMessage("best Cloud region: ".concat(j.region));
    });
  }
  getInfo() {
    const U = super.getInfo();
    return (U.data = this.bestStats), U;
  }
  checkCloudRegion(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      var F, q;
      yield this.connect(U),
        this.options.protocol === "tcp" && (yield this.switchProtocol("tcp"));
      const j =
        (F = this.room.serverInfo) === null || F === void 0 ? void 0 : F.region;
      if (!j) throw new Error("Region not found");
      const V = yield this.room.localParticipant.streamText({ topic: "test" }),
        $ = 1e3,
        K = 1e6 / $,
        G = "A".repeat($),
        H = Date.now();
      for (let X = 0; X < K; X++) yield V.write(G);
      yield V.close();
      const Q = Date.now(),
        z = yield (q = this.room.engine.pcManager) === null || q === void 0
          ? void 0
          : q.publisher.getStats(),
        Y = { region: j, rtt: 1e4, duration: Q - H };
      return (
        z == null ||
          z.forEach((X) => {
            X.type === "candidate-pair" &&
              X.nominated &&
              (Y.rtt = X.currentRoundTripTime * 1e3);
          }),
        yield this.disconnect(),
        Y
      );
    });
  }
}
const TEST_DURATION = 1e4;
class ConnectionProtocolCheck extends Checker {
  get description() {
    return "Connection via UDP vs TCP";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const U = yield this.checkConnectionProtocol("udp"),
        F = yield this.checkConnectionProtocol("tcp");
      (this.bestStats = U),
        U.qualityLimitationDurations.bandwidth -
          F.qualityLimitationDurations.bandwidth >
          0.5 || (U.packetsLost - F.packetsLost) / U.packetsSent > 0.01
          ? (this.appendMessage("best connection quality via tcp"),
            (this.bestStats = F))
          : this.appendMessage("best connection quality via udp");
      const q = this.bestStats;
      this.appendMessage(
        "upstream bitrate: ".concat(
          (q.bitrateTotal / q.count / 1e3 / 1e3).toFixed(2),
          " mbps"
        )
      ),
        this.appendMessage(
          "RTT: ".concat(((q.rttTotal / q.count) * 1e3).toFixed(2), " ms")
        ),
        this.appendMessage(
          "jitter: ".concat(((q.jitterTotal / q.count) * 1e3).toFixed(2), " ms")
        ),
        q.packetsLost > 0 &&
          this.appendWarning(
            "packets lost: ".concat(
              ((q.packetsLost / q.packetsSent) * 100).toFixed(2),
              "%"
            )
          ),
        q.qualityLimitationDurations.bandwidth > 1 &&
          this.appendWarning(
            "bandwidth limited ".concat(
              (
                (q.qualityLimitationDurations.bandwidth /
                  (TEST_DURATION / 1e3)) *
                100
              ).toFixed(2),
              "%"
            )
          ),
        q.qualityLimitationDurations.cpu > 0 &&
          this.appendWarning(
            "cpu limited ".concat(
              (
                (q.qualityLimitationDurations.cpu / (TEST_DURATION / 1e3)) *
                100
              ).toFixed(2),
              "%"
            )
          );
    });
  }
  getInfo() {
    const U = super.getInfo();
    return (U.data = this.bestStats), U;
  }
  checkConnectionProtocol(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      yield this.connect(),
        U === "tcp"
          ? yield this.switchProtocol("tcp")
          : yield this.switchProtocol("udp");
      const F = document.createElement("canvas");
      (F.width = 1280), (F.height = 720);
      const q = F.getContext("2d");
      if (!q) throw new Error("Could not get canvas context");
      let j = 0;
      const V = () => {
        (j = (j + 1) % 360),
          (q.fillStyle = "hsl(".concat(j, ", 100%, 50%)")),
          q.fillRect(0, 0, F.width, F.height),
          requestAnimationFrame(V);
      };
      V();
      const W = F.captureStream(30).getVideoTracks()[0],
        G = (yield this.room.localParticipant.publishTrack(W, {
          simulcast: !1,
          degradationPreference: "maintain-resolution",
          videoEncoding: { maxBitrate: 2e6 },
        })).track,
        H = {
          protocol: U,
          packetsLost: 0,
          packetsSent: 0,
          qualityLimitationDurations: {},
          rttTotal: 0,
          jitterTotal: 0,
          bitrateTotal: 0,
          count: 0,
        },
        Q = setInterval(
          () =>
            __awaiter$b(this, void 0, void 0, function* () {
              const z = yield G.getRTCStatsReport();
              z == null ||
                z.forEach((Y) => {
                  Y.type === "outbound-rtp"
                    ? ((H.packetsSent = Y.packetsSent),
                      (H.qualityLimitationDurations =
                        Y.qualityLimitationDurations),
                      (H.bitrateTotal += Y.targetBitrate),
                      H.count++)
                    : Y.type === "remote-inbound-rtp" &&
                      ((H.packetsLost = Y.packetsLost),
                      (H.rttTotal += Y.roundTripTime),
                      (H.jitterTotal += Y.jitter));
                });
            }),
          1e3
        );
      return (
        yield new Promise((z) => setTimeout(z, TEST_DURATION)),
        clearInterval(Q),
        W.stop(),
        F.remove(),
        yield this.disconnect(),
        H
      );
    });
  }
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.connect(),
        q = yield createLocalAudioTrack();
      if (yield detectSilence(q, 1e3))
        throw new Error("unable to detect audio from microphone");
      this.appendMessage("detected audio from microphone"),
        F.localParticipant.publishTrack(q),
        yield new Promise((W) => setTimeout(W, 3e3));
      const V = yield (U = q.sender) === null || U === void 0
        ? void 0
        : U.getStats();
      if (!V) throw new Error("Could not get RTCStats");
      let $ = 0;
      if (
        (V.forEach((W) => {
          W.type === "outbound-rtp" &&
            (W.kind === "audio" || (!W.kind && W.mediaType === "audio")) &&
            ($ = W.packetsSent);
        }),
        $ === 0)
      )
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat($, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.connect(),
        q = yield createLocalVideoTrack();
      yield this.checkForVideo(q.mediaStreamTrack),
        F.localParticipant.publishTrack(q),
        yield new Promise(($) => setTimeout($, 5e3));
      const j = yield (U = q.sender) === null || U === void 0
        ? void 0
        : U.getStats();
      if (!j) throw new Error("Could not get RTCStats");
      let V = 0;
      if (
        (j.forEach(($) => {
          $.type === "outbound-rtp" &&
            ($.kind === "video" || (!$.kind && $.mediaType === "video")) &&
            (V += $.packetsSent);
        }),
        V === 0)
      )
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(V, " video packets"));
    });
  }
  checkForVideo(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = new MediaStream();
      F.addTrack(U.clone());
      const q = document.createElement("video");
      (q.srcObject = F),
        (q.muted = !0),
        yield new Promise((j) => {
          (q.onplay = () => {
            setTimeout(() => {
              var V, $, W, K;
              const G = document.createElement("canvas"),
                H = U.getSettings(),
                Q =
                  ($ =
                    (V = H.width) !== null && V !== void 0
                      ? V
                      : q.videoWidth) !== null && $ !== void 0
                    ? $
                    : 1280,
                z =
                  (K =
                    (W = H.height) !== null && W !== void 0
                      ? W
                      : q.videoHeight) !== null && K !== void 0
                    ? K
                    : 720;
              (G.width = Q), (G.height = z);
              const Y = G.getContext("2d");
              Y.drawImage(q, 0, 0);
              const Z = Y.getImageData(0, 0, G.width, G.height).data;
              let se = !0;
              for (let ee = 0; ee < Z.length; ee += 4)
                if (Z[ee] !== 0 || Z[ee + 1] !== 0 || Z[ee + 2] !== 0) {
                  se = !1;
                  break;
                }
              se
                ? this.appendError(
                    "camera appears to be producing only black frames"
                  )
                : this.appendMessage("received video frames"),
                j();
            }, 1e3);
          }),
            q.play();
        }),
        q.remove();
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U;
      const F = yield this.connect();
      let q = !1,
        j = !1,
        V;
      const $ = new Promise((G) => {
          setTimeout(G, 5e3), (V = G);
        }),
        W = () => {
          q = !0;
        };
      F.on(RoomEvent.SignalReconnecting, W)
        .on(RoomEvent.Reconnecting, W)
        .on(RoomEvent.Reconnected, () => {
          (j = !0), V(!0);
        }),
        (U = F.engine.client.ws) === null || U === void 0 || U.close();
      const K = F.engine.client.onClose;
      if ((K && K(""), yield $, q)) {
        if (!j || F.state !== ConnectionState.Connected)
          throw (
            (this.appendWarning(
              "reconnection is only possible in Redis-based configurations"
            ),
            new Error("Not able to reconnect"))
          );
      } else throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U, F;
      const q = new SignalClient(),
        j = yield q.join(this.url, this.token, {
          autoSubscribe: !0,
          maxRetries: 0,
          e2eeEnabled: !1,
          websocketTimeout: 15e3,
        });
      let V = !1,
        $ = !1,
        W = !1;
      for (let K of j.iceServers)
        for (let G of K.urls)
          G.startsWith("turn:")
            ? (($ = !0), (W = !0))
            : G.startsWith("turns:") && (($ = !0), (W = !0), (V = !0)),
            G.startsWith("stun:") && (W = !0);
      W
        ? $ &&
          !V &&
          this.appendWarning(
            "TURN is configured server side, but TURN/TLS is unavailable."
          )
        : this.appendWarning("No STUN servers configured on server side."),
        yield q.close(),
        (!(
          (F =
            (U = this.connectOptions) === null || U === void 0
              ? void 0
              : U.rtcConfig) === null || F === void 0
        ) &&
          F.iceServers) ||
        $
          ? yield this.room.connect(this.url, this.token, {
              rtcConfig: { iceTransportPolicy: "relay" },
            })
          : (this.appendWarning("No TURN servers configured."),
            this.skip(),
            yield new Promise((K) => setTimeout(K, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      let U = !1,
        F = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const q = this.room.engine.client.onTrickle;
        (this.room.engine.client.onTrickle = (j, V) => {
          if (j.candidate) {
            const $ = new RTCIceCandidate(j);
            let W = ""
              .concat($.protocol, " ")
              .concat($.address, ":")
              .concat($.port, " ")
              .concat($.type);
            $.address &&
              (isIPPrivate($.address)
                ? (W += " (private)")
                : $.protocol === "tcp" && $.tcpType === "passive"
                ? ((U = !0), (W += " (passive)"))
                : $.protocol === "udp" && (F = !0)),
              this.appendMessage(W);
          }
          q && q(j, V);
        }),
          this.room.engine.pcManager &&
            (this.room.engine.pcManager.subscriber.onIceCandidateError = (
              j
            ) => {
              j instanceof RTCPeerConnectionIceErrorEvent &&
                this.appendWarning(
                  "error with ICE candidate: "
                    .concat(j.errorCode, " ")
                    .concat(j.errorText, " ")
                    .concat(j.url)
                );
            });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (q) {
        throw (
          (this.appendWarning(
            "ports need to be open on firewall in order to connect."
          ),
          q)
        );
      }
      U || this.appendWarning("Server is not configured for ICE/TCP"),
        F ||
          this.appendWarning(
            "No public IPv4 UDP candidates were found. Your server is likely not configured correctly"
          );
    });
  }
}
function isIPPrivate(B) {
  const U = B.split(".");
  if (U.length === 4) {
    if (U[0] === "10") return !0;
    if (U[0] === "192" && U[1] === "168") return !0;
    if (U[0] === "172") {
      const F = parseInt(U[1], 10);
      if (F >= 16 && F <= 31) return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    return __awaiter$b(this, void 0, void 0, function* () {
      var U, F, q;
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) &&
        this.appendWarning(
          "Server is insecure, clients may block connections to it"
        );
      let j = new SignalClient();
      const V = yield j.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3,
      });
      this.appendMessage(
        "Connected to server, version ".concat(V.serverVersion, ".")
      ),
        ((U = V.serverInfo) === null || U === void 0 ? void 0 : U.edition) ===
          ServerInfo_Edition.Cloud &&
          !((F = V.serverInfo) === null || F === void 0) &&
          F.region &&
          this.appendMessage(
            "LiveKit Cloud: ".concat(
              (q = V.serverInfo) === null || q === void 0 ? void 0 : q.region
            )
          ),
        yield j.close();
    });
  }
}
class ConnectionCheck extends eventsExports$1.EventEmitter {
  constructor(U, F) {
    let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(),
      (this.options = {}),
      (this.checkResults = new Map()),
      (this.url = U),
      (this.token = F),
      (this.options = q);
  }
  getNextCheckId() {
    const U = this.checkResults.size;
    return (
      this.checkResults.set(U, {
        logs: [],
        status: CheckStatus.IDLE,
        name: "",
        description: "",
      }),
      U
    );
  }
  updateCheck(U, F) {
    this.checkResults.set(U, F), this.emit("checkUpdate", U, F);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every(
      (U) => U.status !== CheckStatus.FAILED
    );
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(U) {
    return __awaiter$b(this, void 0, void 0, function* () {
      const F = this.getNextCheckId(),
        q = new U(this.url, this.token, this.options),
        j = ($) => {
          this.updateCheck(F, $);
        };
      q.on("update", j);
      const V = yield q.run();
      return q.off("update", j), V;
    });
  }
  checkWebsocket() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
  checkConnectionProtocol() {
    return __awaiter$b(this, void 0, void 0, function* () {
      const U = yield this.createAndRunCheck(ConnectionProtocolCheck);
      if (U.data && "protocol" in U.data) {
        const F = U.data;
        this.options.protocol = F.protocol;
      }
      return U;
    });
  }
  checkCloudRegion() {
    return __awaiter$b(this, void 0, void 0, function* () {
      return this.createAndRunCheck(CloudRegionCheck);
    });
  }
}
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default")
    ? B.default
    : B;
}
var src = { exports: {} },
  indexLight = { exports: {} },
  indexMinimal = {},
  minimal = {},
  aspromise,
  hasRequiredAspromise;
function requireAspromise() {
  if (hasRequiredAspromise) return aspromise;
  (hasRequiredAspromise = 1), (aspromise = B);
  function B(U, F) {
    for (
      var q = new Array(arguments.length - 1), j = 0, V = 2, $ = !0;
      V < arguments.length;

    )
      q[j++] = arguments[V++];
    return new Promise(function (K, G) {
      q[j] = function (Q) {
        if ($)
          if ((($ = !1), Q)) G(Q);
          else {
            for (var z = new Array(arguments.length - 1), Y = 0; Y < z.length; )
              z[Y++] = arguments[Y];
            K.apply(null, z);
          }
      };
      try {
        U.apply(F || null, q);
      } catch (H) {
        $ && (($ = !1), G(H));
      }
    });
  }
  return aspromise;
}
var base64 = {},
  hasRequiredBase64;
function requireBase64() {
  return (
    hasRequiredBase64 ||
      ((hasRequiredBase64 = 1),
      (function (B) {
        var U = B;
        U.length = function (W) {
          var K = W.length;
          if (!K) return 0;
          for (var G = 0; --K % 4 > 1 && W.charAt(K) === "="; ) ++G;
          return Math.ceil(W.length * 3) / 4 - G;
        };
        for (var F = new Array(64), q = new Array(123), j = 0; j < 64; )
          q[
            (F[j] =
              j < 26
                ? j + 65
                : j < 52
                ? j + 71
                : j < 62
                ? j - 4
                : (j - 59) | 43)
          ] = j++;
        U.encode = function (W, K, G) {
          for (var H = null, Q = [], z = 0, Y = 0, X; K < G; ) {
            var Z = W[K++];
            switch (Y) {
              case 0:
                (Q[z++] = F[Z >> 2]), (X = (Z & 3) << 4), (Y = 1);
                break;
              case 1:
                (Q[z++] = F[X | (Z >> 4)]), (X = (Z & 15) << 2), (Y = 2);
                break;
              case 2:
                (Q[z++] = F[X | (Z >> 6)]), (Q[z++] = F[Z & 63]), (Y = 0);
                break;
            }
            z > 8191 &&
              ((H || (H = [])).push(String.fromCharCode.apply(String, Q)),
              (z = 0));
          }
          return (
            Y && ((Q[z++] = F[X]), (Q[z++] = 61), Y === 1 && (Q[z++] = 61)),
            H
              ? (z && H.push(String.fromCharCode.apply(String, Q.slice(0, z))),
                H.join(""))
              : String.fromCharCode.apply(String, Q.slice(0, z))
          );
        };
        var V = "invalid encoding";
        (U.decode = function (W, K, G) {
          for (var H = G, Q = 0, z, Y = 0; Y < W.length; ) {
            var X = W.charCodeAt(Y++);
            if (X === 61 && Q > 1) break;
            if ((X = q[X]) === void 0) throw Error(V);
            switch (Q) {
              case 0:
                (z = X), (Q = 1);
                break;
              case 1:
                (K[G++] = (z << 2) | ((X & 48) >> 4)), (z = X), (Q = 2);
                break;
              case 2:
                (K[G++] = ((z & 15) << 4) | ((X & 60) >> 2)), (z = X), (Q = 3);
                break;
              case 3:
                (K[G++] = ((z & 3) << 6) | X), (Q = 0);
                break;
            }
          }
          if (Q === 1) throw Error(V);
          return G - H;
        }),
          (U.test = function (W) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
              W
            );
          });
      })(base64)),
    base64
  );
}
var eventemitter, hasRequiredEventemitter;
function requireEventemitter() {
  if (hasRequiredEventemitter) return eventemitter;
  (hasRequiredEventemitter = 1), (eventemitter = B);
  function B() {
    this._listeners = {};
  }
  return (
    (B.prototype.on = function (F, q, j) {
      return (
        (this._listeners[F] || (this._listeners[F] = [])).push({
          fn: q,
          ctx: j || this,
        }),
        this
      );
    }),
    (B.prototype.off = function (F, q) {
      if (F === void 0) this._listeners = {};
      else if (q === void 0) this._listeners[F] = [];
      else
        for (var j = this._listeners[F], V = 0; V < j.length; )
          j[V].fn === q ? j.splice(V, 1) : ++V;
      return this;
    }),
    (B.prototype.emit = function (F) {
      var q = this._listeners[F];
      if (q) {
        for (var j = [], V = 1; V < arguments.length; ) j.push(arguments[V++]);
        for (V = 0; V < q.length; ) q[V].fn.apply(q[V++].ctx, j);
      }
      return this;
    }),
    eventemitter
  );
}
var float, hasRequiredFloat;
function requireFloat() {
  if (hasRequiredFloat) return float;
  (hasRequiredFloat = 1), (float = B(B));
  function B(V) {
    return (
      typeof Float32Array < "u"
        ? (function () {
            var $ = new Float32Array([-0]),
              W = new Uint8Array($.buffer),
              K = W[3] === 128;
            function G(Y, X, Z) {
              ($[0] = Y),
                (X[Z] = W[0]),
                (X[Z + 1] = W[1]),
                (X[Z + 2] = W[2]),
                (X[Z + 3] = W[3]);
            }
            function H(Y, X, Z) {
              ($[0] = Y),
                (X[Z] = W[3]),
                (X[Z + 1] = W[2]),
                (X[Z + 2] = W[1]),
                (X[Z + 3] = W[0]);
            }
            (V.writeFloatLE = K ? G : H), (V.writeFloatBE = K ? H : G);
            function Q(Y, X) {
              return (
                (W[0] = Y[X]),
                (W[1] = Y[X + 1]),
                (W[2] = Y[X + 2]),
                (W[3] = Y[X + 3]),
                $[0]
              );
            }
            function z(Y, X) {
              return (
                (W[3] = Y[X]),
                (W[2] = Y[X + 1]),
                (W[1] = Y[X + 2]),
                (W[0] = Y[X + 3]),
                $[0]
              );
            }
            (V.readFloatLE = K ? Q : z), (V.readFloatBE = K ? z : Q);
          })()
        : (function () {
            function $(K, G, H, Q) {
              var z = G < 0 ? 1 : 0;
              if ((z && (G = -G), G === 0)) K(1 / G > 0 ? 0 : 2147483648, H, Q);
              else if (isNaN(G)) K(2143289344, H, Q);
              else if (G > 34028234663852886e22)
                K(((z << 31) | 2139095040) >>> 0, H, Q);
              else if (G < 11754943508222875e-54)
                K(
                  ((z << 31) | Math.round(G / 1401298464324817e-60)) >>> 0,
                  H,
                  Q
                );
              else {
                var Y = Math.floor(Math.log(G) / Math.LN2),
                  X = Math.round(G * Math.pow(2, -Y) * 8388608) & 8388607;
                K(((z << 31) | ((Y + 127) << 23) | X) >>> 0, H, Q);
              }
            }
            (V.writeFloatLE = $.bind(null, U)),
              (V.writeFloatBE = $.bind(null, F));
            function W(K, G, H) {
              var Q = K(G, H),
                z = (Q >> 31) * 2 + 1,
                Y = (Q >>> 23) & 255,
                X = Q & 8388607;
              return Y === 255
                ? X
                  ? NaN
                  : z * (1 / 0)
                : Y === 0
                ? z * 1401298464324817e-60 * X
                : z * Math.pow(2, Y - 150) * (X + 8388608);
            }
            (V.readFloatLE = W.bind(null, q)),
              (V.readFloatBE = W.bind(null, j));
          })(),
      typeof Float64Array < "u"
        ? (function () {
            var $ = new Float64Array([-0]),
              W = new Uint8Array($.buffer),
              K = W[7] === 128;
            function G(Y, X, Z) {
              ($[0] = Y),
                (X[Z] = W[0]),
                (X[Z + 1] = W[1]),
                (X[Z + 2] = W[2]),
                (X[Z + 3] = W[3]),
                (X[Z + 4] = W[4]),
                (X[Z + 5] = W[5]),
                (X[Z + 6] = W[6]),
                (X[Z + 7] = W[7]);
            }
            function H(Y, X, Z) {
              ($[0] = Y),
                (X[Z] = W[7]),
                (X[Z + 1] = W[6]),
                (X[Z + 2] = W[5]),
                (X[Z + 3] = W[4]),
                (X[Z + 4] = W[3]),
                (X[Z + 5] = W[2]),
                (X[Z + 6] = W[1]),
                (X[Z + 7] = W[0]);
            }
            (V.writeDoubleLE = K ? G : H), (V.writeDoubleBE = K ? H : G);
            function Q(Y, X) {
              return (
                (W[0] = Y[X]),
                (W[1] = Y[X + 1]),
                (W[2] = Y[X + 2]),
                (W[3] = Y[X + 3]),
                (W[4] = Y[X + 4]),
                (W[5] = Y[X + 5]),
                (W[6] = Y[X + 6]),
                (W[7] = Y[X + 7]),
                $[0]
              );
            }
            function z(Y, X) {
              return (
                (W[7] = Y[X]),
                (W[6] = Y[X + 1]),
                (W[5] = Y[X + 2]),
                (W[4] = Y[X + 3]),
                (W[3] = Y[X + 4]),
                (W[2] = Y[X + 5]),
                (W[1] = Y[X + 6]),
                (W[0] = Y[X + 7]),
                $[0]
              );
            }
            (V.readDoubleLE = K ? Q : z), (V.readDoubleBE = K ? z : Q);
          })()
        : (function () {
            function $(K, G, H, Q, z, Y) {
              var X = Q < 0 ? 1 : 0;
              if ((X && (Q = -Q), Q === 0))
                K(0, z, Y + G), K(1 / Q > 0 ? 0 : 2147483648, z, Y + H);
              else if (isNaN(Q)) K(0, z, Y + G), K(2146959360, z, Y + H);
              else if (Q > 17976931348623157e292)
                K(0, z, Y + G), K(((X << 31) | 2146435072) >>> 0, z, Y + H);
              else {
                var Z;
                if (Q < 22250738585072014e-324)
                  (Z = Q / 5e-324),
                    K(Z >>> 0, z, Y + G),
                    K(((X << 31) | (Z / 4294967296)) >>> 0, z, Y + H);
                else {
                  var se = Math.floor(Math.log(Q) / Math.LN2);
                  se === 1024 && (se = 1023),
                    (Z = Q * Math.pow(2, -se)),
                    K((Z * 4503599627370496) >>> 0, z, Y + G),
                    K(
                      ((X << 31) |
                        ((se + 1023) << 20) |
                        ((Z * 1048576) & 1048575)) >>>
                        0,
                      z,
                      Y + H
                    );
                }
              }
            }
            (V.writeDoubleLE = $.bind(null, U, 0, 4)),
              (V.writeDoubleBE = $.bind(null, F, 4, 0));
            function W(K, G, H, Q, z) {
              var Y = K(Q, z + G),
                X = K(Q, z + H),
                Z = (X >> 31) * 2 + 1,
                se = (X >>> 20) & 2047,
                ee = 4294967296 * (X & 1048575) + Y;
              return se === 2047
                ? ee
                  ? NaN
                  : Z * (1 / 0)
                : se === 0
                ? Z * 5e-324 * ee
                : Z * Math.pow(2, se - 1075) * (ee + 4503599627370496);
            }
            (V.readDoubleLE = W.bind(null, q, 0, 4)),
              (V.readDoubleBE = W.bind(null, j, 4, 0));
          })(),
      V
    );
  }
  function U(V, $, W) {
    ($[W] = V & 255),
      ($[W + 1] = (V >>> 8) & 255),
      ($[W + 2] = (V >>> 16) & 255),
      ($[W + 3] = V >>> 24);
  }
  function F(V, $, W) {
    ($[W] = V >>> 24),
      ($[W + 1] = (V >>> 16) & 255),
      ($[W + 2] = (V >>> 8) & 255),
      ($[W + 3] = V & 255);
  }
  function q(V, $) {
    return (V[$] | (V[$ + 1] << 8) | (V[$ + 2] << 16) | (V[$ + 3] << 24)) >>> 0;
  }
  function j(V, $) {
    return ((V[$] << 24) | (V[$ + 1] << 16) | (V[$ + 2] << 8) | V[$ + 3]) >>> 0;
  }
  return float;
}
var inquire_1, hasRequiredInquire;
function requireInquire() {
  if (hasRequiredInquire) return inquire_1;
  (hasRequiredInquire = 1), (inquire_1 = inquire);
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (B) {}
    return null;
  }
  return inquire_1;
}
var utf8 = {},
  hasRequiredUtf8;
function requireUtf8() {
  return (
    hasRequiredUtf8 ||
      ((hasRequiredUtf8 = 1),
      (function (B) {
        var U = B;
        (U.length = function (q) {
          for (var j = 0, V = 0, $ = 0; $ < q.length; ++$)
            (V = q.charCodeAt($)),
              V < 128
                ? (j += 1)
                : V < 2048
                ? (j += 2)
                : (V & 64512) === 55296 &&
                  (q.charCodeAt($ + 1) & 64512) === 56320
                ? (++$, (j += 4))
                : (j += 3);
          return j;
        }),
          (U.read = function (q, j, V) {
            var $ = V - j;
            if ($ < 1) return "";
            for (var W = null, K = [], G = 0, H; j < V; )
              (H = q[j++]),
                H < 128
                  ? (K[G++] = H)
                  : H > 191 && H < 224
                  ? (K[G++] = ((H & 31) << 6) | (q[j++] & 63))
                  : H > 239 && H < 365
                  ? ((H =
                      (((H & 7) << 18) |
                        ((q[j++] & 63) << 12) |
                        ((q[j++] & 63) << 6) |
                        (q[j++] & 63)) -
                      65536),
                    (K[G++] = 55296 + (H >> 10)),
                    (K[G++] = 56320 + (H & 1023)))
                  : (K[G++] =
                      ((H & 15) << 12) | ((q[j++] & 63) << 6) | (q[j++] & 63)),
                G > 8191 &&
                  ((W || (W = [])).push(String.fromCharCode.apply(String, K)),
                  (G = 0));
            return W
              ? (G && W.push(String.fromCharCode.apply(String, K.slice(0, G))),
                W.join(""))
              : String.fromCharCode.apply(String, K.slice(0, G));
          }),
          (U.write = function (q, j, V) {
            for (var $ = V, W, K, G = 0; G < q.length; ++G)
              (W = q.charCodeAt(G)),
                W < 128
                  ? (j[V++] = W)
                  : W < 2048
                  ? ((j[V++] = (W >> 6) | 192), (j[V++] = (W & 63) | 128))
                  : (W & 64512) === 55296 &&
                    ((K = q.charCodeAt(G + 1)) & 64512) === 56320
                  ? ((W = 65536 + ((W & 1023) << 10) + (K & 1023)),
                    ++G,
                    (j[V++] = (W >> 18) | 240),
                    (j[V++] = ((W >> 12) & 63) | 128),
                    (j[V++] = ((W >> 6) & 63) | 128),
                    (j[V++] = (W & 63) | 128))
                  : ((j[V++] = (W >> 12) | 224),
                    (j[V++] = ((W >> 6) & 63) | 128),
                    (j[V++] = (W & 63) | 128));
            return V - $;
          });
      })(utf8)),
    utf8
  );
}
var pool_1, hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool_1;
  (hasRequiredPool = 1), (pool_1 = B);
  function B(U, F, q) {
    var j = q || 8192,
      V = j >>> 1,
      $ = null,
      W = j;
    return function (G) {
      if (G < 1 || G > V) return U(G);
      W + G > j && (($ = U(j)), (W = 0));
      var H = F.call($, W, (W += G));
      return W & 7 && (W = (W | 7) + 1), H;
    };
  }
  return pool_1;
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits) return longbits;
  (hasRequiredLongbits = 1), (longbits = U);
  var B = requireMinimal();
  function U(V, $) {
    (this.lo = V >>> 0), (this.hi = $ >>> 0);
  }
  var F = (U.zero = new U(0, 0));
  (F.toNumber = function () {
    return 0;
  }),
    (F.zzEncode = F.zzDecode =
      function () {
        return this;
      }),
    (F.length = function () {
      return 1;
    });
  var q = (U.zeroHash = "\0\0\0\0\0\0\0\0");
  (U.fromNumber = function ($) {
    if ($ === 0) return F;
    var W = $ < 0;
    W && ($ = -$);
    var K = $ >>> 0,
      G = (($ - K) / 4294967296) >>> 0;
    return (
      W &&
        ((G = ~G >>> 0),
        (K = ~K >>> 0),
        ++K > 4294967295 && ((K = 0), ++G > 4294967295 && (G = 0))),
      new U(K, G)
    );
  }),
    (U.from = function ($) {
      if (typeof $ == "number") return U.fromNumber($);
      if (B.isString($))
        if (B.Long) $ = B.Long.fromString($);
        else return U.fromNumber(parseInt($, 10));
      return $.low || $.high ? new U($.low >>> 0, $.high >>> 0) : F;
    }),
    (U.prototype.toNumber = function ($) {
      if (!$ && this.hi >>> 31) {
        var W = (~this.lo + 1) >>> 0,
          K = ~this.hi >>> 0;
        return W || (K = (K + 1) >>> 0), -(W + K * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }),
    (U.prototype.toLong = function ($) {
      return B.Long
        ? new B.Long(this.lo | 0, this.hi | 0, !!$)
        : { low: this.lo | 0, high: this.hi | 0, unsigned: !!$ };
    });
  var j = String.prototype.charCodeAt;
  return (
    (U.fromHash = function ($) {
      return $ === q
        ? F
        : new U(
            (j.call($, 0) |
              (j.call($, 1) << 8) |
              (j.call($, 2) << 16) |
              (j.call($, 3) << 24)) >>>
              0,
            (j.call($, 4) |
              (j.call($, 5) << 8) |
              (j.call($, 6) << 16) |
              (j.call($, 7) << 24)) >>>
              0
          );
    }),
    (U.prototype.toHash = function () {
      return String.fromCharCode(
        this.lo & 255,
        (this.lo >>> 8) & 255,
        (this.lo >>> 16) & 255,
        this.lo >>> 24,
        this.hi & 255,
        (this.hi >>> 8) & 255,
        (this.hi >>> 16) & 255,
        this.hi >>> 24
      );
    }),
    (U.prototype.zzEncode = function () {
      var $ = this.hi >> 31;
      return (
        (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ $) >>> 0),
        (this.lo = ((this.lo << 1) ^ $) >>> 0),
        this
      );
    }),
    (U.prototype.zzDecode = function () {
      var $ = -(this.lo & 1);
      return (
        (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ $) >>> 0),
        (this.hi = ((this.hi >>> 1) ^ $) >>> 0),
        this
      );
    }),
    (U.prototype.length = function () {
      var $ = this.lo,
        W = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
        K = this.hi >>> 24;
      return K === 0
        ? W === 0
          ? $ < 16384
            ? $ < 128
              ? 1
              : 2
            : $ < 2097152
            ? 3
            : 4
          : W < 16384
          ? W < 128
            ? 5
            : 6
          : W < 2097152
          ? 7
          : 8
        : K < 128
        ? 9
        : 10;
    }),
    longbits
  );
}
var hasRequiredMinimal;
function requireMinimal() {
  return (
    hasRequiredMinimal ||
      ((hasRequiredMinimal = 1),
      (function (B) {
        var U = B;
        (U.asPromise = requireAspromise()),
          (U.base64 = requireBase64()),
          (U.EventEmitter = requireEventemitter()),
          (U.float = requireFloat()),
          (U.inquire = requireInquire()),
          (U.utf8 = requireUtf8()),
          (U.pool = requirePool()),
          (U.LongBits = requireLongbits()),
          (U.isNode = !!(
            typeof commonjsGlobal < "u" &&
            commonjsGlobal &&
            commonjsGlobal.process &&
            commonjsGlobal.process.versions &&
            commonjsGlobal.process.versions.node
          )),
          (U.global =
            (U.isNode && commonjsGlobal) ||
            (typeof window < "u" && window) ||
            (typeof self < "u" && self) ||
            minimal),
          (U.emptyArray = Object.freeze ? Object.freeze([]) : []),
          (U.emptyObject = Object.freeze ? Object.freeze({}) : {}),
          (U.isInteger =
            Number.isInteger ||
            function (V) {
              return typeof V == "number" && isFinite(V) && Math.floor(V) === V;
            }),
          (U.isString = function (V) {
            return typeof V == "string" || V instanceof String;
          }),
          (U.isObject = function (V) {
            return V && typeof V == "object";
          }),
          (U.isset = U.isSet =
            function (V, $) {
              var W = V[$];
              return W != null && V.hasOwnProperty($)
                ? typeof W != "object" ||
                    (Array.isArray(W) ? W.length : Object.keys(W).length) > 0
                : !1;
            }),
          (U.Buffer = (function () {
            try {
              var j = U.inquire("buffer").Buffer;
              return j.prototype.utf8Write ? j : null;
            } catch {
              return null;
            }
          })()),
          (U._Buffer_from = null),
          (U._Buffer_allocUnsafe = null),
          (U.newBuffer = function (V) {
            return typeof V == "number"
              ? U.Buffer
                ? U._Buffer_allocUnsafe(V)
                : new U.Array(V)
              : U.Buffer
              ? U._Buffer_from(V)
              : typeof Uint8Array > "u"
              ? V
              : new Uint8Array(V);
          }),
          (U.Array = typeof Uint8Array < "u" ? Uint8Array : Array),
          (U.Long =
            (U.global.dcodeIO && U.global.dcodeIO.Long) ||
            U.global.Long ||
            U.inquire("long")),
          (U.key2Re = /^true|false|0|1$/),
          (U.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
          (U.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
          (U.longToHash = function (V) {
            return V ? U.LongBits.from(V).toHash() : U.LongBits.zeroHash;
          }),
          (U.longFromHash = function (V, $) {
            var W = U.LongBits.fromHash(V);
            return U.Long ? U.Long.fromBits(W.lo, W.hi, $) : W.toNumber(!!$);
          });
        function F(j, V, $) {
          for (var W = Object.keys(V), K = 0; K < W.length; ++K)
            (j[W[K]] === void 0 || !$) && (j[W[K]] = V[W[K]]);
          return j;
        }
        (U.merge = F),
          (U.lcFirst = function (V) {
            return V.charAt(0).toLowerCase() + V.substring(1);
          });
        function q(j) {
          function V($, W) {
            if (!(this instanceof V)) return new V($, W);
            Object.defineProperty(this, "message", {
              get: function () {
                return $;
              },
            }),
              Error.captureStackTrace
                ? Error.captureStackTrace(this, V)
                : Object.defineProperty(this, "stack", {
                    value: new Error().stack || "",
                  }),
              W && F(this, W);
          }
          return (
            (V.prototype = Object.create(Error.prototype, {
              constructor: {
                value: V,
                writable: !0,
                enumerable: !1,
                configurable: !0,
              },
              name: {
                get: function () {
                  return j;
                },
                set: void 0,
                enumerable: !1,
                configurable: !0,
              },
              toString: {
                value: function () {
                  return this.name + ": " + this.message;
                },
                writable: !0,
                enumerable: !1,
                configurable: !0,
              },
            })),
            V
          );
        }
        (U.newError = q),
          (U.ProtocolError = q("ProtocolError")),
          (U.oneOfGetter = function (V) {
            for (var $ = {}, W = 0; W < V.length; ++W) $[V[W]] = 1;
            return function () {
              for (var K = Object.keys(this), G = K.length - 1; G > -1; --G)
                if (
                  $[K[G]] === 1 &&
                  this[K[G]] !== void 0 &&
                  this[K[G]] !== null
                )
                  return K[G];
            };
          }),
          (U.oneOfSetter = function (V) {
            return function ($) {
              for (var W = 0; W < V.length; ++W)
                V[W] !== $ && delete this[V[W]];
            };
          }),
          (U.toJSONOptions = {
            longs: String,
            enums: String,
            bytes: String,
            json: !0,
          }),
          (U._configure = function () {
            var j = U.Buffer;
            if (!j) {
              U._Buffer_from = U._Buffer_allocUnsafe = null;
              return;
            }
            (U._Buffer_from =
              (j.from !== Uint8Array.from && j.from) ||
              function ($, W) {
                return new j($, W);
              }),
              (U._Buffer_allocUnsafe =
                j.allocUnsafe ||
                function ($) {
                  return new j($);
                });
          });
      })(minimal)),
    minimal
  );
}
var writer, hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  (hasRequiredWriter = 1), (writer = K);
  var B = requireMinimal(),
    U,
    F = B.LongBits,
    q = B.base64,
    j = B.utf8;
  function V(se, ee, ie) {
    (this.fn = se), (this.len = ee), (this.next = void 0), (this.val = ie);
  }
  function $() {}
  function W(se) {
    (this.head = se.head),
      (this.tail = se.tail),
      (this.len = se.len),
      (this.next = se.states);
  }
  function K() {
    (this.len = 0),
      (this.head = new V($, 0, 0)),
      (this.tail = this.head),
      (this.states = null);
  }
  var G = function () {
    return B.Buffer
      ? function () {
          return (K.create = function () {
            return new U();
          })();
        }
      : function () {
          return new K();
        };
  };
  (K.create = G()),
    (K.alloc = function (ee) {
      return new B.Array(ee);
    }),
    B.Array !== Array &&
      (K.alloc = B.pool(K.alloc, B.Array.prototype.subarray)),
    (K.prototype._push = function (ee, ie, re) {
      return (
        (this.tail = this.tail.next = new V(ee, ie, re)), (this.len += ie), this
      );
    });
  function H(se, ee, ie) {
    ee[ie] = se & 255;
  }
  function Q(se, ee, ie) {
    for (; se > 127; ) (ee[ie++] = (se & 127) | 128), (se >>>= 7);
    ee[ie] = se;
  }
  function z(se, ee) {
    (this.len = se), (this.next = void 0), (this.val = ee);
  }
  (z.prototype = Object.create(V.prototype)),
    (z.prototype.fn = Q),
    (K.prototype.uint32 = function (ee) {
      return (
        (this.len += (this.tail = this.tail.next =
          new z(
            (ee = ee >>> 0) < 128
              ? 1
              : ee < 16384
              ? 2
              : ee < 2097152
              ? 3
              : ee < 268435456
              ? 4
              : 5,
            ee
          )).len),
        this
      );
    }),
    (K.prototype.int32 = function (ee) {
      return ee < 0 ? this._push(Y, 10, F.fromNumber(ee)) : this.uint32(ee);
    }),
    (K.prototype.sint32 = function (ee) {
      return this.uint32(((ee << 1) ^ (ee >> 31)) >>> 0);
    });
  function Y(se, ee, ie) {
    for (; se.hi; )
      (ee[ie++] = (se.lo & 127) | 128),
        (se.lo = ((se.lo >>> 7) | (se.hi << 25)) >>> 0),
        (se.hi >>>= 7);
    for (; se.lo > 127; )
      (ee[ie++] = (se.lo & 127) | 128), (se.lo = se.lo >>> 7);
    ee[ie++] = se.lo;
  }
  (K.prototype.uint64 = function (ee) {
    var ie = F.from(ee);
    return this._push(Y, ie.length(), ie);
  }),
    (K.prototype.int64 = K.prototype.uint64),
    (K.prototype.sint64 = function (ee) {
      var ie = F.from(ee).zzEncode();
      return this._push(Y, ie.length(), ie);
    }),
    (K.prototype.bool = function (ee) {
      return this._push(H, 1, ee ? 1 : 0);
    });
  function X(se, ee, ie) {
    (ee[ie] = se & 255),
      (ee[ie + 1] = (se >>> 8) & 255),
      (ee[ie + 2] = (se >>> 16) & 255),
      (ee[ie + 3] = se >>> 24);
  }
  (K.prototype.fixed32 = function (ee) {
    return this._push(X, 4, ee >>> 0);
  }),
    (K.prototype.sfixed32 = K.prototype.fixed32),
    (K.prototype.fixed64 = function (ee) {
      var ie = F.from(ee);
      return this._push(X, 4, ie.lo)._push(X, 4, ie.hi);
    }),
    (K.prototype.sfixed64 = K.prototype.fixed64),
    (K.prototype.float = function (ee) {
      return this._push(B.float.writeFloatLE, 4, ee);
    }),
    (K.prototype.double = function (ee) {
      return this._push(B.float.writeDoubleLE, 8, ee);
    });
  var Z = B.Array.prototype.set
    ? function (ee, ie, re) {
        ie.set(ee, re);
      }
    : function (ee, ie, re) {
        for (var te = 0; te < ee.length; ++te) ie[re + te] = ee[te];
      };
  return (
    (K.prototype.bytes = function (ee) {
      var ie = ee.length >>> 0;
      if (!ie) return this._push(H, 1, 0);
      if (B.isString(ee)) {
        var re = K.alloc((ie = q.length(ee)));
        q.decode(ee, re, 0), (ee = re);
      }
      return this.uint32(ie)._push(Z, ie, ee);
    }),
    (K.prototype.string = function (ee) {
      var ie = j.length(ee);
      return ie ? this.uint32(ie)._push(j.write, ie, ee) : this._push(H, 1, 0);
    }),
    (K.prototype.fork = function () {
      return (
        (this.states = new W(this)),
        (this.head = this.tail = new V($, 0, 0)),
        (this.len = 0),
        this
      );
    }),
    (K.prototype.reset = function () {
      return (
        this.states
          ? ((this.head = this.states.head),
            (this.tail = this.states.tail),
            (this.len = this.states.len),
            (this.states = this.states.next))
          : ((this.head = this.tail = new V($, 0, 0)), (this.len = 0)),
        this
      );
    }),
    (K.prototype.ldelim = function () {
      var ee = this.head,
        ie = this.tail,
        re = this.len;
      return (
        this.reset().uint32(re),
        re && ((this.tail.next = ee.next), (this.tail = ie), (this.len += re)),
        this
      );
    }),
    (K.prototype.finish = function () {
      for (
        var ee = this.head.next, ie = this.constructor.alloc(this.len), re = 0;
        ee;

      )
        ee.fn(ee.val, ie, re), (re += ee.len), (ee = ee.next);
      return ie;
    }),
    (K._configure = function (se) {
      (U = se), (K.create = G()), U._configure();
    }),
    writer
  );
}
var writer_buffer, hasRequiredWriter_buffer;
function requireWriter_buffer() {
  if (hasRequiredWriter_buffer) return writer_buffer;
  (hasRequiredWriter_buffer = 1), (writer_buffer = F);
  var B = requireWriter();
  (F.prototype = Object.create(B.prototype)).constructor = F;
  var U = requireMinimal();
  function F() {
    B.call(this);
  }
  (F._configure = function () {
    (F.alloc = U._Buffer_allocUnsafe),
      (F.writeBytesBuffer =
        U.Buffer &&
        U.Buffer.prototype instanceof Uint8Array &&
        U.Buffer.prototype.set.name === "set"
          ? function (V, $, W) {
              $.set(V, W);
            }
          : function (V, $, W) {
              if (V.copy) V.copy($, W, 0, V.length);
              else for (var K = 0; K < V.length; ) $[W++] = V[K++];
            });
  }),
    (F.prototype.bytes = function (V) {
      U.isString(V) && (V = U._Buffer_from(V, "base64"));
      var $ = V.length >>> 0;
      return this.uint32($), $ && this._push(F.writeBytesBuffer, $, V), this;
    });
  function q(j, V, $) {
    j.length < 40
      ? U.utf8.write(j, V, $)
      : V.utf8Write
      ? V.utf8Write(j, $)
      : V.write(j, $);
  }
  return (
    (F.prototype.string = function (V) {
      var $ = U.Buffer.byteLength(V);
      return this.uint32($), $ && this._push(q, $, V), this;
    }),
    F._configure(),
    writer_buffer
  );
}
var reader, hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  (hasRequiredReader = 1), (reader = V);
  var B = requireMinimal(),
    U,
    F = B.LongBits,
    q = B.utf8;
  function j(Q, z) {
    return RangeError(
      "index out of range: " + Q.pos + " + " + (z || 1) + " > " + Q.len
    );
  }
  function V(Q) {
    (this.buf = Q), (this.pos = 0), (this.len = Q.length);
  }
  var $ =
      typeof Uint8Array < "u"
        ? function (z) {
            if (z instanceof Uint8Array || Array.isArray(z)) return new V(z);
            throw Error("illegal buffer");
          }
        : function (z) {
            if (Array.isArray(z)) return new V(z);
            throw Error("illegal buffer");
          },
    W = function () {
      return B.Buffer
        ? function (Y) {
            return (V.create = function (Z) {
              return B.Buffer.isBuffer(Z) ? new U(Z) : $(Z);
            })(Y);
          }
        : $;
    };
  (V.create = W()),
    (V.prototype._slice =
      B.Array.prototype.subarray || B.Array.prototype.slice),
    (V.prototype.uint32 = (function () {
      var z = 4294967295;
      return function () {
        if (
          ((z = (this.buf[this.pos] & 127) >>> 0),
          this.buf[this.pos++] < 128 ||
            ((z = (z | ((this.buf[this.pos] & 127) << 7)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((z = (z | ((this.buf[this.pos] & 127) << 14)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((z = (z | ((this.buf[this.pos] & 127) << 21)) >>> 0),
            this.buf[this.pos++] < 128) ||
            ((z = (z | ((this.buf[this.pos] & 15) << 28)) >>> 0),
            this.buf[this.pos++] < 128))
        )
          return z;
        if ((this.pos += 5) > this.len)
          throw ((this.pos = this.len), j(this, 10));
        return z;
      };
    })()),
    (V.prototype.int32 = function () {
      return this.uint32() | 0;
    }),
    (V.prototype.sint32 = function () {
      var z = this.uint32();
      return ((z >>> 1) ^ -(z & 1)) | 0;
    });
  function K() {
    var Q = new F(0, 0),
      z = 0;
    if (this.len - this.pos > 4) {
      for (; z < 4; ++z)
        if (
          ((Q.lo = (Q.lo | ((this.buf[this.pos] & 127) << (z * 7))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return Q;
      if (
        ((Q.lo = (Q.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0),
        (Q.hi = (Q.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0),
        this.buf[this.pos++] < 128)
      )
        return Q;
      z = 0;
    } else {
      for (; z < 3; ++z) {
        if (this.pos >= this.len) throw j(this);
        if (
          ((Q.lo = (Q.lo | ((this.buf[this.pos] & 127) << (z * 7))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return Q;
      }
      return (
        (Q.lo = (Q.lo | ((this.buf[this.pos++] & 127) << (z * 7))) >>> 0), Q
      );
    }
    if (this.len - this.pos > 4) {
      for (; z < 5; ++z)
        if (
          ((Q.hi = (Q.hi | ((this.buf[this.pos] & 127) << (z * 7 + 3))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return Q;
    } else
      for (; z < 5; ++z) {
        if (this.pos >= this.len) throw j(this);
        if (
          ((Q.hi = (Q.hi | ((this.buf[this.pos] & 127) << (z * 7 + 3))) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return Q;
      }
    throw Error("invalid varint encoding");
  }
  V.prototype.bool = function () {
    return this.uint32() !== 0;
  };
  function G(Q, z) {
    return (
      (Q[z - 4] | (Q[z - 3] << 8) | (Q[z - 2] << 16) | (Q[z - 1] << 24)) >>> 0
    );
  }
  (V.prototype.fixed32 = function () {
    if (this.pos + 4 > this.len) throw j(this, 4);
    return G(this.buf, (this.pos += 4));
  }),
    (V.prototype.sfixed32 = function () {
      if (this.pos + 4 > this.len) throw j(this, 4);
      return G(this.buf, (this.pos += 4)) | 0;
    });
  function H() {
    if (this.pos + 8 > this.len) throw j(this, 8);
    return new F(G(this.buf, (this.pos += 4)), G(this.buf, (this.pos += 4)));
  }
  return (
    (V.prototype.float = function () {
      if (this.pos + 4 > this.len) throw j(this, 4);
      var z = B.float.readFloatLE(this.buf, this.pos);
      return (this.pos += 4), z;
    }),
    (V.prototype.double = function () {
      if (this.pos + 8 > this.len) throw j(this, 4);
      var z = B.float.readDoubleLE(this.buf, this.pos);
      return (this.pos += 8), z;
    }),
    (V.prototype.bytes = function () {
      var z = this.uint32(),
        Y = this.pos,
        X = this.pos + z;
      if (X > this.len) throw j(this, z);
      if (((this.pos += z), Array.isArray(this.buf)))
        return this.buf.slice(Y, X);
      if (Y === X) {
        var Z = B.Buffer;
        return Z ? Z.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, Y, X);
    }),
    (V.prototype.string = function () {
      var z = this.bytes();
      return q.read(z, 0, z.length);
    }),
    (V.prototype.skip = function (z) {
      if (typeof z == "number") {
        if (this.pos + z > this.len) throw j(this, z);
        this.pos += z;
      } else
        do if (this.pos >= this.len) throw j(this);
        while (this.buf[this.pos++] & 128);
      return this;
    }),
    (V.prototype.skipType = function (Q) {
      switch (Q) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          for (; (Q = this.uint32() & 7) !== 4; ) this.skipType(Q);
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + Q + " at offset " + this.pos);
      }
      return this;
    }),
    (V._configure = function (Q) {
      (U = Q), (V.create = W()), U._configure();
      var z = B.Long ? "toLong" : "toNumber";
      B.merge(V.prototype, {
        int64: function () {
          return K.call(this)[z](!1);
        },
        uint64: function () {
          return K.call(this)[z](!0);
        },
        sint64: function () {
          return K.call(this).zzDecode()[z](!1);
        },
        fixed64: function () {
          return H.call(this)[z](!0);
        },
        sfixed64: function () {
          return H.call(this)[z](!1);
        },
      });
    }),
    reader
  );
}
var reader_buffer, hasRequiredReader_buffer;
function requireReader_buffer() {
  if (hasRequiredReader_buffer) return reader_buffer;
  (hasRequiredReader_buffer = 1), (reader_buffer = F);
  var B = requireReader();
  (F.prototype = Object.create(B.prototype)).constructor = F;
  var U = requireMinimal();
  function F(q) {
    B.call(this, q);
  }
  return (
    (F._configure = function () {
      U.Buffer && (F.prototype._slice = U.Buffer.prototype.slice);
    }),
    (F.prototype.string = function () {
      var j = this.uint32();
      return this.buf.utf8Slice
        ? this.buf.utf8Slice(
            this.pos,
            (this.pos = Math.min(this.pos + j, this.len))
          )
        : this.buf.toString(
            "utf-8",
            this.pos,
            (this.pos = Math.min(this.pos + j, this.len))
          );
    }),
    F._configure(),
    reader_buffer
  );
}
var rpc = {},
  service$1,
  hasRequiredService$1;
function requireService$1() {
  if (hasRequiredService$1) return service$1;
  (hasRequiredService$1 = 1), (service$1 = U);
  var B = requireMinimal();
  (U.prototype = Object.create(B.EventEmitter.prototype)).constructor = U;
  function U(F, q, j) {
    if (typeof F != "function") throw TypeError("rpcImpl must be a function");
    B.EventEmitter.call(this),
      (this.rpcImpl = F),
      (this.requestDelimited = !!q),
      (this.responseDelimited = !!j);
  }
  return (
    (U.prototype.rpcCall = function F(q, j, V, $, W) {
      if (!$) throw TypeError("request must be specified");
      var K = this;
      if (!W) return B.asPromise(F, K, q, j, V, $);
      if (!K.rpcImpl) {
        setTimeout(function () {
          W(Error("already ended"));
        }, 0);
        return;
      }
      try {
        return K.rpcImpl(
          q,
          j[K.requestDelimited ? "encodeDelimited" : "encode"]($).finish(),
          function (H, Q) {
            if (H) return K.emit("error", H, q), W(H);
            if (Q === null) {
              K.end(!0);
              return;
            }
            if (!(Q instanceof V))
              try {
                Q = V[K.responseDelimited ? "decodeDelimited" : "decode"](Q);
              } catch (z) {
                return K.emit("error", z, q), W(z);
              }
            return K.emit("data", Q, q), W(null, Q);
          }
        );
      } catch (G) {
        K.emit("error", G, q),
          setTimeout(function () {
            W(G);
          }, 0);
        return;
      }
    }),
    (U.prototype.end = function (q) {
      return (
        this.rpcImpl &&
          (q || this.rpcImpl(null, null, null),
          (this.rpcImpl = null),
          this.emit("end").off()),
        this
      );
    }),
    service$1
  );
}
var hasRequiredRpc;
function requireRpc() {
  return (
    hasRequiredRpc ||
      ((hasRequiredRpc = 1),
      (function (B) {
        var U = B;
        U.Service = requireService$1();
      })(rpc)),
    rpc
  );
}
var roots, hasRequiredRoots;
function requireRoots() {
  return hasRequiredRoots || ((hasRequiredRoots = 1), (roots = {})), roots;
}
var hasRequiredIndexMinimal;
function requireIndexMinimal() {
  return (
    hasRequiredIndexMinimal ||
      ((hasRequiredIndexMinimal = 1),
      (function (B) {
        var U = B;
        (U.build = "minimal"),
          (U.Writer = requireWriter()),
          (U.BufferWriter = requireWriter_buffer()),
          (U.Reader = requireReader()),
          (U.BufferReader = requireReader_buffer()),
          (U.util = requireMinimal()),
          (U.rpc = requireRpc()),
          (U.roots = requireRoots()),
          (U.configure = F);
        function F() {
          U.util._configure(),
            U.Writer._configure(U.BufferWriter),
            U.Reader._configure(U.BufferReader);
        }
        F();
      })(indexMinimal)),
    indexMinimal
  );
}
var types = {},
  util = { exports: {} },
  codegen_1,
  hasRequiredCodegen;
function requireCodegen() {
  if (hasRequiredCodegen) return codegen_1;
  (hasRequiredCodegen = 1), (codegen_1 = B);
  function B(U, F) {
    typeof U == "string" && ((F = U), (U = void 0));
    var q = [];
    function j($) {
      if (typeof $ != "string") {
        var W = V();
        if (
          (B.verbose && console.log("codegen: " + W), (W = "return " + W), $)
        ) {
          for (
            var K = Object.keys($),
              G = new Array(K.length + 1),
              H = new Array(K.length),
              Q = 0;
            Q < K.length;

          )
            (G[Q] = K[Q]), (H[Q] = $[K[Q++]]);
          return (G[Q] = W), Function.apply(null, G).apply(null, H);
        }
        return Function(W)();
      }
      for (var z = new Array(arguments.length - 1), Y = 0; Y < z.length; )
        z[Y] = arguments[++Y];
      if (
        ((Y = 0),
        ($ = $.replace(/%([%dfijs])/g, function (Z, se) {
          var ee = z[Y++];
          switch (se) {
            case "d":
            case "f":
              return String(Number(ee));
            case "i":
              return String(Math.floor(ee));
            case "j":
              return JSON.stringify(ee);
            case "s":
              return String(ee);
          }
          return "%";
        })),
        Y !== z.length)
      )
        throw Error("parameter count mismatch");
      return q.push($), j;
    }
    function V($) {
      return (
        "function " +
        ($ || F || "") +
        "(" +
        ((U && U.join(",")) || "") +
        `){
  ` +
        q.join(`
  `) +
        `
}`
      );
    }
    return (j.toString = V), j;
  }
  return (B.verbose = !1), codegen_1;
}
var fetch_1, hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  (hasRequiredFetch = 1), (fetch_1 = q);
  var B = requireAspromise(),
    U = requireInquire(),
    F = U("fs");
  function q(j, V, $) {
    return (
      typeof V == "function" ? (($ = V), (V = {})) : V || (V = {}),
      $
        ? !V.xhr && F && F.readFile
          ? F.readFile(j, function (K, G) {
              return K && typeof XMLHttpRequest < "u"
                ? q.xhr(j, V, $)
                : K
                ? $(K)
                : $(null, V.binary ? G : G.toString("utf8"));
            })
          : q.xhr(j, V, $)
        : B(q, this, j, V)
    );
  }
  return (
    (q.xhr = function (V, $, W) {
      var K = new XMLHttpRequest();
      (K.onreadystatechange = function () {
        if (K.readyState === 4) {
          if (K.status !== 0 && K.status !== 200)
            return W(Error("status " + K.status));
          if ($.binary) {
            var H = K.response;
            if (!H) {
              H = [];
              for (var Q = 0; Q < K.responseText.length; ++Q)
                H.push(K.responseText.charCodeAt(Q) & 255);
            }
            return W(null, typeof Uint8Array < "u" ? new Uint8Array(H) : H);
          }
          return W(null, K.responseText);
        }
      }),
        $.binary &&
          ("overrideMimeType" in K &&
            K.overrideMimeType("text/plain; charset=x-user-defined"),
          (K.responseType = "arraybuffer")),
        K.open("GET", V),
        K.send();
    }),
    fetch_1
  );
}
var path = {},
  hasRequiredPath;
function requirePath() {
  return (
    hasRequiredPath ||
      ((hasRequiredPath = 1),
      (function (B) {
        var U = B,
          F = (U.isAbsolute = function (V) {
            return /^(?:\/|\w+:)/.test(V);
          }),
          q = (U.normalize = function (V) {
            V = V.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
            var $ = V.split("/"),
              W = F(V),
              K = "";
            W && (K = $.shift() + "/");
            for (var G = 0; G < $.length; )
              $[G] === ".."
                ? G > 0 && $[G - 1] !== ".."
                  ? $.splice(--G, 2)
                  : W
                  ? $.splice(G, 1)
                  : ++G
                : $[G] === "."
                ? $.splice(G, 1)
                : ++G;
            return K + $.join("/");
          });
        U.resolve = function (V, $, W) {
          return (
            W || ($ = q($)),
            F($)
              ? $
              : (W || (V = q(V)),
                (V = V.replace(/(?:\/|^)[^/]+$/, "")).length
                  ? q(V + "/" + $)
                  : $)
          );
        };
      })(path)),
    path
  );
}
var namespace, hasRequiredNamespace;
function requireNamespace() {
  if (hasRequiredNamespace) return namespace;
  (hasRequiredNamespace = 1), (namespace = K);
  var B = requireObject();
  ((K.prototype = Object.create(B.prototype)).constructor = K).className =
    "Namespace";
  var U = requireField(),
    F = requireUtil(),
    q = requireOneof(),
    j,
    V,
    $;
  K.fromJSON = function (Q, z) {
    return new K(Q, z.options).addJSON(z.nested);
  };
  function W(H, Q) {
    if (H && H.length) {
      for (var z = {}, Y = 0; Y < H.length; ++Y) z[H[Y].name] = H[Y].toJSON(Q);
      return z;
    }
  }
  (K.arrayToJSON = W),
    (K.isReservedId = function (Q, z) {
      if (Q) {
        for (var Y = 0; Y < Q.length; ++Y)
          if (typeof Q[Y] != "string" && Q[Y][0] <= z && Q[Y][1] > z) return !0;
      }
      return !1;
    }),
    (K.isReservedName = function (Q, z) {
      if (Q) {
        for (var Y = 0; Y < Q.length; ++Y) if (Q[Y] === z) return !0;
      }
      return !1;
    });
  function K(H, Q) {
    B.call(this, H, Q), (this.nested = void 0), (this._nestedArray = null);
  }
  function G(H) {
    return (H._nestedArray = null), H;
  }
  return (
    Object.defineProperty(K.prototype, "nestedArray", {
      get: function () {
        return (
          this._nestedArray || (this._nestedArray = F.toArray(this.nested))
        );
      },
    }),
    (K.prototype.toJSON = function (Q) {
      return F.toObject([
        "options",
        this.options,
        "nested",
        W(this.nestedArray, Q),
      ]);
    }),
    (K.prototype.addJSON = function (Q) {
      var z = this;
      if (Q)
        for (var Y = Object.keys(Q), X = 0, Z; X < Y.length; ++X)
          (Z = Q[Y[X]]),
            z.add(
              (Z.fields !== void 0
                ? j.fromJSON
                : Z.values !== void 0
                ? $.fromJSON
                : Z.methods !== void 0
                ? V.fromJSON
                : Z.id !== void 0
                ? U.fromJSON
                : K.fromJSON)(Y[X], Z)
            );
      return this;
    }),
    (K.prototype.get = function (Q) {
      return (this.nested && this.nested[Q]) || null;
    }),
    (K.prototype.getEnum = function (Q) {
      if (this.nested && this.nested[Q] instanceof $)
        return this.nested[Q].values;
      throw Error("no such enum: " + Q);
    }),
    (K.prototype.add = function (Q) {
      if (
        !(
          (Q instanceof U && Q.extend !== void 0) ||
          Q instanceof j ||
          Q instanceof q ||
          Q instanceof $ ||
          Q instanceof V ||
          Q instanceof K
        )
      )
        throw TypeError("object must be a valid nested object");
      if (!this.nested) this.nested = {};
      else {
        var z = this.get(Q.name);
        if (z)
          if (
            z instanceof K &&
            Q instanceof K &&
            !(z instanceof j || z instanceof V)
          ) {
            for (var Y = z.nestedArray, X = 0; X < Y.length; ++X) Q.add(Y[X]);
            this.remove(z),
              this.nested || (this.nested = {}),
              Q.setOptions(z.options, !0);
          } else throw Error("duplicate name '" + Q.name + "' in " + this);
      }
      return (
        (this.nested[Q.name] = Q),
        this instanceof j ||
          this instanceof V ||
          this instanceof $ ||
          this instanceof U ||
          Q._edition ||
          (Q._edition = Q._defaultEdition),
        Q.onAdd(this),
        G(this)
      );
    }),
    (K.prototype.remove = function (Q) {
      if (!(Q instanceof B))
        throw TypeError("object must be a ReflectionObject");
      if (Q.parent !== this) throw Error(Q + " is not a member of " + this);
      return (
        delete this.nested[Q.name],
        Object.keys(this.nested).length || (this.nested = void 0),
        Q.onRemove(this),
        G(this)
      );
    }),
    (K.prototype.define = function (Q, z) {
      if (F.isString(Q)) Q = Q.split(".");
      else if (!Array.isArray(Q)) throw TypeError("illegal path");
      if (Q && Q.length && Q[0] === "") throw Error("path must be relative");
      for (var Y = this; Q.length > 0; ) {
        var X = Q.shift();
        if (Y.nested && Y.nested[X]) {
          if (((Y = Y.nested[X]), !(Y instanceof K)))
            throw Error("path conflicts with non-namespace objects");
        } else Y.add((Y = new K(X)));
      }
      return z && Y.addJSON(z), Y;
    }),
    (K.prototype.resolveAll = function () {
      var Q = this.nestedArray,
        z = 0;
      for (this.resolve(); z < Q.length; )
        Q[z] instanceof K ? Q[z++].resolveAll() : Q[z++].resolve();
      return this;
    }),
    (K.prototype._resolveFeaturesRecursive = function (Q) {
      return (
        (Q = this._edition || Q),
        B.prototype._resolveFeaturesRecursive.call(this, Q),
        this.nestedArray.forEach((z) => {
          z._resolveFeaturesRecursive(Q);
        }),
        this
      );
    }),
    (K.prototype.lookup = function (Q, z, Y) {
      if (
        (typeof z == "boolean"
          ? ((Y = z), (z = void 0))
          : z && !Array.isArray(z) && (z = [z]),
        F.isString(Q) && Q.length)
      ) {
        if (Q === ".") return this.root;
        Q = Q.split(".");
      } else if (!Q.length) return this;
      if (Q[0] === "") return this.root.lookup(Q.slice(1), z);
      var X = this.get(Q[0]);
      if (X) {
        if (Q.length === 1) {
          if (!z || z.indexOf(X.constructor) > -1) return X;
        } else if (X instanceof K && (X = X.lookup(Q.slice(1), z, !0)))
          return X;
      } else
        for (var Z = 0; Z < this.nestedArray.length; ++Z)
          if (
            this._nestedArray[Z] instanceof K &&
            (X = this._nestedArray[Z].lookup(Q, z, !0))
          )
            return X;
      return this.parent === null || Y ? null : this.parent.lookup(Q, z);
    }),
    (K.prototype.lookupType = function (Q) {
      var z = this.lookup(Q, [j]);
      if (!z) throw Error("no such type: " + Q);
      return z;
    }),
    (K.prototype.lookupEnum = function (Q) {
      var z = this.lookup(Q, [$]);
      if (!z) throw Error("no such Enum '" + Q + "' in " + this);
      return z;
    }),
    (K.prototype.lookupTypeOrEnum = function (Q) {
      var z = this.lookup(Q, [j, $]);
      if (!z) throw Error("no such Type or Enum '" + Q + "' in " + this);
      return z;
    }),
    (K.prototype.lookupService = function (Q) {
      var z = this.lookup(Q, [V]);
      if (!z) throw Error("no such Service '" + Q + "' in " + this);
      return z;
    }),
    (K._configure = function (H, Q, z) {
      (j = H), (V = Q), ($ = z);
    }),
    namespace
  );
}
var mapfield, hasRequiredMapfield;
function requireMapfield() {
  if (hasRequiredMapfield) return mapfield;
  (hasRequiredMapfield = 1), (mapfield = q);
  var B = requireField();
  ((q.prototype = Object.create(B.prototype)).constructor = q).className =
    "MapField";
  var U = requireTypes(),
    F = requireUtil();
  function q(j, V, $, W, K, G) {
    if ((B.call(this, j, V, W, void 0, void 0, K, G), !F.isString($)))
      throw TypeError("keyType must be a string");
    (this.keyType = $), (this.resolvedKeyType = null), (this.map = !0);
  }
  return (
    (q.fromJSON = function (V, $) {
      return new q(V, $.id, $.keyType, $.type, $.options, $.comment);
    }),
    (q.prototype.toJSON = function (V) {
      var $ = V ? !!V.keepComments : !1;
      return F.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        $ ? this.comment : void 0,
      ]);
    }),
    (q.prototype.resolve = function () {
      if (this.resolved) return this;
      if (U.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return B.prototype.resolve.call(this);
    }),
    (q.d = function (V, $, W) {
      return (
        typeof W == "function"
          ? (W = F.decorateType(W).name)
          : W && typeof W == "object" && (W = F.decorateEnum(W).name),
        function (G, H) {
          F.decorateType(G.constructor).add(new q(H, V, $, W));
        }
      );
    }),
    mapfield
  );
}
var method, hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  (hasRequiredMethod = 1), (method = F);
  var B = requireObject();
  ((F.prototype = Object.create(B.prototype)).constructor = F).className =
    "Method";
  var U = requireUtil();
  function F(q, j, V, $, W, K, G, H, Q) {
    if (
      (U.isObject(W)
        ? ((G = W), (W = K = void 0))
        : U.isObject(K) && ((G = K), (K = void 0)),
      !(j === void 0 || U.isString(j)))
    )
      throw TypeError("type must be a string");
    if (!U.isString(V)) throw TypeError("requestType must be a string");
    if (!U.isString($)) throw TypeError("responseType must be a string");
    B.call(this, q, G),
      (this.type = j || "rpc"),
      (this.requestType = V),
      (this.requestStream = W ? !0 : void 0),
      (this.responseType = $),
      (this.responseStream = K ? !0 : void 0),
      (this.resolvedRequestType = null),
      (this.resolvedResponseType = null),
      (this.comment = H),
      (this.parsedOptions = Q);
  }
  return (
    (F.fromJSON = function (j, V) {
      return new F(
        j,
        V.type,
        V.requestType,
        V.responseType,
        V.requestStream,
        V.responseStream,
        V.options,
        V.comment,
        V.parsedOptions
      );
    }),
    (F.prototype.toJSON = function (j) {
      var V = j ? !!j.keepComments : !1;
      return U.toObject([
        "type",
        (this.type !== "rpc" && this.type) || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        V ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions,
      ]);
    }),
    (F.prototype.resolve = function () {
      return this.resolved
        ? this
        : ((this.resolvedRequestType = this.parent.lookupType(
            this.requestType
          )),
          (this.resolvedResponseType = this.parent.lookupType(
            this.responseType
          )),
          B.prototype.resolve.call(this));
    }),
    method
  );
}
var service, hasRequiredService;
function requireService() {
  if (hasRequiredService) return service;
  (hasRequiredService = 1), (service = j);
  var B = requireNamespace();
  ((j.prototype = Object.create(B.prototype)).constructor = j).className =
    "Service";
  var U = requireMethod(),
    F = requireUtil(),
    q = requireRpc();
  function j($, W) {
    B.call(this, $, W), (this.methods = {}), (this._methodsArray = null);
  }
  (j.fromJSON = function (W, K) {
    var G = new j(W, K.options);
    if (K.methods)
      for (var H = Object.keys(K.methods), Q = 0; Q < H.length; ++Q)
        G.add(U.fromJSON(H[Q], K.methods[H[Q]]));
    return (
      K.nested && G.addJSON(K.nested),
      K.edition && (G._edition = K.edition),
      (G.comment = K.comment),
      (G._defaultEdition = "proto3"),
      G
    );
  }),
    (j.prototype.toJSON = function (W) {
      var K = B.prototype.toJSON.call(this, W),
        G = W ? !!W.keepComments : !1;
      return F.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        (K && K.options) || void 0,
        "methods",
        B.arrayToJSON(this.methodsArray, W) || {},
        "nested",
        (K && K.nested) || void 0,
        "comment",
        G ? this.comment : void 0,
      ]);
    }),
    Object.defineProperty(j.prototype, "methodsArray", {
      get: function () {
        return (
          this._methodsArray || (this._methodsArray = F.toArray(this.methods))
        );
      },
    });
  function V($) {
    return ($._methodsArray = null), $;
  }
  return (
    (j.prototype.get = function (W) {
      return this.methods[W] || B.prototype.get.call(this, W);
    }),
    (j.prototype.resolveAll = function () {
      B.prototype.resolve.call(this);
      for (var W = this.methodsArray, K = 0; K < W.length; ++K) W[K].resolve();
      return this;
    }),
    (j.prototype._resolveFeaturesRecursive = function (W) {
      return (
        (W = this._edition || W),
        B.prototype._resolveFeaturesRecursive.call(this, W),
        this.methodsArray.forEach((K) => {
          K._resolveFeaturesRecursive(W);
        }),
        this
      );
    }),
    (j.prototype.add = function (W) {
      if (this.get(W.name))
        throw Error("duplicate name '" + W.name + "' in " + this);
      return W instanceof U
        ? ((this.methods[W.name] = W), (W.parent = this), V(this))
        : B.prototype.add.call(this, W);
    }),
    (j.prototype.remove = function (W) {
      if (W instanceof U) {
        if (this.methods[W.name] !== W)
          throw Error(W + " is not a member of " + this);
        return delete this.methods[W.name], (W.parent = null), V(this);
      }
      return B.prototype.remove.call(this, W);
    }),
    (j.prototype.create = function (W, K, G) {
      for (
        var H = new q.Service(W, K, G), Q = 0, z;
        Q < this.methodsArray.length;
        ++Q
      ) {
        var Y = F.lcFirst((z = this._methodsArray[Q]).resolve().name).replace(
          /[^$\w_]/g,
          ""
        );
        H[Y] = F.codegen(
          ["r", "c"],
          F.isReserved(Y) ? Y + "_" : Y
        )("return this.rpcCall(m,q,s,r,c)")({
          m: z,
          q: z.resolvedRequestType.ctor,
          s: z.resolvedResponseType.ctor,
        });
      }
      return H;
    }),
    service
  );
}
var message, hasRequiredMessage;
function requireMessage() {
  if (hasRequiredMessage) return message;
  (hasRequiredMessage = 1), (message = U);
  var B = requireMinimal();
  function U(F) {
    if (F)
      for (var q = Object.keys(F), j = 0; j < q.length; ++j)
        this[q[j]] = F[q[j]];
  }
  return (
    (U.create = function (q) {
      return this.$type.create(q);
    }),
    (U.encode = function (q, j) {
      return this.$type.encode(q, j);
    }),
    (U.encodeDelimited = function (q, j) {
      return this.$type.encodeDelimited(q, j);
    }),
    (U.decode = function (q) {
      return this.$type.decode(q);
    }),
    (U.decodeDelimited = function (q) {
      return this.$type.decodeDelimited(q);
    }),
    (U.verify = function (q) {
      return this.$type.verify(q);
    }),
    (U.fromObject = function (q) {
      return this.$type.fromObject(q);
    }),
    (U.toObject = function (q, j) {
      return this.$type.toObject(q, j);
    }),
    (U.prototype.toJSON = function () {
      return this.$type.toObject(this, B.toJSONOptions);
    }),
    message
  );
}
var decoder_1, hasRequiredDecoder;
function requireDecoder() {
  if (hasRequiredDecoder) return decoder_1;
  (hasRequiredDecoder = 1), (decoder_1 = j);
  var B = require_enum(),
    U = requireTypes(),
    F = requireUtil();
  function q(V) {
    return "missing required '" + V.name + "'";
  }
  function j(V) {
    for (
      var $ = F.codegen(
          ["r", "l", "e"],
          V.name + "$decode"
        )("if(!(r instanceof Reader))")("r=Reader.create(r)")(
          "var c=l===undefined?r.len:r.pos+l,m=new this.ctor" +
            (V.fieldsArray.filter(function (z) {
              return z.map;
            }).length
              ? ",k,value"
              : "")
        )("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")(
          "switch(t>>>3){"
        ),
        W = 0;
      W < V.fieldsArray.length;
      ++W
    ) {
      var K = V._fieldsArray[W].resolve(),
        G = K.resolvedType instanceof B ? "int32" : K.type,
        H = "m" + F.safeProp(K.name);
      $("case %i: {", K.id),
        K.map
          ? ($("if(%s===util.emptyObject)", H)("%s={}", H)(
              "var c2 = r.uint32()+r.pos"
            ),
            U.defaults[K.keyType] !== void 0
              ? $("k=%j", U.defaults[K.keyType])
              : $("k=null"),
            U.defaults[G] !== void 0
              ? $("value=%j", U.defaults[G])
              : $("value=null"),
            $("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")(
              "case 1: k=r.%s(); break",
              K.keyType
            )("case 2:"),
            U.basic[G] === void 0
              ? $("value=types[%i].decode(r,r.uint32())", W)
              : $("value=r.%s()", G),
            $("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"),
            U.long[K.keyType] !== void 0
              ? $('%s[typeof k==="object"?util.longToHash(k):k]=value', H)
              : $("%s[k]=value", H))
          : K.repeated
          ? ($("if(!(%s&&%s.length))", H, H)("%s=[]", H),
            U.packed[G] !== void 0 &&
              $("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")(
                "%s.push(r.%s())",
                H,
                G
              )("}else"),
            U.basic[G] === void 0
              ? $(
                  K.delimited
                    ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))"
                    : "%s.push(types[%i].decode(r,r.uint32()))",
                  H,
                  W
                )
              : $("%s.push(r.%s())", H, G))
          : U.basic[G] === void 0
          ? $(
              K.delimited
                ? "%s=types[%i].decode(r,undefined,((t&~7)|4))"
                : "%s=types[%i].decode(r,r.uint32())",
              H,
              W
            )
          : $("%s=r.%s()", H, G),
        $("break")("}");
    }
    for (
      $("default:")("r.skipType(t&7)")("break")("}")("}"), W = 0;
      W < V._fieldsArray.length;
      ++W
    ) {
      var Q = V._fieldsArray[W];
      Q.required &&
        $("if(!m.hasOwnProperty(%j))", Q.name)(
          "throw util.ProtocolError(%j,{instance:m})",
          q(Q)
        );
    }
    return $("return m");
  }
  return decoder_1;
}
var verifier_1, hasRequiredVerifier;
function requireVerifier() {
  if (hasRequiredVerifier) return verifier_1;
  (hasRequiredVerifier = 1), (verifier_1 = V);
  var B = require_enum(),
    U = requireUtil();
  function F($, W) {
    return (
      $.name +
      ": " +
      W +
      ($.repeated && W !== "array"
        ? "[]"
        : $.map && W !== "object"
        ? "{k:" + $.keyType + "}"
        : "") +
      " expected"
    );
  }
  function q($, W, K, G) {
    if (W.resolvedType)
      if (W.resolvedType instanceof B) {
        $("switch(%s){", G)("default:")("return%j", F(W, "enum value"));
        for (
          var H = Object.keys(W.resolvedType.values), Q = 0;
          Q < H.length;
          ++Q
        )
          $("case %i:", W.resolvedType.values[H[Q]]);
        $("break")("}");
      } else
        $("{")("var e=types[%i].verify(%s);", K, G)("if(e)")(
          "return%j+e",
          W.name + "."
        )("}");
    else
      switch (W.type) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          $("if(!util.isInteger(%s))", G)("return%j", F(W, "integer"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          $(
            "if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",
            G,
            G,
            G,
            G
          )("return%j", F(W, "integer|Long"));
          break;
        case "float":
        case "double":
          $('if(typeof %s!=="number")', G)("return%j", F(W, "number"));
          break;
        case "bool":
          $('if(typeof %s!=="boolean")', G)("return%j", F(W, "boolean"));
          break;
        case "string":
          $("if(!util.isString(%s))", G)("return%j", F(W, "string"));
          break;
        case "bytes":
          $(
            'if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',
            G,
            G,
            G
          )("return%j", F(W, "buffer"));
          break;
      }
    return $;
  }
  function j($, W, K) {
    switch (W.keyType) {
      case "int32":
      case "uint32":
      case "sint32":
      case "fixed32":
      case "sfixed32":
        $("if(!util.key32Re.test(%s))", K)("return%j", F(W, "integer key"));
        break;
      case "int64":
      case "uint64":
      case "sint64":
      case "fixed64":
      case "sfixed64":
        $("if(!util.key64Re.test(%s))", K)(
          "return%j",
          F(W, "integer|Long key")
        );
        break;
      case "bool":
        $("if(!util.key2Re.test(%s))", K)("return%j", F(W, "boolean key"));
        break;
    }
    return $;
  }
  function V($) {
    var W = U.codegen(
        ["m"],
        $.name + "$verify"
      )('if(typeof m!=="object"||m===null)')("return%j", "object expected"),
      K = $.oneofsArray,
      G = {};
    K.length && W("var p={}");
    for (var H = 0; H < $.fieldsArray.length; ++H) {
      var Q = $._fieldsArray[H].resolve(),
        z = "m" + U.safeProp(Q.name);
      if (
        (Q.optional && W("if(%s!=null&&m.hasOwnProperty(%j)){", z, Q.name),
        Q.map)
      )
        W("if(!util.isObject(%s))", z)("return%j", F(Q, "object"))(
          "var k=Object.keys(%s)",
          z
        )("for(var i=0;i<k.length;++i){"),
          j(W, Q, "k[i]"),
          q(W, Q, H, z + "[k[i]]")("}");
      else if (Q.repeated)
        W("if(!Array.isArray(%s))", z)("return%j", F(Q, "array"))(
          "for(var i=0;i<%s.length;++i){",
          z
        ),
          q(W, Q, H, z + "[i]")("}");
      else {
        if (Q.partOf) {
          var Y = U.safeProp(Q.partOf.name);
          G[Q.partOf.name] === 1 &&
            W("if(p%s===1)", Y)(
              "return%j",
              Q.partOf.name + ": multiple values"
            ),
            (G[Q.partOf.name] = 1),
            W("p%s=1", Y);
        }
        q(W, Q, H, z);
      }
      Q.optional && W("}");
    }
    return W("return null");
  }
  return verifier_1;
}
var converter = {},
  hasRequiredConverter;
function requireConverter() {
  return (
    hasRequiredConverter ||
      ((hasRequiredConverter = 1),
      (function (B) {
        var U = B,
          F = require_enum(),
          q = requireUtil();
        function j($, W, K, G) {
          var H = !1;
          if (W.resolvedType)
            if (W.resolvedType instanceof F) {
              $("switch(d%s){", G);
              for (
                var Q = W.resolvedType.values, z = Object.keys(Q), Y = 0;
                Y < z.length;
                ++Y
              )
                Q[z[Y]] === W.typeDefault &&
                  !H &&
                  ($("default:")(
                    'if(typeof(d%s)==="number"){m%s=d%s;break}',
                    G,
                    G,
                    G
                  ),
                  W.repeated || $("break"),
                  (H = !0)),
                  $("case%j:", z[Y])("case %i:", Q[z[Y]])("m%s=%j", G, Q[z[Y]])(
                    "break"
                  );
              $("}");
            } else
              $('if(typeof d%s!=="object")', G)(
                "throw TypeError(%j)",
                W.fullName + ": object expected"
              )("m%s=types[%i].fromObject(d%s)", G, K, G);
          else {
            var X = !1;
            switch (W.type) {
              case "double":
              case "float":
                $("m%s=Number(d%s)", G, G);
                break;
              case "uint32":
              case "fixed32":
                $("m%s=d%s>>>0", G, G);
                break;
              case "int32":
              case "sint32":
              case "sfixed32":
                $("m%s=d%s|0", G, G);
                break;
              case "uint64":
                X = !0;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                $("if(util.Long)")(
                  "(m%s=util.Long.fromValue(d%s)).unsigned=%j",
                  G,
                  G,
                  X
                )('else if(typeof d%s==="string")', G)(
                  "m%s=parseInt(d%s,10)",
                  G,
                  G
                )('else if(typeof d%s==="number")', G)(
                  "m%s=d%s",
                  G,
                  G
                )('else if(typeof d%s==="object")', G)(
                  "m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",
                  G,
                  G,
                  G,
                  X ? "true" : ""
                );
                break;
              case "bytes":
                $('if(typeof d%s==="string")', G)(
                  "util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",
                  G,
                  G,
                  G
                )("else if(d%s.length >= 0)", G)("m%s=d%s", G, G);
                break;
              case "string":
                $("m%s=String(d%s)", G, G);
                break;
              case "bool":
                $("m%s=Boolean(d%s)", G, G);
                break;
            }
          }
          return $;
        }
        U.fromObject = function (W) {
          var K = W.fieldsArray,
            G = q.codegen(
              ["d"],
              W.name + "$fromObject"
            )("if(d instanceof this.ctor)")("return d");
          if (!K.length) return G("return new this.ctor");
          G("var m=new this.ctor");
          for (var H = 0; H < K.length; ++H) {
            var Q = K[H].resolve(),
              z = q.safeProp(Q.name);
            Q.map
              ? (G("if(d%s){", z)('if(typeof d%s!=="object")', z)(
                  "throw TypeError(%j)",
                  Q.fullName + ": object expected"
                )("m%s={}", z)(
                  "for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",
                  z
                ),
                j(G, Q, H, z + "[ks[i]]")("}")("}"))
              : Q.repeated
              ? (G("if(d%s){", z)("if(!Array.isArray(d%s))", z)(
                  "throw TypeError(%j)",
                  Q.fullName + ": array expected"
                )("m%s=[]", z)("for(var i=0;i<d%s.length;++i){", z),
                j(G, Q, H, z + "[i]")("}")("}"))
              : (Q.resolvedType instanceof F || G("if(d%s!=null){", z),
                j(G, Q, H, z),
                Q.resolvedType instanceof F || G("}"));
          }
          return G("return m");
        };
        function V($, W, K, G) {
          if (W.resolvedType)
            W.resolvedType instanceof F
              ? $(
                  "d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",
                  G,
                  K,
                  G,
                  G,
                  K,
                  G,
                  G
                )
              : $("d%s=types[%i].toObject(m%s,o)", G, K, G);
          else {
            var H = !1;
            switch (W.type) {
              case "double":
              case "float":
                $("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", G, G, G, G);
                break;
              case "uint64":
                H = !0;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                $('if(typeof m%s==="number")', G)(
                  "d%s=o.longs===String?String(m%s):m%s",
                  G,
                  G,
                  G
                )("else")(
                  "d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
                  G,
                  G,
                  G,
                  G,
                  H ? "true" : "",
                  G
                );
                break;
              case "bytes":
                $(
                  "d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
                  G,
                  G,
                  G,
                  G,
                  G
                );
                break;
              default:
                $("d%s=m%s", G, G);
                break;
            }
          }
          return $;
        }
        U.toObject = function (W) {
          var K = W.fieldsArray.slice().sort(q.compareFieldsById);
          if (!K.length) return q.codegen()("return {}");
          for (
            var G = q.codegen(["m", "o"], W.name + "$toObject")("if(!o)")(
                "o={}"
              )("var d={}"),
              H = [],
              Q = [],
              z = [],
              Y = 0;
            Y < K.length;
            ++Y
          )
            K[Y].partOf ||
              (K[Y].resolve().repeated ? H : K[Y].map ? Q : z).push(K[Y]);
          if (H.length) {
            for (G("if(o.arrays||o.defaults){"), Y = 0; Y < H.length; ++Y)
              G("d%s=[]", q.safeProp(H[Y].name));
            G("}");
          }
          if (Q.length) {
            for (G("if(o.objects||o.defaults){"), Y = 0; Y < Q.length; ++Y)
              G("d%s={}", q.safeProp(Q[Y].name));
            G("}");
          }
          if (z.length) {
            for (G("if(o.defaults){"), Y = 0; Y < z.length; ++Y) {
              var X = z[Y],
                Z = q.safeProp(X.name);
              if (X.resolvedType instanceof F)
                G(
                  "d%s=o.enums===String?%j:%j",
                  Z,
                  X.resolvedType.valuesById[X.typeDefault],
                  X.typeDefault
                );
              else if (X.long)
                G("if(util.Long){")(
                  "var n=new util.Long(%i,%i,%j)",
                  X.typeDefault.low,
                  X.typeDefault.high,
                  X.typeDefault.unsigned
                )(
                  "d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",
                  Z
                )("}else")(
                  "d%s=o.longs===String?%j:%i",
                  Z,
                  X.typeDefault.toString(),
                  X.typeDefault.toNumber()
                );
              else if (X.bytes) {
                var se =
                  "[" +
                  Array.prototype.slice.call(X.typeDefault).join(",") +
                  "]";
                G(
                  "if(o.bytes===String)d%s=%j",
                  Z,
                  String.fromCharCode.apply(String, X.typeDefault)
                )("else{")("d%s=%s", Z, se)(
                  "if(o.bytes!==Array)d%s=util.newBuffer(d%s)",
                  Z,
                  Z
                )("}");
              } else G("d%s=%j", Z, X.typeDefault);
            }
            G("}");
          }
          var ee = !1;
          for (Y = 0; Y < K.length; ++Y) {
            var X = K[Y],
              ie = W._fieldsArray.indexOf(X),
              Z = q.safeProp(X.name);
            X.map
              ? (ee || ((ee = !0), G("var ks2")),
                G("if(m%s&&(ks2=Object.keys(m%s)).length){", Z, Z)("d%s={}", Z)(
                  "for(var j=0;j<ks2.length;++j){"
                ),
                V(G, X, ie, Z + "[ks2[j]]")("}"))
              : X.repeated
              ? (G("if(m%s&&m%s.length){", Z, Z)("d%s=[]", Z)(
                  "for(var j=0;j<m%s.length;++j){",
                  Z
                ),
                V(G, X, ie, Z + "[j]")("}"))
              : (G("if(m%s!=null&&m.hasOwnProperty(%j)){", Z, X.name),
                V(G, X, ie, Z),
                X.partOf &&
                  G("if(o.oneofs)")(
                    "d%s=%j",
                    q.safeProp(X.partOf.name),
                    X.name
                  )),
              G("}");
          }
          return G("return d");
        };
      })(converter)),
    converter
  );
}
var wrappers = {},
  hasRequiredWrappers;
function requireWrappers() {
  return (
    hasRequiredWrappers ||
      ((hasRequiredWrappers = 1),
      (function (B) {
        var U = B,
          F = requireMessage();
        U[".google.protobuf.Any"] = {
          fromObject: function (q) {
            if (q && q["@type"]) {
              var j = q["@type"].substring(q["@type"].lastIndexOf("/") + 1),
                V = this.lookup(j);
              if (V) {
                var $ =
                  q["@type"].charAt(0) === "."
                    ? q["@type"].slice(1)
                    : q["@type"];
                return (
                  $.indexOf("/") === -1 && ($ = "/" + $),
                  this.create({
                    type_url: $,
                    value: V.encode(V.fromObject(q)).finish(),
                  })
                );
              }
            }
            return this.fromObject(q);
          },
          toObject: function (q, j) {
            var V = "type.googleapis.com/",
              $ = "",
              W = "";
            if (j && j.json && q.type_url && q.value) {
              (W = q.type_url.substring(q.type_url.lastIndexOf("/") + 1)),
                ($ = q.type_url.substring(0, q.type_url.lastIndexOf("/") + 1));
              var K = this.lookup(W);
              K && (q = K.decode(q.value));
            }
            if (!(q instanceof this.ctor) && q instanceof F) {
              var G = q.$type.toObject(q, j),
                H =
                  q.$type.fullName[0] === "."
                    ? q.$type.fullName.slice(1)
                    : q.$type.fullName;
              return $ === "" && ($ = V), (W = $ + H), (G["@type"] = W), G;
            }
            return this.toObject(q, j);
          },
        };
      })(wrappers)),
    wrappers
  );
}
var type, hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  (hasRequiredType = 1), (type = Z);
  var B = requireNamespace();
  ((Z.prototype = Object.create(B.prototype)).constructor = Z).className =
    "Type";
  var U = require_enum(),
    F = requireOneof(),
    q = requireField(),
    j = requireMapfield(),
    V = requireService(),
    $ = requireMessage(),
    W = requireReader(),
    K = requireWriter(),
    G = requireUtil(),
    H = requireEncoder(),
    Q = requireDecoder(),
    z = requireVerifier(),
    Y = requireConverter(),
    X = requireWrappers();
  function Z(ee, ie) {
    B.call(this, ee, ie),
      (this.fields = {}),
      (this.oneofs = void 0),
      (this.extensions = void 0),
      (this.reserved = void 0),
      (this.group = void 0),
      (this._fieldsById = null),
      (this._fieldsArray = null),
      (this._oneofsArray = null),
      (this._ctor = null);
  }
  Object.defineProperties(Z.prototype, {
    fieldsById: {
      get: function () {
        if (this._fieldsById) return this._fieldsById;
        this._fieldsById = {};
        for (var ee = Object.keys(this.fields), ie = 0; ie < ee.length; ++ie) {
          var re = this.fields[ee[ie]],
            te = re.id;
          if (this._fieldsById[te])
            throw Error("duplicate id " + te + " in " + this);
          this._fieldsById[te] = re;
        }
        return this._fieldsById;
      },
    },
    fieldsArray: {
      get: function () {
        return (
          this._fieldsArray || (this._fieldsArray = G.toArray(this.fields))
        );
      },
    },
    oneofsArray: {
      get: function () {
        return (
          this._oneofsArray || (this._oneofsArray = G.toArray(this.oneofs))
        );
      },
    },
    ctor: {
      get: function () {
        return this._ctor || (this.ctor = Z.generateConstructor(this)());
      },
      set: function (ee) {
        var ie = ee.prototype;
        ie instanceof $ ||
          (((ee.prototype = new $()).constructor = ee),
          G.merge(ee.prototype, ie)),
          (ee.$type = ee.prototype.$type = this),
          G.merge(ee, $, !0),
          (this._ctor = ee);
        for (var re = 0; re < this.fieldsArray.length; ++re)
          this._fieldsArray[re].resolve();
        var te = {};
        for (re = 0; re < this.oneofsArray.length; ++re)
          te[this._oneofsArray[re].resolve().name] = {
            get: G.oneOfGetter(this._oneofsArray[re].oneof),
            set: G.oneOfSetter(this._oneofsArray[re].oneof),
          };
        re && Object.defineProperties(ee.prototype, te);
      },
    },
  }),
    (Z.generateConstructor = function (ie) {
      for (
        var re = G.codegen(["p"], ie.name), te = 0, ne;
        te < ie.fieldsArray.length;
        ++te
      )
        (ne = ie._fieldsArray[te]).map
          ? re("this%s={}", G.safeProp(ne.name))
          : ne.repeated && re("this%s=[]", G.safeProp(ne.name));
      return re(
        "if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)"
      )("this[ks[i]]=p[ks[i]]");
    });
  function se(ee) {
    return (
      (ee._fieldsById = ee._fieldsArray = ee._oneofsArray = null),
      delete ee.encode,
      delete ee.decode,
      delete ee.verify,
      ee
    );
  }
  return (
    (Z.fromJSON = function (ie, re) {
      var te = new Z(ie, re.options);
      (te.extensions = re.extensions), (te.reserved = re.reserved);
      for (var ne = Object.keys(re.fields), oe = 0; oe < ne.length; ++oe)
        te.add(
          (typeof re.fields[ne[oe]].keyType < "u" ? j.fromJSON : q.fromJSON)(
            ne[oe],
            re.fields[ne[oe]]
          )
        );
      if (re.oneofs)
        for (ne = Object.keys(re.oneofs), oe = 0; oe < ne.length; ++oe)
          te.add(F.fromJSON(ne[oe], re.oneofs[ne[oe]]));
      if (re.nested)
        for (ne = Object.keys(re.nested), oe = 0; oe < ne.length; ++oe) {
          var ce = re.nested[ne[oe]];
          te.add(
            (ce.id !== void 0
              ? q.fromJSON
              : ce.fields !== void 0
              ? Z.fromJSON
              : ce.values !== void 0
              ? U.fromJSON
              : ce.methods !== void 0
              ? V.fromJSON
              : B.fromJSON)(ne[oe], ce)
          );
        }
      return (
        re.extensions &&
          re.extensions.length &&
          (te.extensions = re.extensions),
        re.reserved && re.reserved.length && (te.reserved = re.reserved),
        re.group && (te.group = !0),
        re.comment && (te.comment = re.comment),
        re.edition && (te._edition = re.edition),
        (te._defaultEdition = "proto3"),
        te
      );
    }),
    (Z.prototype.toJSON = function (ie) {
      var re = B.prototype.toJSON.call(this, ie),
        te = ie ? !!ie.keepComments : !1;
      return G.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        (re && re.options) || void 0,
        "oneofs",
        B.arrayToJSON(this.oneofsArray, ie),
        "fields",
        B.arrayToJSON(
          this.fieldsArray.filter(function (ne) {
            return !ne.declaringField;
          }),
          ie
        ) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        (re && re.nested) || void 0,
        "comment",
        te ? this.comment : void 0,
      ]);
    }),
    (Z.prototype.resolveAll = function () {
      B.prototype.resolveAll.call(this);
      var ie = this.oneofsArray;
      for (te = 0; te < ie.length; ) ie[te++].resolve();
      for (var re = this.fieldsArray, te = 0; te < re.length; )
        re[te++].resolve();
      return this;
    }),
    (Z.prototype._resolveFeaturesRecursive = function (ie) {
      return (
        (ie = this._edition || ie),
        B.prototype._resolveFeaturesRecursive.call(this, ie),
        this.oneofsArray.forEach((re) => {
          re._resolveFeatures(ie);
        }),
        this.fieldsArray.forEach((re) => {
          re._resolveFeatures(ie);
        }),
        this
      );
    }),
    (Z.prototype.get = function (ie) {
      return (
        this.fields[ie] ||
        (this.oneofs && this.oneofs[ie]) ||
        (this.nested && this.nested[ie]) ||
        null
      );
    }),
    (Z.prototype.add = function (ie) {
      if (this.get(ie.name))
        throw Error("duplicate name '" + ie.name + "' in " + this);
      if (ie instanceof q && ie.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[ie.id] : this.fieldsById[ie.id])
          throw Error("duplicate id " + ie.id + " in " + this);
        if (this.isReservedId(ie.id))
          throw Error("id " + ie.id + " is reserved in " + this);
        if (this.isReservedName(ie.name))
          throw Error("name '" + ie.name + "' is reserved in " + this);
        return (
          ie.parent && ie.parent.remove(ie),
          (this.fields[ie.name] = ie),
          (ie.message = this),
          ie.onAdd(this),
          se(this)
        );
      }
      return ie instanceof F
        ? (this.oneofs || (this.oneofs = {}),
          (this.oneofs[ie.name] = ie),
          ie.onAdd(this),
          se(this))
        : B.prototype.add.call(this, ie);
    }),
    (Z.prototype.remove = function (ie) {
      if (ie instanceof q && ie.extend === void 0) {
        if (!this.fields || this.fields[ie.name] !== ie)
          throw Error(ie + " is not a member of " + this);
        return (
          delete this.fields[ie.name],
          (ie.parent = null),
          ie.onRemove(this),
          se(this)
        );
      }
      if (ie instanceof F) {
        if (!this.oneofs || this.oneofs[ie.name] !== ie)
          throw Error(ie + " is not a member of " + this);
        return (
          delete this.oneofs[ie.name],
          (ie.parent = null),
          ie.onRemove(this),
          se(this)
        );
      }
      return B.prototype.remove.call(this, ie);
    }),
    (Z.prototype.isReservedId = function (ie) {
      return B.isReservedId(this.reserved, ie);
    }),
    (Z.prototype.isReservedName = function (ie) {
      return B.isReservedName(this.reserved, ie);
    }),
    (Z.prototype.create = function (ie) {
      return new this.ctor(ie);
    }),
    (Z.prototype.setup = function () {
      for (
        var ie = this.fullName, re = [], te = 0;
        te < this.fieldsArray.length;
        ++te
      )
        re.push(this._fieldsArray[te].resolve().resolvedType);
      (this.encode = H(this)({ Writer: K, types: re, util: G })),
        (this.decode = Q(this)({ Reader: W, types: re, util: G })),
        (this.verify = z(this)({ types: re, util: G })),
        (this.fromObject = Y.fromObject(this)({ types: re, util: G })),
        (this.toObject = Y.toObject(this)({ types: re, util: G }));
      var ne = X[ie];
      if (ne) {
        var oe = Object.create(this);
        (oe.fromObject = this.fromObject),
          (this.fromObject = ne.fromObject.bind(oe)),
          (oe.toObject = this.toObject),
          (this.toObject = ne.toObject.bind(oe));
      }
      return this;
    }),
    (Z.prototype.encode = function (ie, re) {
      return this.setup().encode(ie, re);
    }),
    (Z.prototype.encodeDelimited = function (ie, re) {
      return this.encode(ie, re && re.len ? re.fork() : re).ldelim();
    }),
    (Z.prototype.decode = function (ie, re) {
      return this.setup().decode(ie, re);
    }),
    (Z.prototype.decodeDelimited = function (ie) {
      return (
        ie instanceof W || (ie = W.create(ie)), this.decode(ie, ie.uint32())
      );
    }),
    (Z.prototype.verify = function (ie) {
      return this.setup().verify(ie);
    }),
    (Z.prototype.fromObject = function (ie) {
      return this.setup().fromObject(ie);
    }),
    (Z.prototype.toObject = function (ie, re) {
      return this.setup().toObject(ie, re);
    }),
    (Z.d = function (ie) {
      return function (te) {
        G.decorateType(te, ie);
      };
    }),
    type
  );
}
var root, hasRequiredRoot;
function requireRoot() {
  if (hasRequiredRoot) return root;
  (hasRequiredRoot = 1), (root = K);
  var B = requireNamespace();
  ((K.prototype = Object.create(B.prototype)).constructor = K).className =
    "Root";
  var U = requireField(),
    F = require_enum(),
    q = requireOneof(),
    j = requireUtil(),
    V,
    $,
    W;
  function K(z) {
    B.call(this, "", z),
      (this.deferred = []),
      (this.files = []),
      (this._edition = "proto2");
  }
  (K.fromJSON = function (Y, X) {
    return (
      X || (X = new K()),
      Y.options && X.setOptions(Y.options),
      X.addJSON(Y.nested).resolveAll()
    );
  }),
    (K.prototype.resolvePath = j.path.resolve),
    (K.prototype.fetch = j.fetch);
  function G() {}
  (K.prototype.load = function z(Y, X, Z) {
    typeof X == "function" && ((Z = X), (X = void 0));
    var se = this;
    if (!Z) return j.asPromise(z, se, Y, X);
    var ee = Z === G;
    function ie(he, de) {
      if (Z) {
        if (ee) throw he;
        var pe = Z;
        (Z = null), de && de.resolveAll(), pe(he, de);
      }
    }
    function re(he) {
      var de = he.lastIndexOf("google/protobuf/");
      if (de > -1) {
        var pe = he.substring(de);
        if (pe in W) return pe;
      }
      return null;
    }
    function te(he, de) {
      try {
        if (
          (j.isString(de) && de.charAt(0) === "{" && (de = JSON.parse(de)),
          !j.isString(de))
        )
          se.setOptions(de.options).addJSON(de.nested);
        else {
          $.filename = he;
          var pe = $(de, se, X),
            Te,
            Pe = 0;
          if (pe.imports)
            for (; Pe < pe.imports.length; ++Pe)
              (Te = re(pe.imports[Pe]) || se.resolvePath(he, pe.imports[Pe])) &&
                ne(Te);
          if (pe.weakImports)
            for (Pe = 0; Pe < pe.weakImports.length; ++Pe)
              (Te =
                re(pe.weakImports[Pe]) ||
                se.resolvePath(he, pe.weakImports[Pe])) && ne(Te, !0);
        }
      } catch (ye) {
        ie(ye);
      }
      !ee && !oe && ie(null, se);
    }
    function ne(he, de) {
      if (((he = re(he) || he), !(se.files.indexOf(he) > -1))) {
        if ((se.files.push(he), he in W)) {
          ee
            ? te(he, W[he])
            : (++oe,
              setTimeout(function () {
                --oe, te(he, W[he]);
              }));
          return;
        }
        if (ee) {
          var pe;
          try {
            pe = j.fs.readFileSync(he).toString("utf8");
          } catch (Te) {
            de || ie(Te);
            return;
          }
          te(he, pe);
        } else
          ++oe,
            se.fetch(he, function (Te, Pe) {
              if ((--oe, !!Z)) {
                if (Te) {
                  de ? oe || ie(null, se) : ie(Te);
                  return;
                }
                te(he, Pe);
              }
            });
      }
    }
    var oe = 0;
    j.isString(Y) && (Y = [Y]);
    for (var ce = 0, le; ce < Y.length; ++ce)
      (le = se.resolvePath("", Y[ce])) && ne(le);
    return se.resolveAll(), ee || oe || ie(null, se), se;
  }),
    (K.prototype.loadSync = function (Y, X) {
      if (!j.isNode) throw Error("not supported");
      return this.load(Y, X, G);
    }),
    (K.prototype.resolveAll = function () {
      if (this.deferred.length)
        throw Error(
          "unresolvable extensions: " +
            this.deferred
              .map(function (Y) {
                return "'extend " + Y.extend + "' in " + Y.parent.fullName;
              })
              .join(", ")
        );
      return B.prototype.resolveAll.call(this);
    });
  var H = /^[A-Z]/;
  function Q(z, Y) {
    var X = Y.parent.lookup(Y.extend);
    if (X) {
      var Z = new U(Y.fullName, Y.id, Y.type, Y.rule, void 0, Y.options);
      return (
        X.get(Z.name) ||
          ((Z.declaringField = Y), (Y.extensionField = Z), X.add(Z)),
        !0
      );
    }
    return !1;
  }
  return (
    (K.prototype._handleAdd = function (Y) {
      if (Y instanceof U)
        Y.extend !== void 0 &&
          !Y.extensionField &&
          (Q(this, Y) || this.deferred.push(Y));
      else if (Y instanceof F) H.test(Y.name) && (Y.parent[Y.name] = Y.values);
      else if (!(Y instanceof q)) {
        if (Y instanceof V)
          for (var X = 0; X < this.deferred.length; )
            Q(this, this.deferred[X]) ? this.deferred.splice(X, 1) : ++X;
        for (var Z = 0; Z < Y.nestedArray.length; ++Z)
          this._handleAdd(Y._nestedArray[Z]);
        H.test(Y.name) && (Y.parent[Y.name] = Y);
      }
    }),
    (K.prototype._handleRemove = function (Y) {
      if (Y instanceof U) {
        if (Y.extend !== void 0)
          if (Y.extensionField)
            Y.extensionField.parent.remove(Y.extensionField),
              (Y.extensionField = null);
          else {
            var X = this.deferred.indexOf(Y);
            X > -1 && this.deferred.splice(X, 1);
          }
      } else if (Y instanceof F) H.test(Y.name) && delete Y.parent[Y.name];
      else if (Y instanceof B) {
        for (var Z = 0; Z < Y.nestedArray.length; ++Z)
          this._handleRemove(Y._nestedArray[Z]);
        H.test(Y.name) && delete Y.parent[Y.name];
      }
    }),
    (K._configure = function (z, Y, X) {
      (V = z), ($ = Y), (W = X);
    }),
    root
  );
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util.exports;
  hasRequiredUtil = 1;
  var B = (util.exports = requireMinimal()),
    U = requireRoots(),
    F,
    q;
  (B.codegen = requireCodegen()),
    (B.fetch = requireFetch()),
    (B.path = requirePath()),
    (B.fs = B.inquire("fs")),
    (B.toArray = function (G) {
      if (G) {
        for (
          var H = Object.keys(G), Q = new Array(H.length), z = 0;
          z < H.length;

        )
          Q[z] = G[H[z++]];
        return Q;
      }
      return [];
    }),
    (B.toObject = function (G) {
      for (var H = {}, Q = 0; Q < G.length; ) {
        var z = G[Q++],
          Y = G[Q++];
        Y !== void 0 && (H[z] = Y);
      }
      return H;
    });
  var j = /\\/g,
    V = /"/g;
  (B.isReserved = function (G) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(
      G
    );
  }),
    (B.safeProp = function (G) {
      return !/^[$\w_]+$/.test(G) || B.isReserved(G)
        ? '["' + G.replace(j, "\\\\").replace(V, '\\"') + '"]'
        : "." + G;
    }),
    (B.ucFirst = function (G) {
      return G.charAt(0).toUpperCase() + G.substring(1);
    });
  var $ = /_([a-z])/g;
  (B.camelCase = function (G) {
    return (
      G.substring(0, 1) +
      G.substring(1).replace($, function (H, Q) {
        return Q.toUpperCase();
      })
    );
  }),
    (B.compareFieldsById = function (G, H) {
      return G.id - H.id;
    }),
    (B.decorateType = function (G, H) {
      if (G.$type)
        return (
          H &&
            G.$type.name !== H &&
            (B.decorateRoot.remove(G.$type),
            (G.$type.name = H),
            B.decorateRoot.add(G.$type)),
          G.$type
        );
      F || (F = requireType());
      var Q = new F(H || G.name);
      return (
        B.decorateRoot.add(Q),
        (Q.ctor = G),
        Object.defineProperty(G, "$type", { value: Q, enumerable: !1 }),
        Object.defineProperty(G.prototype, "$type", {
          value: Q,
          enumerable: !1,
        }),
        Q
      );
    });
  var W = 0;
  return (
    (B.decorateEnum = function (G) {
      if (G.$type) return G.$type;
      q || (q = require_enum());
      var H = new q("Enum" + W++, G);
      return (
        B.decorateRoot.add(H),
        Object.defineProperty(G, "$type", { value: H, enumerable: !1 }),
        H
      );
    }),
    (B.setProperty = function (G, H, Q, z) {
      function Y(X, Z, se) {
        var ee = Z.shift();
        if (ee === "__proto__" || ee === "prototype") return X;
        if (Z.length > 0) X[ee] = Y(X[ee] || {}, Z, se);
        else {
          var ie = X[ee];
          if (ie && z) return X;
          ie && (se = [].concat(ie).concat(se)), (X[ee] = se);
        }
        return X;
      }
      if (typeof G != "object") throw TypeError("dst must be an object");
      if (!H) throw TypeError("path must be specified");
      return (H = H.split(".")), Y(G, H, Q);
    }),
    Object.defineProperty(B, "decorateRoot", {
      get: function () {
        return U.decorated || (U.decorated = new (requireRoot())());
      },
    }),
    util.exports
  );
}
var hasRequiredTypes;
function requireTypes() {
  return (
    hasRequiredTypes ||
      ((hasRequiredTypes = 1),
      (function (B) {
        var U = B,
          F = requireUtil(),
          q = [
            "double",
            "float",
            "int32",
            "uint32",
            "sint32",
            "fixed32",
            "sfixed32",
            "int64",
            "uint64",
            "sint64",
            "fixed64",
            "sfixed64",
            "bool",
            "string",
            "bytes",
          ];
        function j(V, $) {
          var W = 0,
            K = {};
          for ($ |= 0; W < V.length; ) K[q[W + $]] = V[W++];
          return K;
        }
        (U.basic = j([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2])),
          (U.defaults = j([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            !1,
            "",
            F.emptyArray,
            null,
          ])),
          (U.long = j([0, 0, 0, 1, 1], 7)),
          (U.mapKey = j([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2)),
          (U.packed = j([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]));
      })(types)),
    types
  );
}
var field, hasRequiredField;
function requireField() {
  if (hasRequiredField) return field;
  (hasRequiredField = 1), (field = $);
  var B = requireObject();
  (($.prototype = Object.create(B.prototype)).constructor = $).className =
    "Field";
  var U = require_enum(),
    F = requireTypes(),
    q = requireUtil(),
    j,
    V = /^required|optional|repeated$/;
  $.fromJSON = function (K, G) {
    var H = new $(K, G.id, G.type, G.rule, G.extend, G.options, G.comment);
    return (
      G.edition && (H._edition = G.edition), (H._defaultEdition = "proto3"), H
    );
  };
  function $(W, K, G, H, Q, z, Y) {
    if (
      (q.isObject(H)
        ? ((Y = Q), (z = H), (H = Q = void 0))
        : q.isObject(Q) && ((Y = z), (z = Q), (Q = void 0)),
      B.call(this, W, z),
      !q.isInteger(K) || K < 0)
    )
      throw TypeError("id must be a non-negative integer");
    if (!q.isString(G)) throw TypeError("type must be a string");
    if (H !== void 0 && !V.test((H = H.toString().toLowerCase())))
      throw TypeError("rule must be a string rule");
    if (Q !== void 0 && !q.isString(Q))
      throw TypeError("extend must be a string");
    H === "proto3_optional" && (H = "optional"),
      (this.rule = H && H !== "optional" ? H : void 0),
      (this.type = G),
      (this.id = K),
      (this.extend = Q || void 0),
      (this.repeated = H === "repeated"),
      (this.map = !1),
      (this.message = null),
      (this.partOf = null),
      (this.typeDefault = null),
      (this.defaultValue = null),
      (this.long = q.Long ? F.long[G] !== void 0 : !1),
      (this.bytes = G === "bytes"),
      (this.resolvedType = null),
      (this.extensionField = null),
      (this.declaringField = null),
      (this.comment = Y);
  }
  return (
    Object.defineProperty($.prototype, "required", {
      get: function () {
        return this._features.field_presence === "LEGACY_REQUIRED";
      },
    }),
    Object.defineProperty($.prototype, "optional", {
      get: function () {
        return !this.required;
      },
    }),
    Object.defineProperty($.prototype, "delimited", {
      get: function () {
        return (
          this.resolvedType instanceof j &&
          this._features.message_encoding === "DELIMITED"
        );
      },
    }),
    Object.defineProperty($.prototype, "packed", {
      get: function () {
        return this._features.repeated_field_encoding === "PACKED";
      },
    }),
    Object.defineProperty($.prototype, "hasPresence", {
      get: function () {
        return this.repeated || this.map
          ? !1
          : this.partOf ||
              this.declaringField ||
              this.extensionField ||
              this._features.field_presence !== "IMPLICIT";
      },
    }),
    ($.prototype.setOption = function (K, G, H) {
      return B.prototype.setOption.call(this, K, G, H);
    }),
    ($.prototype.toJSON = function (K) {
      var G = K ? !!K.keepComments : !1;
      return q.toObject([
        "edition",
        this._editionToJSON(),
        "rule",
        (this.rule !== "optional" && this.rule) || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        G ? this.comment : void 0,
      ]);
    }),
    ($.prototype.resolve = function () {
      if (this.resolved) return this;
      if (
        ((this.typeDefault = F.defaults[this.type]) === void 0
          ? ((this.resolvedType = (
              this.declaringField ? this.declaringField.parent : this.parent
            ).lookupTypeOrEnum(this.type)),
            this.resolvedType instanceof j
              ? (this.typeDefault = null)
              : (this.typeDefault =
                  this.resolvedType.values[
                    Object.keys(this.resolvedType.values)[0]
                  ]))
          : this.options &&
            this.options.proto3_optional &&
            (this.typeDefault = null),
        this.options &&
          this.options.default != null &&
          ((this.typeDefault = this.options.default),
          this.resolvedType instanceof U &&
            typeof this.typeDefault == "string" &&
            (this.typeDefault = this.resolvedType.values[this.typeDefault])),
        this.options &&
          (this.options.packed !== void 0 &&
            this.resolvedType &&
            !(this.resolvedType instanceof U) &&
            delete this.options.packed,
          Object.keys(this.options).length || (this.options = void 0)),
        this.long)
      )
        (this.typeDefault = q.Long.fromNumber(
          this.typeDefault,
          this.type.charAt(0) === "u"
        )),
          Object.freeze && Object.freeze(this.typeDefault);
      else if (this.bytes && typeof this.typeDefault == "string") {
        var K;
        q.base64.test(this.typeDefault)
          ? q.base64.decode(
              this.typeDefault,
              (K = q.newBuffer(q.base64.length(this.typeDefault))),
              0
            )
          : q.utf8.write(
              this.typeDefault,
              (K = q.newBuffer(q.utf8.length(this.typeDefault))),
              0
            ),
          (this.typeDefault = K);
      }
      return (
        this.map
          ? (this.defaultValue = q.emptyObject)
          : this.repeated
          ? (this.defaultValue = q.emptyArray)
          : (this.defaultValue = this.typeDefault),
        this.parent instanceof j &&
          (this.parent.ctor.prototype[this.name] = this.defaultValue),
        B.prototype.resolve.call(this)
      );
    }),
    ($.prototype._inferLegacyProtoFeatures = function (K) {
      if (K !== "proto2" && K !== "proto3") return {};
      var G = {};
      return (
        this.resolve(),
        this.rule === "required" && (G.field_presence = "LEGACY_REQUIRED"),
        this.resolvedType instanceof j &&
          this.resolvedType.group &&
          (G.message_encoding = "DELIMITED"),
        this.getOption("packed") === !0
          ? (G.repeated_field_encoding = "PACKED")
          : this.getOption("packed") === !1 &&
            (G.repeated_field_encoding = "EXPANDED"),
        G
      );
    }),
    ($.prototype._resolveFeatures = function (K) {
      return B.prototype._resolveFeatures.call(this, this._edition || K);
    }),
    ($.d = function (K, G, H, Q) {
      return (
        typeof G == "function"
          ? (G = q.decorateType(G).name)
          : G && typeof G == "object" && (G = q.decorateEnum(G).name),
        function (Y, X) {
          q.decorateType(Y.constructor).add(new $(X, K, G, H, { default: Q }));
        }
      );
    }),
    ($._configure = function (K) {
      j = K;
    }),
    field
  );
}
var oneof, hasRequiredOneof;
function requireOneof() {
  if (hasRequiredOneof) return oneof;
  (hasRequiredOneof = 1), (oneof = q);
  var B = requireObject();
  ((q.prototype = Object.create(B.prototype)).constructor = q).className =
    "OneOf";
  var U = requireField(),
    F = requireUtil();
  function q(V, $, W, K) {
    if (
      (Array.isArray($) || ((W = $), ($ = void 0)),
      B.call(this, V, W),
      !($ === void 0 || Array.isArray($)))
    )
      throw TypeError("fieldNames must be an Array");
    (this.oneof = $ || []), (this.fieldsArray = []), (this.comment = K);
  }
  (q.fromJSON = function ($, W) {
    return new q($, W.oneof, W.options, W.comment);
  }),
    (q.prototype.toJSON = function ($) {
      var W = $ ? !!$.keepComments : !1;
      return F.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        W ? this.comment : void 0,
      ]);
    });
  function j(V) {
    if (V.parent)
      for (var $ = 0; $ < V.fieldsArray.length; ++$)
        V.fieldsArray[$].parent || V.parent.add(V.fieldsArray[$]);
  }
  return (
    (q.prototype.add = function ($) {
      if (!($ instanceof U)) throw TypeError("field must be a Field");
      return (
        $.parent && $.parent !== this.parent && $.parent.remove($),
        this.oneof.push($.name),
        this.fieldsArray.push($),
        ($.partOf = this),
        j(this),
        this
      );
    }),
    (q.prototype.remove = function ($) {
      if (!($ instanceof U)) throw TypeError("field must be a Field");
      var W = this.fieldsArray.indexOf($);
      if (W < 0) throw Error($ + " is not a member of " + this);
      return (
        this.fieldsArray.splice(W, 1),
        (W = this.oneof.indexOf($.name)),
        W > -1 && this.oneof.splice(W, 1),
        ($.partOf = null),
        this
      );
    }),
    (q.prototype.onAdd = function ($) {
      B.prototype.onAdd.call(this, $);
      for (var W = this, K = 0; K < this.oneof.length; ++K) {
        var G = $.get(this.oneof[K]);
        G && !G.partOf && ((G.partOf = W), W.fieldsArray.push(G));
      }
      j(this);
    }),
    (q.prototype.onRemove = function ($) {
      for (var W = 0, K; W < this.fieldsArray.length; ++W)
        (K = this.fieldsArray[W]).parent && K.parent.remove(K);
      B.prototype.onRemove.call(this, $);
    }),
    Object.defineProperty(q.prototype, "isProto3Optional", {
      get: function () {
        if (this.fieldsArray == null || this.fieldsArray.length !== 1)
          return !1;
        var V = this.fieldsArray[0];
        return V.options != null && V.options.proto3_optional === !0;
      },
    }),
    (q.d = function () {
      for (var $ = new Array(arguments.length), W = 0; W < arguments.length; )
        $[W] = arguments[W++];
      return function (G, H) {
        F.decorateType(G.constructor).add(new q(H, $)),
          Object.defineProperty(G, H, {
            get: F.oneOfGetter($),
            set: F.oneOfSetter($),
          });
      };
    }),
    oneof
  );
}
var object, hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  (hasRequiredObject = 1), (object = $), ($.className = "ReflectionObject");
  const B = requireOneof();
  var U = requireUtil(),
    F,
    q = {
      enum_type: "OPEN",
      field_presence: "EXPLICIT",
      json_format: "ALLOW",
      message_encoding: "LENGTH_PREFIXED",
      repeated_field_encoding: "PACKED",
      utf8_validation: "VERIFY",
    },
    j = {
      enum_type: "CLOSED",
      field_presence: "EXPLICIT",
      json_format: "LEGACY_BEST_EFFORT",
      message_encoding: "LENGTH_PREFIXED",
      repeated_field_encoding: "EXPANDED",
      utf8_validation: "NONE",
    },
    V = {
      enum_type: "OPEN",
      field_presence: "IMPLICIT",
      json_format: "ALLOW",
      message_encoding: "LENGTH_PREFIXED",
      repeated_field_encoding: "PACKED",
      utf8_validation: "VERIFY",
    };
  function $(W, K) {
    if (!U.isString(W)) throw TypeError("name must be a string");
    if (K && !U.isObject(K)) throw TypeError("options must be an object");
    (this.options = K),
      (this.parsedOptions = null),
      (this.name = W),
      (this._edition = null),
      (this._defaultEdition = "proto2"),
      (this._features = {}),
      (this.parent = null),
      (this.resolved = !1),
      (this.comment = null),
      (this.filename = null);
  }
  return (
    Object.defineProperties($.prototype, {
      root: {
        get: function () {
          for (var W = this; W.parent !== null; ) W = W.parent;
          return W;
        },
      },
      fullName: {
        get: function () {
          for (var W = [this.name], K = this.parent; K; )
            W.unshift(K.name), (K = K.parent);
          return W.join(".");
        },
      },
    }),
    ($.prototype.toJSON = function () {
      throw Error();
    }),
    ($.prototype.onAdd = function (K) {
      this.parent && this.parent !== K && this.parent.remove(this),
        (this.parent = K),
        (this.resolved = !1);
      var G = K.root;
      G instanceof F && G._handleAdd(this);
    }),
    ($.prototype.onRemove = function (K) {
      var G = K.root;
      G instanceof F && G._handleRemove(this),
        (this.parent = null),
        (this.resolved = !1);
    }),
    ($.prototype.resolve = function () {
      return this.resolved
        ? this
        : (this instanceof F &&
            (this._resolveFeaturesRecursive(this._edition),
            (this.resolved = !0)),
          this);
    }),
    ($.prototype._resolveFeaturesRecursive = function (K) {
      return this._resolveFeatures(this._edition || K);
    }),
    ($.prototype._resolveFeatures = function (K) {
      var G = {};
      if (!K) throw new Error("Unknown edition for " + this.fullName);
      var H = Object.assign(
        this.options ? Object.assign({}, this.options.features) : {},
        this._inferLegacyProtoFeatures(K)
      );
      if (this._edition) {
        if (K === "proto2") G = Object.assign({}, j);
        else if (K === "proto3") G = Object.assign({}, V);
        else if (K === "2023") G = Object.assign({}, q);
        else throw new Error("Unknown edition: " + K);
        this._features = Object.assign(G, H || {});
        return;
      }
      if (this.partOf instanceof B) {
        var Q = Object.assign({}, this.partOf._features);
        this._features = Object.assign(Q, H || {});
      } else if (!this.declaringField)
        if (this.parent) {
          var z = Object.assign({}, this.parent._features);
          this._features = Object.assign(z, H || {});
        } else throw new Error("Unable to find a parent for " + this.fullName);
      this.extensionField && (this.extensionField._features = this._features);
    }),
    ($.prototype._inferLegacyProtoFeatures = function () {
      return {};
    }),
    ($.prototype.getOption = function (K) {
      if (this.options) return this.options[K];
    }),
    ($.prototype.setOption = function (K, G, H) {
      return (
        this.options || (this.options = {}),
        /^features\./.test(K)
          ? U.setProperty(this.options, K, G, H)
          : (!H || this.options[K] === void 0) &&
            (this.getOption(K) !== G && (this.resolved = !1),
            (this.options[K] = G)),
        this
      );
    }),
    ($.prototype.setParsedOption = function (K, G, H) {
      this.parsedOptions || (this.parsedOptions = []);
      var Q = this.parsedOptions;
      if (H) {
        var z = Q.find(function (Z) {
          return Object.prototype.hasOwnProperty.call(Z, K);
        });
        if (z) {
          var Y = z[K];
          U.setProperty(Y, H, G);
        } else (z = {}), (z[K] = U.setProperty({}, H, G)), Q.push(z);
      } else {
        var X = {};
        (X[K] = G), Q.push(X);
      }
      return this;
    }),
    ($.prototype.setOptions = function (K, G) {
      if (K)
        for (var H = Object.keys(K), Q = 0; Q < H.length; ++Q)
          this.setOption(H[Q], K[H[Q]], G);
      return this;
    }),
    ($.prototype.toString = function () {
      var K = this.constructor.className,
        G = this.fullName;
      return G.length ? K + " " + G : K;
    }),
    ($.prototype._editionToJSON = function () {
      if (!(!this._edition || this._edition === "proto3")) return this._edition;
    }),
    ($._configure = function (W) {
      F = W;
    }),
    object
  );
}
var _enum, hasRequired_enum;
function require_enum() {
  if (hasRequired_enum) return _enum;
  (hasRequired_enum = 1), (_enum = q);
  var B = requireObject();
  ((q.prototype = Object.create(B.prototype)).constructor = q).className =
    "Enum";
  var U = requireNamespace(),
    F = requireUtil();
  function q(j, V, $, W, K, G) {
    if ((B.call(this, j, $), V && typeof V != "object"))
      throw TypeError("values must be an object");
    if (
      ((this.valuesById = {}),
      (this.values = Object.create(this.valuesById)),
      (this.comment = W),
      (this.comments = K || {}),
      (this.valuesOptions = G),
      (this._valuesFeatures = {}),
      (this.reserved = void 0),
      V)
    )
      for (var H = Object.keys(V), Q = 0; Q < H.length; ++Q)
        typeof V[H[Q]] == "number" &&
          (this.valuesById[(this.values[H[Q]] = V[H[Q]])] = H[Q]);
  }
  return (
    (q.prototype._resolveFeatures = function (V) {
      return (
        (V = this._edition || V),
        B.prototype._resolveFeatures.call(this, V),
        Object.keys(this.values).forEach(($) => {
          var W = Object.assign({}, this._features);
          this._valuesFeatures[$] = Object.assign(
            W,
            this.valuesOptions &&
              this.valuesOptions[$] &&
              this.valuesOptions[$].features
          );
        }),
        this
      );
    }),
    (q.fromJSON = function (V, $) {
      var W = new q(V, $.values, $.options, $.comment, $.comments);
      return (
        (W.reserved = $.reserved),
        $.edition && (W._edition = $.edition),
        (W._defaultEdition = "proto3"),
        W
      );
    }),
    (q.prototype.toJSON = function (V) {
      var $ = V ? !!V.keepComments : !1;
      return F.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        $ ? this.comment : void 0,
        "comments",
        $ ? this.comments : void 0,
      ]);
    }),
    (q.prototype.add = function (V, $, W, K) {
      if (!F.isString(V)) throw TypeError("name must be a string");
      if (!F.isInteger($)) throw TypeError("id must be an integer");
      if (this.values[V] !== void 0)
        throw Error("duplicate name '" + V + "' in " + this);
      if (this.isReservedId($))
        throw Error("id " + $ + " is reserved in " + this);
      if (this.isReservedName(V))
        throw Error("name '" + V + "' is reserved in " + this);
      if (this.valuesById[$] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + $ + " in " + this);
        this.values[V] = $;
      } else this.valuesById[(this.values[V] = $)] = V;
      return (
        K &&
          (this.valuesOptions === void 0 && (this.valuesOptions = {}),
          (this.valuesOptions[V] = K || null)),
        (this.comments[V] = W || null),
        this
      );
    }),
    (q.prototype.remove = function (V) {
      if (!F.isString(V)) throw TypeError("name must be a string");
      var $ = this.values[V];
      if ($ == null) throw Error("name '" + V + "' does not exist in " + this);
      return (
        delete this.valuesById[$],
        delete this.values[V],
        delete this.comments[V],
        this.valuesOptions && delete this.valuesOptions[V],
        this
      );
    }),
    (q.prototype.isReservedId = function (V) {
      return U.isReservedId(this.reserved, V);
    }),
    (q.prototype.isReservedName = function (V) {
      return U.isReservedName(this.reserved, V);
    }),
    _enum
  );
}
var encoder_1, hasRequiredEncoder;
function requireEncoder() {
  if (hasRequiredEncoder) return encoder_1;
  (hasRequiredEncoder = 1), (encoder_1 = j);
  var B = require_enum(),
    U = requireTypes(),
    F = requireUtil();
  function q(V, $, W, K) {
    return $.delimited
      ? V(
          "types[%i].encode(%s,w.uint32(%i)).uint32(%i)",
          W,
          K,
          (($.id << 3) | 3) >>> 0,
          (($.id << 3) | 4) >>> 0
        )
      : V(
          "types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",
          W,
          K,
          (($.id << 3) | 2) >>> 0
        );
  }
  function j(V) {
    for (
      var $ = F.codegen(["m", "w"], V.name + "$encode")("if(!w)")(
          "w=Writer.create()"
        ),
        W,
        K,
        G = V.fieldsArray.slice().sort(F.compareFieldsById),
        W = 0;
      W < G.length;
      ++W
    ) {
      var H = G[W].resolve(),
        Q = V._fieldsArray.indexOf(H),
        z = H.resolvedType instanceof B ? "int32" : H.type,
        Y = U.basic[z];
      (K = "m" + F.safeProp(H.name)),
        H.map
          ? ($(
              "if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",
              K,
              H.name
            )("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", K)(
              "w.uint32(%i).fork().uint32(%i).%s(ks[i])",
              ((H.id << 3) | 2) >>> 0,
              8 | U.mapKey[H.keyType],
              H.keyType
            ),
            Y === void 0
              ? $(
                  "types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",
                  Q,
                  K
                )
              : $(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | Y, z, K),
            $("}")("}"))
          : H.repeated
          ? ($("if(%s!=null&&%s.length){", K, K),
            H.packed && U.packed[z] !== void 0
              ? $("w.uint32(%i).fork()", ((H.id << 3) | 2) >>> 0)(
                  "for(var i=0;i<%s.length;++i)",
                  K
                )(
                  "w.%s(%s[i])",
                  z,
                  K
                )("w.ldelim()")
              : ($("for(var i=0;i<%s.length;++i)", K),
                Y === void 0
                  ? q($, H, Q, K + "[i]")
                  : $("w.uint32(%i).%s(%s[i])", ((H.id << 3) | Y) >>> 0, z, K)),
            $("}"))
          : (H.optional &&
              $("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", K, H.name),
            Y === void 0
              ? q($, H, Q, K)
              : $("w.uint32(%i).%s(%s)", ((H.id << 3) | Y) >>> 0, z, K));
    }
    return $("return w");
  }
  return encoder_1;
}
var hasRequiredIndexLight;
function requireIndexLight() {
  if (hasRequiredIndexLight) return indexLight.exports;
  hasRequiredIndexLight = 1;
  var B = (indexLight.exports = requireIndexMinimal());
  B.build = "light";
  function U(q, j, V) {
    return (
      typeof j == "function"
        ? ((V = j), (j = new B.Root()))
        : j || (j = new B.Root()),
      j.load(q, V)
    );
  }
  B.load = U;
  function F(q, j) {
    return j || (j = new B.Root()), j.loadSync(q);
  }
  return (
    (B.loadSync = F),
    (B.encoder = requireEncoder()),
    (B.decoder = requireDecoder()),
    (B.verifier = requireVerifier()),
    (B.converter = requireConverter()),
    (B.ReflectionObject = requireObject()),
    (B.Namespace = requireNamespace()),
    (B.Root = requireRoot()),
    (B.Enum = require_enum()),
    (B.Type = requireType()),
    (B.Field = requireField()),
    (B.OneOf = requireOneof()),
    (B.MapField = requireMapfield()),
    (B.Service = requireService()),
    (B.Method = requireMethod()),
    (B.Message = requireMessage()),
    (B.wrappers = requireWrappers()),
    (B.types = requireTypes()),
    (B.util = requireUtil()),
    B.ReflectionObject._configure(B.Root),
    B.Namespace._configure(B.Type, B.Service, B.Enum),
    B.Root._configure(B.Type),
    B.Field._configure(B.Type),
    indexLight.exports
  );
}
var tokenize_1, hasRequiredTokenize;
function requireTokenize() {
  if (hasRequiredTokenize) return tokenize_1;
  (hasRequiredTokenize = 1), (tokenize_1 = H);
  var B = /[\s{}=;:[\],'"()<>]/g,
    U = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    F = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
    q = /^ *[*/]+ */,
    j = /^\s*\*?\/*/,
    V = /\n/g,
    $ = /\s/,
    W = /\\(.?)/g,
    K = {
      0: "\0",
      r: "\r",
      n: `
`,
      t: "	",
    };
  function G(Q) {
    return Q.replace(W, function (z, Y) {
      switch (Y) {
        case "\\":
        case "":
          return Y;
        default:
          return K[Y] || "";
      }
    });
  }
  H.unescape = G;
  function H(Q, z) {
    Q = Q.toString();
    var Y = 0,
      X = Q.length,
      Z = 1,
      se = 0,
      ee = {},
      ie = [],
      re = null;
    function te(ae) {
      return Error("illegal " + ae + " (line " + Z + ")");
    }
    function ne() {
      var ae = re === "'" ? F : U;
      ae.lastIndex = Y - 1;
      var ue = ae.exec(Q);
      if (!ue) throw te("string");
      return (Y = ae.lastIndex), pe(re), (re = null), G(ue[1]);
    }
    function oe(ae) {
      return Q.charAt(ae);
    }
    function ce(ae, ue, ve) {
      var Ce = { type: Q.charAt(ae++), lineEmpty: !1, leading: ve },
        we;
      z ? (we = 2) : (we = 3);
      var be = ae - we,
        Ie;
      do
        if (
          --be < 0 ||
          (Ie = Q.charAt(be)) ===
            `
`
        ) {
          Ce.lineEmpty = !0;
          break;
        }
      while (Ie === " " || Ie === "	");
      for (var Ne = Q.substring(ae, ue).split(V), Ue = 0; Ue < Ne.length; ++Ue)
        Ne[Ue] = Ne[Ue].replace(z ? j : q, "").trim();
      (Ce.text = Ne.join(
        `
`
      ).trim()),
        (ee[Z] = Ce),
        (se = Z);
    }
    function le(ae) {
      var ue = he(ae),
        ve = Q.substring(ae, ue),
        Ce = /^\s*\/\//.test(ve);
      return Ce;
    }
    function he(ae) {
      for (
        var ue = ae;
        ue < X &&
        oe(ue) !==
          `
`;

      )
        ue++;
      return ue;
    }
    function de() {
      if (ie.length > 0) return ie.shift();
      if (re) return ne();
      var ae,
        ue,
        ve,
        Ce,
        we,
        be = Y === 0;
      do {
        if (Y === X) return null;
        for (ae = !1; $.test((ve = oe(Y))); )
          if (
            (ve ===
              `
` && ((be = !0), ++Z),
            ++Y === X)
          )
            return null;
        if (oe(Y) === "/") {
          if (++Y === X) throw te("comment");
          if (oe(Y) === "/")
            if (z) {
              if (((Ce = Y), (we = !1), le(Y - 1))) {
                we = !0;
                do if (((Y = he(Y)), Y === X || (Y++, !be))) break;
                while (le(Y));
              } else Y = Math.min(X, he(Y) + 1);
              we && (ce(Ce, Y, be), (be = !0)), Z++, (ae = !0);
            } else {
              for (
                we = oe((Ce = Y + 1)) === "/";
                oe(++Y) !==
                `
`;

              )
                if (Y === X) return null;
              ++Y, we && (ce(Ce, Y - 1, be), (be = !0)), ++Z, (ae = !0);
            }
          else if ((ve = oe(Y)) === "*") {
            (Ce = Y + 1), (we = z || oe(Ce) === "*");
            do {
              if (
                (ve ===
                  `
` && ++Z,
                ++Y === X)
              )
                throw te("comment");
              (ue = ve), (ve = oe(Y));
            } while (ue !== "*" || ve !== "/");
            ++Y, we && (ce(Ce, Y - 2, be), (be = !0)), (ae = !0);
          } else return "/";
        }
      } while (ae);
      var Ie = Y;
      B.lastIndex = 0;
      var Ne = B.test(oe(Ie++));
      if (!Ne) for (; Ie < X && !B.test(oe(Ie)); ) ++Ie;
      var Ue = Q.substring(Y, (Y = Ie));
      return (Ue === '"' || Ue === "'") && (re = Ue), Ue;
    }
    function pe(ae) {
      ie.push(ae);
    }
    function Te() {
      if (!ie.length) {
        var ae = de();
        if (ae === null) return null;
        pe(ae);
      }
      return ie[0];
    }
    function Pe(ae, ue) {
      var ve = Te(),
        Ce = ve === ae;
      if (Ce) return de(), !0;
      if (!ue) throw te("token '" + ve + "', '" + ae + "' expected");
      return !1;
    }
    function ye(ae) {
      var ue = null,
        ve;
      return (
        ae === void 0
          ? ((ve = ee[Z - 1]),
            delete ee[Z - 1],
            ve &&
              (z || ve.type === "*" || ve.lineEmpty) &&
              (ue = ve.leading ? ve.text : null))
          : (se < ae && Te(),
            (ve = ee[ae]),
            delete ee[ae],
            ve &&
              !ve.lineEmpty &&
              (z || ve.type === "/") &&
              (ue = ve.leading ? null : ve.text)),
        ue
      );
    }
    return Object.defineProperty(
      { next: de, peek: Te, push: pe, skip: Pe, cmnt: ye },
      "line",
      {
        get: function () {
          return Z;
        },
      }
    );
  }
  return tokenize_1;
}
var parse_1, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse_1;
  (hasRequiredParse = 1),
    (parse_1 = ne),
    (ne.filename = null),
    (ne.defaults = { keepCase: !1 });
  var B = requireTokenize(),
    U = requireRoot(),
    F = requireType(),
    q = requireField(),
    j = requireMapfield(),
    V = requireOneof(),
    $ = require_enum(),
    W = requireService(),
    K = requireMethod(),
    G = requireObject(),
    H = requireTypes(),
    Q = requireUtil(),
    z = /^[1-9][0-9]*$/,
    Y = /^-?[1-9][0-9]*$/,
    X = /^0[x][0-9a-fA-F]+$/,
    Z = /^-?0[x][0-9a-fA-F]+$/,
    se = /^0[0-7]+$/,
    ee = /^-?0[0-7]+$/,
    ie = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    re = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    te = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
  function ne(oe, ce, le) {
    ce instanceof U || ((le = ce), (ce = new U())), le || (le = ne.defaults);
    var he = le.preferTrailingComment || !1,
      de = B(oe, le.alternateCommentMode || !1),
      pe = de.next,
      Te = de.push,
      Pe = de.peek,
      ye = de.skip,
      ae = de.cmnt,
      ue = !0,
      ve,
      Ce,
      we,
      be = "proto2",
      Ie = ce,
      Ne = [],
      Ue = {},
      Le = le.keepCase
        ? function (me) {
            return me;
          }
        : Q.camelCase;
    function We() {
      Ne.forEach((me) => {
        (me._edition = be),
          Object.keys(Ue).forEach((fe) => {
            me.getOption(fe) === void 0 && me.setOption(fe, Ue[fe], !0);
          });
      });
    }
    function Ee(me, fe, ge) {
      var ke = ne.filename;
      return (
        ge || (ne.filename = null),
        Error(
          "illegal " +
            (fe || "token") +
            " '" +
            me +
            "' (" +
            (ke ? ke + ", " : "") +
            "line " +
            de.line +
            ")"
        )
      );
    }
    function Ze() {
      var me = [],
        fe;
      do {
        if ((fe = pe()) !== '"' && fe !== "'") throw Ee(fe);
        me.push(pe()), ye(fe), (fe = Pe());
      } while (fe === '"' || fe === "'");
      return me.join("");
    }
    function bt(me) {
      var fe = pe();
      switch (fe) {
        case "'":
        case '"':
          return Te(fe), Ze();
        case "true":
        case "TRUE":
          return !0;
        case "false":
        case "FALSE":
          return !1;
      }
      try {
        return It(fe, !0);
      } catch {
        if (te.test(fe)) return fe;
        throw Ee(fe, "value");
      }
    }
    function Tt(me, fe) {
      var ge, ke;
      do
        if (fe && ((ge = Pe()) === '"' || ge === "'")) {
          var Se = Ze();
          if ((me.push(Se), be >= 2023)) throw Ee(Se, "id");
        } else
          try {
            me.push([(ke = Qe(pe())), ye("to", !0) ? Qe(pe()) : ke]);
          } catch (Oe) {
            if (fe && te.test(ge) && be >= 2023) me.push(ge);
            else throw Oe;
          }
      while (ye(",", !0));
      var Re = { options: void 0 };
      (Re.setOption = function (Oe, Fe) {
        this.options === void 0 && (this.options = {}), (this.options[Oe] = Fe);
      }),
        je(
          Re,
          function (Fe) {
            if (Fe === "option") Ve(Re, Fe), ye(";");
            else throw Ee(Fe);
          },
          function () {
            gt(Re);
          }
        );
    }
    function It(me, fe) {
      var ge = 1;
      switch (
        (me.charAt(0) === "-" && ((ge = -1), (me = me.substring(1))), me)
      ) {
        case "inf":
        case "INF":
        case "Inf":
          return ge * (1 / 0);
        case "nan":
        case "NAN":
        case "Nan":
        case "NaN":
          return NaN;
        case "0":
          return 0;
      }
      if (z.test(me)) return ge * parseInt(me, 10);
      if (X.test(me)) return ge * parseInt(me, 16);
      if (se.test(me)) return ge * parseInt(me, 8);
      if (ie.test(me)) return ge * parseFloat(me);
      throw Ee(me, "number", fe);
    }
    function Qe(me, fe) {
      switch (me) {
        case "max":
        case "MAX":
        case "Max":
          return 536870911;
        case "0":
          return 0;
      }
      if (!fe && me.charAt(0) === "-") throw Ee(me, "id");
      if (Y.test(me)) return parseInt(me, 10);
      if (Z.test(me)) return parseInt(me, 16);
      if (ee.test(me)) return parseInt(me, 8);
      throw Ee(me, "id");
    }
    function Ot() {
      if (ve !== void 0) throw Ee("package");
      if (((ve = pe()), !te.test(ve))) throw Ee(ve, "name");
      (Ie = Ie.define(ve)), ye(";");
    }
    function At() {
      var me = Pe(),
        fe;
      switch (me) {
        case "weak":
          (fe = we || (we = [])), pe();
          break;
        case "public":
          pe();
        default:
          fe = Ce || (Ce = []);
          break;
      }
      (me = Ze()), ye(";"), fe.push(me);
    }
    function Dt() {
      if ((ye("="), (be = Ze()), be < 2023)) throw Ee(be, "syntax");
      ye(";");
    }
    function Lt() {
      if ((ye("="), (be = Ze()), !["2023"].includes(be)))
        throw Ee(be, "edition");
      ye(";");
    }
    function kt(me, fe) {
      switch (fe) {
        case "option":
          return Ve(me, fe), ye(";"), !0;
        case "message":
          return Et(me, fe), !0;
        case "enum":
          return _t(me, fe), !0;
        case "service":
          return qt(me, fe), !0;
        case "extend":
          return jt(me, fe), !0;
      }
      return !1;
    }
    function je(me, fe, ge) {
      var ke = de.line;
      if (
        (me &&
          (typeof me.comment != "string" && (me.comment = ae()),
          (me.filename = ne.filename)),
        ye("{", !0))
      ) {
        for (var Se; (Se = pe()) !== "}"; ) fe(Se);
        ye(";", !0);
      } else
        ge && ge(),
          ye(";"),
          me &&
            (typeof me.comment != "string" || he) &&
            (me.comment = ae(ke) || me.comment);
    }
    function Et(me, fe) {
      if (!re.test((fe = pe()))) throw Ee(fe, "type name");
      var ge = new F(fe);
      je(ge, function (Se) {
        if (!kt(ge, Se))
          switch (Se) {
            case "map":
              Nt(ge);
              break;
            case "required":
              if (be !== "proto2") throw Ee(Se);
            case "repeated":
              Be(ge, Se);
              break;
            case "optional":
              if (be === "proto3") Be(ge, "proto3_optional");
              else {
                if (be !== "proto2") throw Ee(Se);
                Be(ge, "optional");
              }
              break;
            case "oneof":
              Mt(ge, Se);
              break;
            case "extensions":
              Tt(ge.extensions || (ge.extensions = []));
              break;
            case "reserved":
              Tt(ge.reserved || (ge.reserved = []), !0);
              break;
            default:
              if (be === "proto2" || !te.test(Se)) throw Ee(Se);
              Te(Se), Be(ge, "optional");
              break;
          }
      }),
        me.add(ge),
        me === Ie && Ne.push(ge);
    }
    function Be(me, fe, ge) {
      var ke = pe();
      if (ke === "group") {
        xt(me, fe);
        return;
      }
      for (; ke.endsWith(".") || Pe().startsWith("."); ) ke += pe();
      if (!te.test(ke)) throw Ee(ke, "type");
      var Se = pe();
      if (!re.test(Se)) throw Ee(Se, "name");
      (Se = Le(Se)), ye("=");
      var Re = new q(Se, Qe(pe()), ke, fe, ge);
      if (
        (je(
          Re,
          function (qe) {
            if (qe === "option") Ve(Re, qe), ye(";");
            else throw Ee(qe);
          },
          function () {
            gt(Re);
          }
        ),
        fe === "proto3_optional")
      ) {
        var Oe = new V("_" + Se);
        Re.setOption("proto3_optional", !0), Oe.add(Re), me.add(Oe);
      } else me.add(Re);
      me === Ie && Ne.push(Re);
    }
    function xt(me, fe) {
      if (be >= 2023) throw Ee("group");
      var ge = pe();
      if (!re.test(ge)) throw Ee(ge, "name");
      var ke = Q.lcFirst(ge);
      ge === ke && (ge = Q.ucFirst(ge)), ye("=");
      var Se = Qe(pe()),
        Re = new F(ge);
      Re.group = !0;
      var Oe = new q(ke, Se, ge, fe);
      (Oe.filename = ne.filename),
        je(Re, function (qe) {
          switch (qe) {
            case "option":
              Ve(Re, qe), ye(";");
              break;
            case "required":
            case "repeated":
              Be(Re, qe);
              break;
            case "optional":
              be === "proto3" ? Be(Re, "proto3_optional") : Be(Re, "optional");
              break;
            case "message":
              Et(Re, qe);
              break;
            case "enum":
              _t(Re, qe);
              break;
            default:
              throw Ee(qe);
          }
        }),
        me.add(Re).add(Oe);
    }
    function Nt(me) {
      ye("<");
      var fe = pe();
      if (H.mapKey[fe] === void 0) throw Ee(fe, "type");
      ye(",");
      var ge = pe();
      if (!te.test(ge)) throw Ee(ge, "type");
      ye(">");
      var ke = pe();
      if (!re.test(ke)) throw Ee(ke, "name");
      ye("=");
      var Se = new j(Le(ke), Qe(pe()), fe, ge);
      je(
        Se,
        function (Oe) {
          if (Oe === "option") Ve(Se, Oe), ye(";");
          else throw Ee(Oe);
        },
        function () {
          gt(Se);
        }
      ),
        me.add(Se);
    }
    function Mt(me, fe) {
      if (!re.test((fe = pe()))) throw Ee(fe, "name");
      var ge = new V(Le(fe));
      je(ge, function (Se) {
        Se === "option" ? (Ve(ge, Se), ye(";")) : (Te(Se), Be(ge, "optional"));
      }),
        me.add(ge);
    }
    function _t(me, fe) {
      if (!re.test((fe = pe()))) throw Ee(fe, "name");
      var ge = new $(fe);
      je(ge, function (Se) {
        switch (Se) {
          case "option":
            Ve(ge, Se), ye(";");
            break;
          case "reserved":
            Tt(ge.reserved || (ge.reserved = []), !0),
              ge.reserved === void 0 && (ge.reserved = []);
            break;
          default:
            Ut(ge, Se);
        }
      }),
        me.add(ge),
        me === Ie && Ne.push(ge);
    }
    function Ut(me, fe) {
      if (!re.test(fe)) throw Ee(fe, "name");
      ye("=");
      var ge = Qe(pe(), !0),
        ke = { options: void 0 };
      (ke.getOption = function (Se) {
        return this.options[Se];
      }),
        (ke.setOption = function (Se, Re) {
          G.prototype.setOption.call(ke, Se, Re);
        }),
        (ke.setParsedOption = function () {}),
        je(
          ke,
          function (Re) {
            if (Re === "option") Ve(ke, Re), ye(";");
            else throw Ee(Re);
          },
          function () {
            gt(ke);
          }
        ),
        me.add(fe, ge, ke.comment, ke.parsedOptions || ke.options);
    }
    function Ve(me, fe) {
      var ge,
        ke,
        Se = !0;
      for (fe === "option" && (fe = pe()); fe !== "="; ) {
        if (fe === "(") {
          var Re = pe();
          ye(")"), (fe = "(" + Re + ")");
        }
        if (Se) {
          if (((Se = !1), fe.includes(".") && !fe.includes("("))) {
            var Oe = fe.split(".");
            (ge = Oe[0] + "."), (fe = Oe[1]);
            continue;
          }
          ge = fe;
        } else ke = ke ? (ke += fe) : fe;
        fe = pe();
      }
      var Fe = ke ? ge.concat(ke) : ge,
        qe = wt(me, Fe);
      (ke = ke && ke[0] === "." ? ke.slice(1) : ke),
        (ge = ge && ge[ge.length - 1] === "." ? ge.slice(0, -1) : ge),
        Ft(me, ge, qe, ke);
    }
    function wt(me, fe) {
      if (ye("{", !0)) {
        for (var ge = {}; !ye("}", !0); ) {
          if (!re.test((Me = pe()))) throw Ee(Me, "name");
          if (Me === null) throw Ee(Me, "end of input");
          var ke,
            Se = Me;
          if ((ye(":", !0), Pe() === "{")) ke = wt(me, fe + "." + Me);
          else if (Pe() === "[") {
            ke = [];
            var Re;
            if (ye("[", !0)) {
              do (Re = bt()), ke.push(Re);
              while (ye(",", !0));
              ye("]"), typeof Re < "u" && St(me, fe + "." + Me, Re);
            }
          } else (ke = bt()), St(me, fe + "." + Me, ke);
          var Oe = ge[Se];
          Oe && (ke = [].concat(Oe).concat(ke)),
            (ge[Se] = ke),
            ye(",", !0),
            ye(";", !0);
        }
        return ge;
      }
      var Fe = bt();
      return St(me, fe, Fe), Fe;
    }
    function St(me, fe, ge) {
      if (Ie === me && /^features\./.test(fe)) {
        Ue[fe] = ge;
        return;
      }
      me.setOption && me.setOption(fe, ge);
    }
    function Ft(me, fe, ge, ke) {
      me.setParsedOption && me.setParsedOption(fe, ge, ke);
    }
    function gt(me) {
      if (ye("[", !0)) {
        do Ve(me, "option");
        while (ye(",", !0));
        ye("]");
      }
      return me;
    }
    function qt(me, fe) {
      if (!re.test((fe = pe()))) throw Ee(fe, "service name");
      var ge = new W(fe);
      je(ge, function (Se) {
        if (!kt(ge, Se))
          if (Se === "rpc") Bt(ge, Se);
          else throw Ee(Se);
      }),
        me.add(ge),
        me === Ie && Ne.push(ge);
    }
    function Bt(me, fe) {
      var ge = ae(),
        ke = fe;
      if (!re.test((fe = pe()))) throw Ee(fe, "name");
      var Se = fe,
        Re,
        Oe,
        Fe,
        qe;
      if (
        (ye("("),
        ye("stream", !0) && (Oe = !0),
        !te.test((fe = pe())) ||
          ((Re = fe),
          ye(")"),
          ye("returns"),
          ye("("),
          ye("stream", !0) && (qe = !0),
          !te.test((fe = pe()))))
      )
        throw Ee(fe);
      (Fe = fe), ye(")");
      var vt = new K(Se, ke, Re, Fe, Oe, qe);
      (vt.comment = ge),
        je(vt, function (Ct) {
          if (Ct === "option") Ve(vt, Ct), ye(";");
          else throw Ee(Ct);
        }),
        me.add(vt);
    }
    function jt(me, fe) {
      if (!te.test((fe = pe()))) throw Ee(fe, "reference");
      var ge = fe;
      je(null, function (Se) {
        switch (Se) {
          case "required":
          case "repeated":
            Be(me, Se, ge);
            break;
          case "optional":
            be === "proto3"
              ? Be(me, "proto3_optional", ge)
              : Be(me, "optional", ge);
            break;
          default:
            if (be === "proto2" || !te.test(Se)) throw Ee(Se);
            Te(Se), Be(me, "optional", ge);
            break;
        }
      });
    }
    for (var Me; (Me = pe()) !== null; )
      switch (Me) {
        case "package":
          if (!ue) throw Ee(Me);
          Ot();
          break;
        case "import":
          if (!ue) throw Ee(Me);
          At();
          break;
        case "syntax":
          if (!ue) throw Ee(Me);
          Dt();
          break;
        case "edition":
          if (!ue) throw Ee(Me);
          Lt();
          break;
        case "option":
          Ve(Ie, Me), ye(";", !0);
          break;
        default:
          if (kt(Ie, Me)) {
            ue = !1;
            continue;
          }
          throw Ee(Me);
      }
    return (
      We(),
      (ne.filename = null),
      { package: ve, imports: Ce, weakImports: we, root: ce }
    );
  }
  return parse_1;
}
var common_1, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common_1;
  (hasRequiredCommon = 1), (common_1 = U);
  var B = /\/|\./;
  function U(q, j) {
    B.test(q) ||
      ((q = "google/protobuf/" + q + ".proto"),
      (j = { nested: { google: { nested: { protobuf: { nested: j } } } } })),
      (U[q] = j);
  }
  U("any", {
    Any: {
      fields: {
        type_url: { type: "string", id: 1 },
        value: { type: "bytes", id: 2 },
      },
    },
  });
  var F;
  return (
    U("duration", {
      Duration: (F = {
        fields: {
          seconds: { type: "int64", id: 1 },
          nanos: { type: "int32", id: 2 },
        },
      }),
    }),
    U("timestamp", { Timestamp: F }),
    U("empty", { Empty: { fields: {} } }),
    U("struct", {
      Struct: {
        fields: { fields: { keyType: "string", type: "Value", id: 1 } },
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue",
            ],
          },
        },
        fields: {
          nullValue: { type: "NullValue", id: 1 },
          numberValue: { type: "double", id: 2 },
          stringValue: { type: "string", id: 3 },
          boolValue: { type: "bool", id: 4 },
          structValue: { type: "Struct", id: 5 },
          listValue: { type: "ListValue", id: 6 },
        },
      },
      NullValue: { values: { NULL_VALUE: 0 } },
      ListValue: {
        fields: { values: { rule: "repeated", type: "Value", id: 1 } },
      },
    }),
    U("wrappers", {
      DoubleValue: { fields: { value: { type: "double", id: 1 } } },
      FloatValue: { fields: { value: { type: "float", id: 1 } } },
      Int64Value: { fields: { value: { type: "int64", id: 1 } } },
      UInt64Value: { fields: { value: { type: "uint64", id: 1 } } },
      Int32Value: { fields: { value: { type: "int32", id: 1 } } },
      UInt32Value: { fields: { value: { type: "uint32", id: 1 } } },
      BoolValue: { fields: { value: { type: "bool", id: 1 } } },
      StringValue: { fields: { value: { type: "string", id: 1 } } },
      BytesValue: { fields: { value: { type: "bytes", id: 1 } } },
    }),
    U("field_mask", {
      FieldMask: {
        fields: { paths: { rule: "repeated", type: "string", id: 1 } },
      },
    }),
    (U.get = function (j) {
      return U[j] || null;
    }),
    common_1
  );
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  var B = (src.exports = requireIndexLight());
  return (
    (B.build = "full"),
    (B.tokenize = requireTokenize()),
    (B.parse = requireParse()),
    (B.common = requireCommon()),
    B.Root._configure(B.Type, B.parse, B.common),
    src.exports
  );
}
var protobufjs, hasRequiredProtobufjs;
function requireProtobufjs() {
  return (
    hasRequiredProtobufjs ||
      ((hasRequiredProtobufjs = 1), (protobufjs = requireSrc())),
    protobufjs
  );
}
var protobufjsExports = requireProtobufjs();
const protobuf = getDefaultExportFromCjs(protobufjsExports);
var extendStatics = function (B, U) {
  return (
    (extendStatics =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (F, q) {
          F.__proto__ = q;
        }) ||
      function (F, q) {
        for (var j in q)
          Object.prototype.hasOwnProperty.call(q, j) && (F[j] = q[j]);
      }),
    extendStatics(B, U)
  );
};
function __extends(B, U) {
  if (typeof U != "function" && U !== null)
    throw new TypeError(
      "Class extends value " + String(U) + " is not a constructor or null"
    );
  extendStatics(B, U);
  function F() {
    this.constructor = B;
  }
  B.prototype =
    U === null ? Object.create(U) : ((F.prototype = U.prototype), new F());
}
var __assign = function () {
  return (
    (__assign =
      Object.assign ||
      function (U) {
        for (var F, q = 1, j = arguments.length; q < j; q++) {
          F = arguments[q];
          for (var V in F)
            Object.prototype.hasOwnProperty.call(F, V) && (U[V] = F[V]);
        }
        return U;
      }),
    __assign.apply(this, arguments)
  );
};
function __awaiter$a(B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
}
function __generator(B, U) {
  var F = {
      label: 0,
      sent: function () {
        if (V[0] & 1) throw V[1];
        return V[1];
      },
      trys: [],
      ops: [],
    },
    q,
    j,
    V,
    $;
  return (
    ($ = { next: W(0), throw: W(1), return: W(2) }),
    typeof Symbol == "function" &&
      ($[Symbol.iterator] = function () {
        return this;
      }),
    $
  );
  function W(G) {
    return function (H) {
      return K([G, H]);
    };
  }
  function K(G) {
    if (q) throw new TypeError("Generator is already executing.");
    for (; $ && (($ = 0), G[0] && (F = 0)), F; )
      try {
        if (
          ((q = 1),
          j &&
            (V =
              G[0] & 2
                ? j.return
                : G[0]
                ? j.throw || ((V = j.return) && V.call(j), 0)
                : j.next) &&
            !(V = V.call(j, G[1])).done)
        )
          return V;
        switch (((j = 0), V && (G = [G[0] & 2, V.value]), G[0])) {
          case 0:
          case 1:
            V = G;
            break;
          case 4:
            return F.label++, { value: G[1], done: !1 };
          case 5:
            F.label++, (j = G[1]), (G = [0]);
            continue;
          case 7:
            (G = F.ops.pop()), F.trys.pop();
            continue;
          default:
            if (
              ((V = F.trys),
              !(V = V.length > 0 && V[V.length - 1]) &&
                (G[0] === 6 || G[0] === 2))
            ) {
              F = 0;
              continue;
            }
            if (G[0] === 3 && (!V || (G[1] > V[0] && G[1] < V[3]))) {
              F.label = G[1];
              break;
            }
            if (G[0] === 6 && F.label < V[1]) {
              (F.label = V[1]), (V = G);
              break;
            }
            if (V && F.label < V[2]) {
              (F.label = V[2]), F.ops.push(G);
              break;
            }
            V[2] && F.ops.pop(), F.trys.pop();
            continue;
        }
        G = U.call(B, F);
      } catch (H) {
        (G = [6, H]), (j = 0);
      } finally {
        q = V = 0;
      }
    if (G[0] & 5) throw G[1];
    return { value: G[0] ? G[1] : void 0, done: !0 };
  }
}
typeof SuppressedError == "function" && SuppressedError;
var options = { syntax: "proto3" },
  nested = {
    pipecat: {
      nested: {
        TextFrame: {
          fields: {
            id: { type: "uint64", id: 1 },
            name: { type: "string", id: 2 },
            text: { type: "string", id: 3 },
          },
        },
        AudioRawFrame: {
          fields: {
            id: { type: "uint64", id: 1 },
            name: { type: "string", id: 2 },
            audio: { type: "bytes", id: 3 },
            sampleRate: { type: "uint32", id: 4 },
            numChannels: { type: "uint32", id: 5 },
          },
        },
        TranscriptionFrame: {
          fields: {
            id: { type: "uint64", id: 1 },
            name: { type: "string", id: 2 },
            text: { type: "string", id: 3 },
            userId: { type: "string", id: 4 },
            timestamp: { type: "string", id: 5 },
          },
        },
        Frame: {
          oneofs: { frame: { oneof: ["text", "audio", "transcription"] } },
          fields: {
            text: { type: "TextFrame", id: 1 },
            audio: { type: "AudioRawFrame", id: 2 },
            transcription: { type: "TranscriptionFrame", id: 3 },
          },
        },
      },
    },
  },
  jsonDescriptor = { options, nested },
  ConnectionQuality;
(function (B) {
  (B.UNKNOWN = "UNKNOWN"), (B.GOOD = "GOOD"), (B.BAD = "BAD");
})(ConnectionQuality || (ConnectionQuality = {}));
var AbstractConnectionQualityIndicator = (function () {
  function B(U) {
    (this._connectionQuality = ConnectionQuality.UNKNOWN),
      (this.onConnectionQualityChanged = U);
  }
  return (
    Object.defineProperty(B.prototype, "connectionQuality", {
      get: function () {
        return this._connectionQuality;
      },
      enumerable: !1,
      configurable: !0,
    }),
    (B.prototype.handleStatsChanged = function () {
      var U = this.calculateConnectionQuality();
      U !== this._connectionQuality &&
        ((this._connectionQuality = U), this.onConnectionQualityChanged(U));
    }),
    (B.prototype.start = function (U) {
      this.stop(!0), this._start(U);
    }),
    (B.prototype.stop = function (U) {
      U === void 0 && (U = !1),
        this._stop(),
        (this._connectionQuality = ConnectionQuality.UNKNOWN),
        U || this.onConnectionQualityChanged(ConnectionQuality.UNKNOWN);
    }),
    B
  );
})();
function QualityIndicatorMixer() {
  for (var B = [], U = 0; U < arguments.length; U++) B[U] = arguments[U];
  var F = (function (q) {
    __extends(j, q);
    function j(V) {
      var $ = q.call(this, V) || this;
      return (
        ($.childTrackers = B.map(function (W) {
          var K = W.getParams,
            G = W.TrackerClass;
          return {
            tracker: new G(function () {
              return $.handleStatsChanged();
            }),
            getParams: K,
          };
        })),
        $
      );
    }
    return (
      (j.prototype.calculateConnectionQuality = function () {
        var V = this.childTrackers.map(function ($) {
          var W = $.tracker;
          return W.connectionQuality;
        });
        return V.some(function ($) {
          return $ === ConnectionQuality.BAD;
        })
          ? ConnectionQuality.BAD
          : V.every(function ($) {
              return $ === ConnectionQuality.UNKNOWN;
            })
          ? ConnectionQuality.UNKNOWN
          : ConnectionQuality.GOOD;
      }),
      (j.prototype._start = function (V) {
        this.childTrackers.forEach(function ($) {
          var W = $.tracker,
            K = $.getParams;
          return W.start(K(V));
        });
      }),
      (j.prototype._stop = function () {
        this.childTrackers.forEach(function (V) {
          var $ = V.tracker;
          return $.stop(!0);
        });
      }),
      j
    );
  })(AbstractConnectionQualityIndicator);
  return F;
}
var LiveKitConnectionQualityIndicator = (function (B) {
    __extends(U, B);
    function U() {
      var F = (B !== null && B.apply(this, arguments)) || this;
      return (
        (F.room = null),
        (F.liveKitConnectionQuality = ConnectionQuality$2.Unknown),
        (F.liveKitConnectionState = null),
        (F.handleConnectionQualityChanged = function (q) {
          (F.liveKitConnectionQuality = q), F.handleStatsChanged();
        }),
        (F.handleConnectionStateChanged = function (q) {
          (F.liveKitConnectionState = q), F.handleStatsChanged();
        }),
        F
      );
    }
    return (
      (U.prototype._start = function (F) {
        (this.room = F),
          this.room.localParticipant.on(
            ParticipantEvent.ConnectionQualityChanged,
            this.handleConnectionQualityChanged
          ),
          this.room.on(
            RoomEvent.ConnectionStateChanged,
            this.handleConnectionStateChanged
          );
      }),
      (U.prototype._stop = function () {
        this.room &&
          (this.room.localParticipant.off(
            RoomEvent.ConnectionQualityChanged,
            this.handleConnectionQualityChanged
          ),
          this.room.off(
            RoomEvent.ConnectionStateChanged,
            this.handleConnectionStateChanged
          ));
      }),
      (U.prototype.calculateConnectionQuality = function () {
        return [ConnectionQuality$2.Lost, ConnectionQuality$2.Poor].includes(
          this.liveKitConnectionQuality
        ) ||
          (this.liveKitConnectionState &&
            [
              ConnectionState.Disconnected,
              ConnectionState.Reconnecting,
              ConnectionState.SignalReconnecting,
            ].includes(this.liveKitConnectionState))
          ? ConnectionQuality.BAD
          : ConnectionQuality.GOOD;
      }),
      U
    );
  })(AbstractConnectionQualityIndicator),
  t,
  e,
  s,
  n;
function r() {}
function o() {
  o.init.call(this);
}
function i(B) {
  return B._maxListeners === void 0 ? o.defaultMaxListeners : B._maxListeners;
}
function a(B, U, F) {
  if (U) B.call(F);
  else for (var q = B.length, j = m(B, q), V = 0; V < q; ++V) j[V].call(F);
}
function c(B, U, F, q) {
  if (U) B.call(F, q);
  else for (var j = B.length, V = m(B, j), $ = 0; $ < j; ++$) V[$].call(F, q);
}
function d(B, U, F, q, j) {
  if (U) B.call(F, q, j);
  else
    for (var V = B.length, $ = m(B, V), W = 0; W < V; ++W) $[W].call(F, q, j);
}
function u(B, U, F, q, j, V) {
  if (U) B.call(F, q, j, V);
  else
    for (var $ = B.length, W = m(B, $), K = 0; K < $; ++K)
      W[K].call(F, q, j, V);
}
function h(B, U, F, q) {
  if (U) B.apply(F, q);
  else for (var j = B.length, V = m(B, j), $ = 0; $ < j; ++$) V[$].apply(F, q);
}
function l(B, U, F, q) {
  var j, V, $, W;
  if (typeof F != "function")
    throw new TypeError('"listener" argument must be a function');
  if (
    ((V = B._events)
      ? (V.newListener &&
          (B.emit("newListener", U, F.listener ? F.listener : F),
          (V = B._events)),
        ($ = V[U]))
      : ((V = B._events = new r()), (B._eventsCount = 0)),
    $)
  ) {
    if (
      (typeof $ == "function"
        ? ($ = V[U] = q ? [F, $] : [$, F])
        : q
        ? $.unshift(F)
        : $.push(F),
      !$.warned && (j = i(B)) && j > 0 && $.length > j)
    ) {
      $.warned = !0;
      var K = new Error(
        "Possible EventEmitter memory leak detected. " +
          $.length +
          " " +
          U +
          " listeners added. Use emitter.setMaxListeners() to increase limit"
      );
      (K.name = "MaxListenersExceededWarning"),
        (K.emitter = B),
        (K.type = U),
        (K.count = $.length),
        (W = K),
        typeof console.warn == "function" ? console.warn(W) : console.log(W);
    }
  } else ($ = V[U] = F), ++B._eventsCount;
  return B;
}
function p(B, U, F) {
  var q = !1;
  function j() {
    B.removeListener(U, j), q || ((q = !0), F.apply(B, arguments));
  }
  return (j.listener = F), j;
}
function f(B) {
  var U = this._events;
  if (U) {
    var F = U[B];
    if (typeof F == "function") return 1;
    if (F) return F.length;
  }
  return 0;
}
function m(B, U) {
  for (var F = new Array(U); U--; ) F[U] = B[U];
  return F;
}
(r.prototype = Object.create(null)),
  (o.EventEmitter = o),
  (o.usingDomains = !1),
  (o.prototype.domain = void 0),
  (o.prototype._events = void 0),
  (o.prototype._maxListeners = void 0),
  (o.defaultMaxListeners = 10),
  (o.init = function () {
    (this.domain = null),
      o.usingDomains && (void 0).active,
      (this._events && this._events !== Object.getPrototypeOf(this)._events) ||
        ((this._events = new r()), (this._eventsCount = 0)),
      (this._maxListeners = this._maxListeners || void 0);
  }),
  (o.prototype.setMaxListeners = function (B) {
    if (typeof B != "number" || B < 0 || isNaN(B))
      throw new TypeError('"n" argument must be a positive number');
    return (this._maxListeners = B), this;
  }),
  (o.prototype.getMaxListeners = function () {
    return i(this);
  }),
  (o.prototype.emit = function (B) {
    var U,
      F,
      q,
      j,
      V,
      $,
      W,
      K = B === "error";
    if (($ = this._events)) K = K && $.error == null;
    else if (!K) return !1;
    if (((W = this.domain), K)) {
      if (((U = arguments[1]), !W)) {
        if (U instanceof Error) throw U;
        var G = new Error('Uncaught, unspecified "error" event. (' + U + ")");
        throw ((G.context = U), G);
      }
      return (
        U || (U = new Error('Uncaught, unspecified "error" event')),
        (U.domainEmitter = this),
        (U.domain = W),
        (U.domainThrown = !1),
        W.emit("error", U),
        !1
      );
    }
    if (!(F = $[B])) return !1;
    var H = typeof F == "function";
    switch ((q = arguments.length)) {
      case 1:
        a(F, H, this);
        break;
      case 2:
        c(F, H, this, arguments[1]);
        break;
      case 3:
        d(F, H, this, arguments[1], arguments[2]);
        break;
      case 4:
        u(F, H, this, arguments[1], arguments[2], arguments[3]);
        break;
      default:
        for (j = new Array(q - 1), V = 1; V < q; V++) j[V - 1] = arguments[V];
        h(F, H, this, j);
    }
    return !0;
  }),
  (o.prototype.addListener = function (B, U) {
    return l(this, B, U, !1);
  }),
  (o.prototype.on = o.prototype.addListener),
  (o.prototype.prependListener = function (B, U) {
    return l(this, B, U, !0);
  }),
  (o.prototype.once = function (B, U) {
    if (typeof U != "function")
      throw new TypeError('"listener" argument must be a function');
    return this.on(B, p(this, B, U)), this;
  }),
  (o.prototype.prependOnceListener = function (B, U) {
    if (typeof U != "function")
      throw new TypeError('"listener" argument must be a function');
    return this.prependListener(B, p(this, B, U)), this;
  }),
  (o.prototype.removeListener = function (B, U) {
    var F, q, j, V, $;
    if (typeof U != "function")
      throw new TypeError('"listener" argument must be a function');
    if (!(q = this._events)) return this;
    if (!(F = q[B])) return this;
    if (F === U || (F.listener && F.listener === U))
      --this._eventsCount == 0
        ? (this._events = new r())
        : (delete q[B],
          q.removeListener && this.emit("removeListener", B, F.listener || U));
    else if (typeof F != "function") {
      for (j = -1, V = F.length; V-- > 0; )
        if (F[V] === U || (F[V].listener && F[V].listener === U)) {
          ($ = F[V].listener), (j = V);
          break;
        }
      if (j < 0) return this;
      if (F.length === 1) {
        if (((F[0] = void 0), --this._eventsCount == 0))
          return (this._events = new r()), this;
        delete q[B];
      } else
        (function (W, K) {
          for (var G = K, H = G + 1, Q = W.length; H < Q; G += 1, H += 1)
            W[G] = W[H];
          W.pop();
        })(F, j);
      q.removeListener && this.emit("removeListener", B, $ || U);
    }
    return this;
  }),
  (o.prototype.off = function (B, U) {
    return this.removeListener(B, U);
  }),
  (o.prototype.removeAllListeners = function (B) {
    var U, F;
    if (!(F = this._events)) return this;
    if (!F.removeListener)
      return (
        arguments.length === 0
          ? ((this._events = new r()), (this._eventsCount = 0))
          : F[B] &&
            (--this._eventsCount == 0 ? (this._events = new r()) : delete F[B]),
        this
      );
    if (arguments.length === 0) {
      for (var q, j = Object.keys(F), V = 0; V < j.length; ++V)
        (q = j[V]) !== "removeListener" && this.removeAllListeners(q);
      return (
        this.removeAllListeners("removeListener"),
        (this._events = new r()),
        (this._eventsCount = 0),
        this
      );
    }
    if (typeof (U = F[B]) == "function") this.removeListener(B, U);
    else if (U)
      do this.removeListener(B, U[U.length - 1]);
      while (U[0]);
    return this;
  }),
  (o.prototype.listeners = function (B) {
    var U,
      F = this._events;
    return F && (U = F[B])
      ? typeof U == "function"
        ? [U.listener || U]
        : (function (q) {
            for (var j = new Array(q.length), V = 0; V < j.length; ++V)
              j[V] = q[V].listener || q[V];
            return j;
          })(U)
      : [];
  }),
  (o.listenerCount = function (B, U) {
    return typeof B.listenerCount == "function"
      ? B.listenerCount(U)
      : f.call(B, U);
  }),
  (o.prototype.listenerCount = f),
  (o.prototype.eventNames = function () {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  });
class g extends o {}
(function (B) {
  (B.Issue = "issue"),
    (B.NetworkScoresUpdated = "network-scores-updated"),
    (B.StatsParsingFinished = "stats-parsing-finished");
})(t || (t = {})),
  (function (B) {
    (B.Network = "network"),
      (B.CPU = "cpu"),
      (B.Server = "server"),
      (B.Stream = "stream");
  })(e || (e = {})),
  (function (B) {
    (B.OutboundNetworkQuality = "outbound-network-quality"),
      (B.InboundNetworkQuality = "inbound-network-quality"),
      (B.OutboundNetworkMediaLatency = "outbound-network-media-latency"),
      (B.InboundNetworkMediaLatency = "inbound-network-media-latency"),
      (B.NetworkMediaSyncFailure = "network-media-sync-failure"),
      (B.OutboundNetworkThroughput = "outbound-network-throughput"),
      (B.InboundNetworkThroughput = "inbound-network-throughput"),
      (B.EncoderCPUThrottling = "encoder-cpu-throttling"),
      (B.DecoderCPUThrottling = "decoder-cpu-throttling"),
      (B.ServerIssue = "server-issue"),
      (B.UnknownVideoDecoderIssue = "unknown-video-decoder"),
      (B.LowInboundMOS = "low-inbound-mean-opinion-score"),
      (B.LowOutboundMOS = "low-outbound-mean-opinion-score"),
      (B.FrozenVideoTrack = "frozen-video-track"),
      (B.MissingVideoStreamData = "missing-video-stream-data"),
      (B.MissingAudioStreamData = "missing-audio-stream-data");
  })(s || (s = {})),
  (function (B) {
    (B[(B.BAD = 2.1)] = "BAD"),
      (B[(B.POOR = 2.6)] = "POOR"),
      (B[(B.FAIR = 3.1)] = "FAIR"),
      (B[(B.GOOD = 3.8)] = "GOOD"),
      (B[(B.EXCELLENT = 4.3)] = "EXCELLENT");
  })(n || (n = {}));
const ze = class ze extends o {
  constructor(F) {
    super();
    xe(this, "isStopped", !1);
    xe(this, "reportTimer");
    xe(this, "getStatsInterval");
    xe(this, "compositeStatsParser");
    (this.compositeStatsParser = F.compositeStatsParser),
      (this.getStatsInterval = F.getStatsInterval ?? 1e4);
  }
  get isRunning() {
    return !!this.reportTimer && !this.isStopped;
  }
  startReporting() {
    if (this.reportTimer) return;
    const F = () =>
      setTimeout(() => {
        this.isStopped
          ? (this.reportTimer = void 0)
          : this.parseReports().finally(() => {
              this.reportTimer = F();
            });
      }, this.getStatsInterval);
    (this.isStopped = !1), (this.reportTimer = F());
  }
  stopReporting() {
    (this.isStopped = !0),
      this.reportTimer &&
        (clearTimeout(this.reportTimer), (this.reportTimer = void 0));
  }
  async parseReports() {
    const F = Date.now(),
      q = await this.compositeStatsParser.parse(),
      j = Date.now() - F;
    this.emit(ze.STATS_REPORTS_PARSED, { timeTaken: j, reportItems: q }),
      q.forEach((V) => {
        this.emit(ze.STATS_REPORT_READY_EVENT, V);
      });
  }
};
xe(ze, "STATS_REPORT_READY_EVENT", "stats-report-ready"),
  xe(ze, "STATS_REPORTS_PARSED", "stats-reports-parsed");
let S = ze;
const v = (() => {
  const B = new Map();
  return (U) => {
    const { taskId: F, delayMs: q, maxJitterMs: j, callback: V } = U,
      $ = Math.ceil(Math.random() * (j || 0)),
      W = B.get(F);
    W && clearTimeout(W);
    const K = setTimeout(() => {
      V(), B.delete(F);
    }, q + $);
    B.set(F, K);
  };
})();
var Je;
class k {
  constructor() {
    Ae(this, Je, {});
  }
  calculate(U) {
    const {
        connection: { id: F },
      } = U,
      { mos: q, stats: j } = this.calculateOutboundScore(U) || {},
      { mos: V, stats: $ } = this.calculateInboundScore(U) || {};
    return (
      (_e(this, Je)[F] = U),
      v({ taskId: F, delayMs: 35e3, callback: () => delete _e(this, Je)[F] }),
      {
        outbound: q,
        inbound: V,
        connectionId: F,
        statsSamples: { inboundStatsSample: $, outboundStatsSample: j },
      }
    );
  }
  calculateOutboundScore(U) {
    var X, Z, se, ee;
    const F = [
      ...(((X = U.remote) == null ? void 0 : X.audio.inbound) || []),
      ...(((Z = U.remote) == null ? void 0 : Z.video.inbound) || []),
    ];
    if (!F.length) return;
    const q = _e(this, Je)[U.connection.id];
    if (!q) return;
    const j = [
        ...(((se = q.remote) == null ? void 0 : se.audio.inbound) || []),
        ...(((ee = q.remote) == null ? void 0 : ee.video.inbound) || []),
      ],
      { packetsSent: V } = U.connection,
      $ = q.connection.packetsSent,
      W = F.reduce(
        (ie, re) => {
          const te = j.find((ne) => ne.ssrc === re.ssrc);
          return {
            sumJitter: ie.sumJitter + re.jitter,
            packetsLost: ie.packetsLost + re.packetsLost,
            lastPacketsLost:
              ie.lastPacketsLost +
              ((te == null ? void 0 : te.packetsLost) || 0),
          };
        },
        { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
      ),
      K = 1e3 * U.connection.currentRoundTripTime || 0,
      { sumJitter: G } = W,
      H = G / F.length,
      Q = V - $,
      z = W.packetsLost - W.lastPacketsLost,
      Y = Q && z ? Math.round((100 * z) / (Q + z)) : 0;
    return {
      mos: this.calculateMOS({ avgJitter: H, rtt: K, packetsLoss: Y }),
      stats: { avgJitter: H, rtt: K, packetsLoss: Y },
    };
  }
  calculateInboundScore(U) {
    var X, Z, se, ee;
    const F = [
      ...((X = U.audio) == null ? void 0 : X.inbound),
      ...((Z = U.video) == null ? void 0 : Z.inbound),
    ];
    if (!F.length) return;
    const q = _e(this, Je)[U.connection.id];
    if (!q) return;
    const j = [
        ...((se = q.video) == null ? void 0 : se.inbound),
        ...((ee = q.audio) == null ? void 0 : ee.inbound),
      ],
      { packetsReceived: V } = U.connection,
      $ = q.connection.packetsReceived,
      W = F.reduce(
        (ie, re) => {
          const te = j.find((ne) => ne.ssrc === re.ssrc);
          return {
            sumJitter: ie.sumJitter + re.jitter,
            packetsLost: ie.packetsLost + re.packetsLost,
            lastPacketsLost:
              ie.lastPacketsLost +
              ((te == null ? void 0 : te.packetsLost) || 0),
          };
        },
        { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
      ),
      K = 1e3 * U.connection.currentRoundTripTime || 0,
      { sumJitter: G } = W,
      H = G / F.length,
      Q = V - $,
      z = W.packetsLost - W.lastPacketsLost,
      Y = Q && z ? Math.round((100 * z) / (Q + z)) : 0;
    return {
      mos: this.calculateMOS({ avgJitter: H, rtt: K, packetsLoss: Y }),
      stats: { avgJitter: H, rtt: K, packetsLoss: Y },
    };
  }
  calculateMOS({ avgJitter: U, rtt: F, packetsLoss: q }) {
    const j = F + 2 * U + 10;
    let V = j < 160 ? 93.2 - j / 40 : 93.2 - j / 120 - 10;
    return (V -= 2.5 * q), 1 + 0.035 * V + 7e-6 * V * (V - 60) * (100 - V);
  }
}
Je = new WeakMap();
var Ke, et, tt;
class y {
  constructor(U = {}) {
    Ae(this, Ke, new Map());
    Ae(this, et);
    Ae(this, tt);
    De(this, et, U.statsCleanupTtlMs ?? 35e3),
      De(this, tt, U.maxParsedStatsStorageSize ?? 5);
  }
  detect(U, F) {
    const q = {
        ...U,
        networkScores: {
          ...F,
          statsSamples: (F == null ? void 0 : F.statsSamples) || {},
        },
      },
      j = this.performDetection(q);
    return (
      this.setLastProcessedStats(U.connection.id, q),
      this.performPrevStatsCleanup({ connectionId: U.connection.id }),
      j
    );
  }
  performPrevStatsCleanup(U) {
    const { connectionId: F, cleanupCallback: q } = U;
    _e(this, Ke).has(F) &&
      v({
        taskId: F,
        delayMs: _e(this, et),
        callback: () => {
          this.deleteLastProcessedStats(F), typeof q == "function" && q();
        },
      });
  }
  setLastProcessedStats(U, F) {
    if (!U || F.connection.id !== U) return;
    const q = _e(this, Ke).get(U) ?? [];
    q.push(F), q.length > _e(this, tt) && q.shift(), _e(this, Ke).set(U, q);
  }
  getLastProcessedStats(U) {
    const F = _e(this, Ke).get(U);
    return F == null ? void 0 : F[F.length - 1];
  }
  getAllLastProcessedStats(U) {
    return _e(this, Ke).get(U) ?? [];
  }
  deleteLastProcessedStats(U) {
    _e(this, Ke).delete(U);
  }
}
(Ke = new WeakMap()), (et = new WeakMap()), (tt = new WeakMap());
var it;
class w extends y {
  constructor(F = {}) {
    super(F);
    Ae(this, it);
    De(this, it, F.availableOutgoingBitrateThreshold ?? 1e5);
  }
  performDetection(F) {
    const q = [],
      { availableOutgoingBitrate: j } = F.connection;
    if (j === void 0) return q;
    const V = F.audio.outbound.reduce((K, G) => K + G.targetBitrate, 0),
      $ = F.video.outbound.reduce((K, G) => K + G.bitrate, 0);
    if (!V && !$) return q;
    const W = {
      availableOutgoingBitrate: j,
      videoStreamsTotalBitrate: $,
      audioStreamsTotalTargetBitrate: V,
    };
    return (
      (V > j || ($ > 0 && j < _e(this, it))) &&
        q.push({
          statsSample: W,
          type: e.Network,
          reason: s.OutboundNetworkThroughput,
        }),
      q
    );
  }
}
it = new WeakMap();
var nt, rt, st, ot;
class b extends y {
  constructor(F = {}) {
    super();
    Ae(this, nt);
    Ae(this, rt);
    Ae(this, st);
    Ae(this, ot);
    De(this, nt, F.highPacketLossThresholdPct ?? 5),
      De(this, rt, F.highJitterThreshold ?? 200),
      De(this, st, F.highJitterBufferDelayThresholdMs ?? 500),
      De(this, ot, F.highRttThresholdMs ?? 250);
  }
  performDetection(F) {
    return this.processData(F);
  }
  processData(F) {
    var de, pe, Te, Pe;
    const q = [],
      j = [
        ...((de = F.audio) == null ? void 0 : de.inbound),
        ...((pe = F.video) == null ? void 0 : pe.inbound),
      ];
    if (!j.length) return q;
    const V = this.getLastProcessedStats(F.connection.id);
    if (!V) return q;
    const $ = [
        ...((Te = V.video) == null ? void 0 : Te.inbound),
        ...((Pe = V.audio) == null ? void 0 : Pe.inbound),
      ],
      { packetsReceived: W } = F.connection,
      K = V.connection.packetsReceived,
      G = j.reduce(
        (ye, ae) => {
          const ue = $.find((Ne) => Ne.ssrc === ae.ssrc),
            ve = (ue == null ? void 0 : ue.jitterBufferDelay) || 0,
            Ce = (ue == null ? void 0 : ue.jitterBufferEmittedCount) || 0,
            we = ae.jitterBufferDelay - ve,
            be = ae.jitterBufferEmittedCount - Ce,
            Ie = we && be ? (1e3 * we) / be : 0;
          return {
            sumJitter: ye.sumJitter + ae.jitter,
            sumJitterBufferDelayMs: ye.sumJitterBufferDelayMs + Ie,
            packetsLost: ye.packetsLost + ae.packetsLost,
            lastPacketsLost:
              ye.lastPacketsLost +
              ((ue == null ? void 0 : ue.packetsLost) || 0),
          };
        },
        {
          sumJitter: 0,
          sumJitterBufferDelayMs: 0,
          packetsLost: 0,
          lastPacketsLost: 0,
        }
      ),
      H = 1e3 * F.connection.currentRoundTripTime || 0,
      { sumJitter: Q, sumJitterBufferDelayMs: z } = G,
      Y = Q / j.length,
      X = z / j.length,
      Z = W - K,
      se = G.packetsLost - G.lastPacketsLost,
      ee = Z && se ? Math.round((100 * se) / (Z + se)) : 0,
      ie = ee > _e(this, nt),
      re = Y >= _e(this, rt),
      te = H >= _e(this, ot),
      ne = X > _e(this, st),
      oe = te && !re && !ie,
      ce = ie && re,
      le = re && ne,
      he = { rtt: H, packetLossPct: ee, avgJitter: Y, avgJitterBufferDelay: X };
    return (
      (re || ie) &&
        q.push({
          statsSample: he,
          type: e.Network,
          reason: s.InboundNetworkQuality,
          iceCandidate: F.connection.local.id,
        }),
      oe &&
        q.push({
          statsSample: he,
          type: e.Server,
          reason: s.ServerIssue,
          iceCandidate: F.connection.remote.id,
        }),
      ce &&
        q.push({
          statsSample: he,
          type: e.Network,
          reason: s.InboundNetworkMediaLatency,
          iceCandidate: F.connection.local.id,
        }),
      le &&
        q.push({
          statsSample: he,
          type: e.Network,
          reason: s.NetworkMediaSyncFailure,
          iceCandidate: F.connection.local.id,
        }),
      q
    );
  }
}
(nt = new WeakMap()),
  (rt = new WeakMap()),
  (st = new WeakMap()),
  (ot = new WeakMap());
var at;
class P extends y {
  constructor(F = {}) {
    super();
    Ae(this, at);
    De(this, at, F.correctedSamplesThresholdPct ?? 5);
  }
  performDetection(F) {
    return this.processData(F);
  }
  processData(F) {
    var $;
    const q = F.audio.inbound,
      j = [],
      V =
        ($ = this.getLastProcessedStats(F.connection.id)) == null
          ? void 0
          : $.audio.inbound;
    return (
      V &&
        q.forEach((W) => {
          const K = V.find((Z) => Z.ssrc === W.ssrc);
          if (!K) return;
          const G =
              W.track.insertedSamplesForDeceleration +
              W.track.removedSamplesForAcceleration,
            H =
              K.track.insertedSamplesForDeceleration +
              K.track.removedSamplesForAcceleration;
          if (G === H) return;
          const Q = W.track.totalSamplesReceived - K.track.totalSamplesReceived,
            z = G - H,
            Y = Math.round((100 * z) / Q),
            X = { correctedSamplesPct: Y };
          Y > _e(this, at) &&
            j.push({
              statsSample: X,
              type: e.Network,
              reason: s.NetworkMediaSyncFailure,
              ssrc: W.ssrc,
            });
        }),
      j
    );
  }
}
at = new WeakMap();
var ct, ut;
class T extends y {
  constructor(F = {}) {
    super();
    Ae(this, ct);
    Ae(this, ut);
    De(this, ct, F.highPacketLossThresholdPct ?? 5),
      De(this, ut, F.highJitterThreshold ?? 200);
  }
  performDetection(F) {
    return this.processData(F);
  }
  processData(F) {
    var te, ne, oe, ce;
    const q = [],
      j = [
        ...(((te = F.remote) == null ? void 0 : te.audio.inbound) || []),
        ...(((ne = F.remote) == null ? void 0 : ne.video.inbound) || []),
      ];
    if (!j.length) return q;
    const V = this.getLastProcessedStats(F.connection.id);
    if (!V) return q;
    const $ = [
        ...(((oe = V.remote) == null ? void 0 : oe.audio.inbound) || []),
        ...(((ce = V.remote) == null ? void 0 : ce.video.inbound) || []),
      ],
      { packetsSent: W } = F.connection,
      K = V.connection.packetsSent,
      G = j.reduce(
        (le, he) => {
          const de = $.find((pe) => pe.ssrc === he.ssrc);
          return {
            sumJitter: le.sumJitter + he.jitter,
            packetsLost: le.packetsLost + he.packetsLost,
            lastPacketsLost:
              le.lastPacketsLost +
              ((de == null ? void 0 : de.packetsLost) || 0),
          };
        },
        { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
      ),
      H = 1e3 * F.connection.currentRoundTripTime || 0,
      { sumJitter: Q } = G,
      z = Q / j.length,
      Y = W - K,
      X = G.packetsLost - G.lastPacketsLost,
      Z = Y && X ? Math.round((100 * X) / (Y + X)) : 0,
      se = Z > _e(this, ct),
      ee = z >= _e(this, ut),
      ie = (!se && ee) || ee || se,
      re = { rtt: H, avgJitter: z, packetLossPct: Z };
    return (
      se &&
        ee &&
        q.push({
          statsSample: re,
          type: e.Network,
          reason: s.OutboundNetworkMediaLatency,
          iceCandidate: F.connection.local.id,
        }),
      ie &&
        q.push({
          statsSample: re,
          type: e.Network,
          reason: s.OutboundNetworkQuality,
          iceCandidate: F.connection.local.id,
        }),
      q
    );
  }
}
(ct = new WeakMap()), (ut = new WeakMap());
class L extends y {
  performDetection(U) {
    return this.processData(U);
  }
  processData(U) {
    var V;
    const F = U.video.outbound.filter(
        ($) => $.qualityLimitationReason !== "none"
      ),
      q = [],
      j =
        (V = this.getLastProcessedStats(U.connection.id)) == null
          ? void 0
          : V.video.outbound;
    return (
      j &&
        F.forEach(($) => {
          const W = j.find((G) => G.ssrc === $.ssrc);
          if (!W) return;
          const K = { qualityLimitationReason: $.qualityLimitationReason };
          $.framesSent > W.framesSent ||
            ($.qualityLimitationReason === "cpu" &&
              q.push({
                statsSample: K,
                type: e.CPU,
                reason: s.EncoderCPUThrottling,
                ssrc: $.ssrc,
              }),
            $.qualityLimitationReason === "bandwidth" &&
              q.push({
                statsSample: K,
                type: e.Network,
                reason: s.OutboundNetworkThroughput,
                ssrc: $.ssrc,
              }));
        }),
      q
    );
  }
}
var He;
class D extends y {
  constructor() {
    super(...arguments);
    xe(this, "UNKNOWN_DECODER", "unknown");
    Ae(this, He, {});
  }
  performDetection(F) {
    return this.processData(F);
  }
  performPrevStatsCleanup(F) {
    const { connectionId: q, cleanupCallback: j } = F;
    super.performPrevStatsCleanup({
      ...F,
      cleanupCallback: () => {
        delete _e(this, He)[q], typeof j == "function" && j();
      },
    });
  }
  processData(F) {
    var $;
    const q = [],
      { id: j } = F.connection,
      V =
        ($ = this.getLastProcessedStats(j)) == null ? void 0 : $.video.inbound;
    return (
      F.video.inbound.forEach((W) => {
        const { decoderImplementation: K, ssrc: G } = W;
        if (V == null ? void 0 : V.find((Q) => Q.ssrc === G))
          if (K === this.UNKNOWN_DECODER) {
            if (!this.hadLastDecoderWithIssue(j, G)) {
              this.setLastDecoderWithIssue(j, G, this.UNKNOWN_DECODER);
              const Q = { mimeType: W.mimeType, decoderImplementation: K };
              q.push({
                ssrc: G,
                statsSample: Q,
                type: e.Stream,
                reason: s.UnknownVideoDecoderIssue,
                trackIdentifier: W.track.trackIdentifier,
              });
            }
          } else this.setLastDecoderWithIssue(j, G, void 0);
      }),
      q
    );
  }
  setLastDecoderWithIssue(F, q, j) {
    const V = _e(this, He)[F] ?? {};
    j === void 0 ? delete V[q] : (V[q] = j), (_e(this, He)[F] = V);
  }
  hadLastDecoderWithIssue(F, q) {
    const j = _e(this, He)[F];
    return (j && j[q]) === this.UNKNOWN_DECODER;
  }
}
He = new WeakMap();
const C = (B) => B.reduce((U, F) => U + F, 0) / B.length,
  R = (B, U, F = 30) => {
    var j, V, $, W, K;
    const q = [];
    for (let G = 1; G < U.length - 1; G += 1) {
      const H =
        (V = (j = U[G]) == null ? void 0 : j.video) == null
          ? void 0
          : V.inbound.find((X) => X.ssrc === B);
      if (!H) continue;
      const Q =
        (K =
          (W = ($ = U[G - 1]) == null ? void 0 : $.video) == null
            ? void 0
            : W.inbound) == null
          ? void 0
          : K.find((X) => X.ssrc === B);
      if (!H || !Q) continue;
      const z = H.timestamp - Q.timestamp,
        Y = H.framesDecoded - Q.framesDecoded;
      if (Y > 0) {
        const X = z / Y;
        q.push(X);
      }
    }
    return q.length <= 1
      ? !1
      : ((G) => {
          const H = ((Q, z) =>
            z.reduce((Y, X) => Y + (X - Q) ** 2, 0) / z.length)(C(G), G);
          return Math.sqrt(H);
        })(q) > F;
  },
  M = (B, U) => {
    for (let F = 1; F < U.length; F += 1) {
      const q = U[F].video.inbound.find((W) => W.ssrc === B);
      if (!q) continue;
      const j = U[F - 1].video.inbound.find((W) => W.ssrc === B),
        V = q.frameWidth !== (j == null ? void 0 : j.frameWidth),
        $ = q.frameHeight !== (j == null ? void 0 : j.frameHeight);
      if (V || $) return !0;
    }
    return !1;
  };
var lt, dt, ht;
class I extends y {
  constructor(F = {}) {
    super();
    Ae(this, lt);
    Ae(this, dt);
    Ae(this, ht);
    De(this, lt, F.avgFreezeDurationThresholdMs ?? 1e3),
      De(this, dt, F.frozenDurationThresholdPct ?? 30),
      De(this, ht, F.minMosQuality ?? n.BAD);
  }
  performDetection(F) {
    const q = F.networkScores.inbound;
    return q !== void 0 && q <= _e(this, ht) ? [] : this.processData(F);
  }
  processData(F) {
    const q = [],
      j = this.getAllLastProcessedStats(F.connection.id);
    if (j.length === 0) return [];
    const V = F.video.inbound
      .map(($) => {
        const W = j[j.length - 1].video.inbound.find((z) => z.ssrc === $.ssrc);
        if (!W || M($.ssrc, [j[j.length - 1], F]) || R($.ssrc, j)) return;
        const K = $.freezeCount - (W.freezeCount ?? 0),
          G = 1e3 * ($.totalFreezesDuration - (W.totalFreezesDuration ?? 0)),
          H = K > 0 ? G / K : 0,
          Q = (G / ($.timestamp - W.timestamp)) * 100;
        return Q > _e(this, dt) || H > _e(this, lt)
          ? { ssrc: $.ssrc, avgFreezeDurationMs: H, frozenDurationPct: Q }
          : void 0;
      })
      .filter(($) => $ !== void 0);
    return (
      V.length > 0 &&
        (q.push({
          type: e.Stream,
          reason: s.FrozenVideoTrack,
          statsSample: { ssrcs: V.map(($) => $.ssrc) },
        }),
        this.deleteLastProcessedStats(F.connection.id)),
      q
    );
  }
}
(lt = new WeakMap()), (dt = new WeakMap()), (ht = new WeakMap());
var pt, ft, mt;
class E extends y {
  constructor(F = {}) {
    super(F);
    Ae(this, pt);
    Ae(this, ft);
    Ae(this, mt);
    De(this, pt, F.volatilityThreshold ?? 8),
      De(this, ft, F.affectedStreamsPercentThreshold ?? 30),
      De(this, mt, F.minMosQuality ?? n.BAD);
  }
  performDetection(F) {
    return [...this.getAllLastProcessedStats(F.connection.id), F].find(
      (q) =>
        q.networkScores.inbound !== void 0 &&
        q.networkScores.inbound <= _e(this, mt)
    )
      ? []
      : this.processData(F);
  }
  processData(F) {
    const q = [],
      j = [...this.getAllLastProcessedStats(F.connection.id), F],
      V = F.video.inbound
        .map((W) => {
          if (j.length < 5 || M(W.ssrc, j)) return;
          const K = [];
          for (let H = 0; H < j.length - 1; H += 1) {
            const Q = j[H].video.inbound.find((z) => z.ssrc === W.ssrc);
            (Q == null ? void 0 : Q.framesPerSecond) !== void 0 &&
              K.push(Q.framesPerSecond);
          }
          if (K.length < 5 || R(W.ssrc, j)) return;
          const G = ((H) => {
            if (H.length === 0)
              throw new Error("Cannot calculate volatility for empty array");
            const Q = C(H);
            return (
              ((H.reduce((z, Y) => z + Math.abs(Y - Q), 0) / H.length) * 100) /
              Q
            );
          })(K);
          return G > _e(this, pt)
            ? { ssrc: W.ssrc, allFps: K, volatility: G }
            : void 0;
        })
        .filter((W) => !!W);
    if (V.length === 0) return q;
    const $ = V.length / (F.video.inbound.length / 100);
    return (
      $ > _e(this, ft) &&
        (q.push({
          type: e.CPU,
          reason: s.DecoderCPUThrottling,
          statsSample: { affectedStreamsPercent: $, throtthedStreams: V },
        }),
        this.deleteLastProcessedStats(F.connection.id)),
      q
    );
  }
}
(pt = new WeakMap()), (ft = new WeakMap()), (mt = new WeakMap());
const N = (B) =>
    B.iceConnectionState === "closed" || B.connectionState === "closed",
  _ = (B, U, F) =>
    8 *
    ((q, j, V) => {
      if (!j) return 0;
      const $ = q[V],
        W = j[V];
      if ($ == null || W == null) return 0;
      const K = Math.floor(q.timestamp) - Math.floor(j.timestamp);
      return K === 0 ? 0 : ((Number($) - Number(W)) / K) * 1e3;
    })(B, U, F);
class A {
  constructor(U) {
    xe(this, "connections", []);
    xe(this, "statsParser");
    this.statsParser = U.statsParser;
  }
  listConnections() {
    return [...this.connections];
  }
  addPeerConnection(U) {
    this.connections.push({
      id: U.id ?? String(Date.now() + Math.random().toString(32)),
      pc: U.pc,
    });
  }
  removePeerConnection(U) {
    const F = this.connections.findIndex(({ pc: q }) => q === U.pc);
    F >= 0 && this.removeConnectionsByIndexes([F]);
  }
  async parse() {
    const U = [],
      F = this.connections.map(async (q, j) => {
        if (!N(q.pc)) return this.statsParser.parse(q);
        U.unshift(j);
      });
    return (
      U.length && this.removeConnectionsByIndexes(U),
      (await Promise.all(F)).filter((q) => q !== void 0)
    );
  }
  removeConnectionsByIndexes(U) {
    U.forEach((F) => {
      this.connections.splice(F, 1);
    });
  }
}
class O {
  constructor(U) {
    xe(this, "prevStats", new Map());
    xe(
      this,
      "allowedReportTypes",
      new Set([
        "candidate-pair",
        "inbound-rtp",
        "outbound-rtp",
        "remote-outbound-rtp",
        "remote-inbound-rtp",
        "track",
        "transport",
      ])
    );
    xe(this, "ignoreSSRCList");
    xe(this, "logger");
    (this.ignoreSSRCList = U.ignoreSSRCList ?? []), (this.logger = U.logger);
  }
  get previouslyParsedStatsConnectionsIds() {
    return [...this.prevStats.keys()];
  }
  async parse(U) {
    if (!N(U.pc)) return this.getConnectionStats(U);
    this.logger.debug("Skip stats parsing. Connection is closed.", {
      connection: U,
    });
  }
  async getConnectionStats(U) {
    const { pc: F, id: q } = U;
    try {
      const j = Date.now(),
        V = F.getReceivers().filter((G) => {
          var H;
          return (H = G.track) == null ? void 0 : H.enabled;
        }),
        $ = F.getSenders().filter((G) => {
          var H;
          return (H = G.track) == null ? void 0 : H.enabled;
        }),
        W = await Promise.all(V.map((G) => G.getStats())),
        K = await Promise.all($.map((G) => G.getStats()));
      return {
        id: q,
        stats: this.mapReportsStats([...W, ...K], U),
        timeTaken: Date.now() - j,
      };
    } catch (j) {
      return void this.logger.error("Failed to get stats for PC", {
        id: q,
        pc: F,
        error: j,
      });
    }
  }
  mapReportsStats(U, F) {
    const q = {
      audio: { inbound: [], outbound: [] },
      video: { inbound: [], outbound: [] },
      connection: {},
      remote: {
        video: { inbound: [], outbound: [] },
        audio: { inbound: [], outbound: [] },
      },
    };
    U.forEach(($) => {
      $.forEach((W) => {
        this.allowedReportTypes.has(W.type) &&
          this.updateMappedStatsWithReportItemData(W, q, $);
      });
    });
    const { id: j } = F,
      V = this.prevStats.get(j);
    return (
      V && this.propagateStatsWithRateValues(q, V.stats),
      this.prevStats.set(j, { stats: q, ts: Date.now() }),
      v({ taskId: j, delayMs: 35e3, callback: () => this.prevStats.delete(j) }),
      q
    );
  }
  updateMappedStatsWithReportItemData(U, F, q) {
    const j = U.type;
    if (j === "candidate-pair" && U.state === "succeeded" && U.nominated)
      return void (F.connection = this.prepareConnectionStats(U, q));
    const V = this.getMediaType(U);
    if (!V) return;
    const $ = U.ssrc;
    if (!$ || !this.ignoreSSRCList.includes($))
      if (j !== "outbound-rtp")
        if (j !== "inbound-rtp")
          j !== "remote-outbound-rtp"
            ? j === "remote-inbound-rtp" &&
              (this.mapConnectionStatsIfNecessary(F, U, q),
              F.remote[V].inbound.push({ ...U }))
            : F.remote[V].outbound.push({ ...U });
        else {
          const W = q.get(U.trackId) || q.get(U.mediaSourceId) || {};
          this.mapConnectionStatsIfNecessary(F, U, q);
          const K = { ...U, track: { ...W } };
          F[V].inbound.push(K);
        }
      else {
        const W = q.get(U.trackId) || q.get(U.mediaSourceId) || {},
          K = { ...U, track: { ...W } };
        F[V].outbound.push(K);
      }
  }
  getMediaType(U) {
    const F = U.mediaType || U.kind;
    if (!["audio", "video"].includes(F)) {
      const { id: q } = U;
      return q
        ? String(q).includes("Video")
          ? "video"
          : String(q).includes("Audio")
          ? "audio"
          : void 0
        : void 0;
    }
    return F;
  }
  propagateStatsWithRateValues(U, F) {
    U.audio.inbound.forEach((q) => {
      const j = F.audio.inbound.find(({ id: V }) => V === q.id);
      (q.bitrate = _(q, j, "bytesReceived")),
        (q.packetRate = _(q, j, "packetsReceived"));
    }),
      U.audio.outbound.forEach((q) => {
        const j = F.audio.outbound.find(({ id: V }) => V === q.id);
        (q.bitrate = _(q, j, "bytesSent")),
          (q.packetRate = _(q, j, "packetsSent"));
      }),
      U.video.inbound.forEach((q) => {
        const j = F.video.inbound.find(({ id: V }) => V === q.id);
        (q.bitrate = _(q, j, "bytesReceived")),
          (q.packetRate = _(q, j, "packetsReceived"));
      }),
      U.video.outbound.forEach((q) => {
        const j = F.video.outbound.find(({ id: V }) => V === q.id);
        (q.bitrate = _(q, j, "bytesSent")),
          (q.packetRate = _(q, j, "packetsSent"));
      });
  }
  mapConnectionStatsIfNecessary(U, F, q) {
    if (U.connection.id || !F.transportId) return;
    const j = q.get(F.transportId);
    if (j && j.selectedCandidatePairId) {
      const V = q.get(j.selectedCandidatePairId);
      U.connection = this.prepareConnectionStats(V, q);
    }
  }
  prepareConnectionStats(U, F) {
    if (!U || !F) return {};
    const q = { ...U };
    if (q.remoteCandidateId) {
      const j = F.get(q.remoteCandidateId);
      q.remote = { ...j };
    }
    if (q.localCandidateId) {
      const j = F.get(q.localCandidateId);
      q.local = { ...j };
    }
    return q;
  }
}
var Ge, Ye, Xe;
const yt = class yt extends y {
  constructor(F = {}) {
    super();
    Ae(this, Ge, new Map());
    Ae(this, Ye);
    Ae(this, Xe);
    De(this, Ye, F.timeoutMs ?? 15e3), De(this, Xe, F.steps ?? 3);
  }
  performDetection(F) {
    return this.processData(F);
  }
  processData(F) {
    const q = [],
      j = [...this.getAllLastProcessedStats(F.connection.id), F];
    if (j.length < _e(this, Xe)) return q;
    const V = j.slice(-_e(this, Xe)),
      $ = V.map((K) => K.video.inbound),
      W = V.map((K) => K.audio.inbound);
    return (
      q.push(...this.detectMissingData(W, e.Stream, s.MissingAudioStreamData)),
      q.push(...this.detectMissingData($, e.Stream, s.MissingVideoStreamData)),
      new Set(_e(this, Ge).keys()).forEach((K) => {
        const G = _e(this, Ge).get(K);
        G && Date.now() - G > _e(this, Ye) && this.removeMarkedIssue(K);
      }),
      q
    );
  }
  detectMissingData(F, q, j) {
    const V = [],
      $ = F.pop(),
      W = yt.mapStatsByTrackId(F);
    return (
      $.forEach((K) => {
        const G = K.track.trackIdentifier,
          H = W.get(G);
        if (
          !Array.isArray(H) ||
          H.length === 0 ||
          K.track.detached ||
          K.track.ended
        )
          return;
        if (!yt.isAllBytesReceivedDidntChange(K.bytesReceived, H))
          return void this.removeMarkedIssue(G);
        if (!this.markIssue(G)) return;
        const Q = { bytesReceived: K.bytesReceived };
        V.push({ type: q, reason: j, statsSample: Q, trackIdentifier: G });
      }),
      V
    );
  }
  static mapStatsByTrackId(F) {
    const q = new Map();
    return (
      F.forEach((j) => {
        j.forEach((V) => {
          const $ = q.get(V.track.trackIdentifier) || [];
          $.push(V), q.set(V.track.trackIdentifier, $);
        });
      }),
      q
    );
  }
  static isAllBytesReceivedDidntChange(F, q) {
    for (let j = 0; j < q.length; j += 1)
      if (q[j].bytesReceived !== F) return !1;
    return !0;
  }
  markIssue(F) {
    const q = Date.now(),
      j = _e(this, Ge).get(F);
    return (!j || q - j > _e(this, Ye)) && (_e(this, Ge).set(F, q), !0);
  }
  removeMarkedIssue(F) {
    _e(this, Ge).delete(F);
  }
};
(Ge = new WeakMap()), (Ye = new WeakMap()), (Xe = new WeakMap());
let J = yt;
var $e;
class x {
  constructor(U) {
    xe(this, "eventEmitter");
    Ae(this, $e, !1);
    xe(this, "detectors", []);
    xe(this, "networkScoresCalculator");
    xe(this, "statsReporter");
    xe(this, "compositeStatsParser");
    xe(this, "logger");
    xe(this, "autoAddPeerConnections");
    (this.logger = U.logger ?? {
      debug: () => {},
      info: () => {},
      warn: () => {},
      error: () => {},
    }),
      (this.eventEmitter = U.issueEmitter ?? new g()),
      U.onIssues && this.eventEmitter.on(t.Issue, U.onIssues),
      U.onNetworkScoresUpdated &&
        this.eventEmitter.on(t.NetworkScoresUpdated, U.onNetworkScoresUpdated),
      (this.detectors = U.detectors ?? [
        new L(),
        new b(),
        new T(),
        new P(),
        new w(),
        new D(),
        new I(),
        new E(),
        new J(),
      ]),
      (this.networkScoresCalculator = U.networkScoresCalculator ?? new k()),
      (this.compositeStatsParser =
        U.compositeStatsParser ??
        new A({
          statsParser: new O({
            ignoreSSRCList: U.ignoreSSRCList,
            logger: this.logger,
          }),
        })),
      (this.statsReporter =
        U.statsReporter ??
        new S({
          compositeStatsParser: this.compositeStatsParser,
          getStatsInterval: U.getStatsInterval ?? 5e3,
        })),
      (window.wid = this),
      (this.autoAddPeerConnections = U.autoAddPeerConnections ?? !0),
      this.autoAddPeerConnections && this.wrapRTCPeerConnection(),
      this.statsReporter.on(S.STATS_REPORT_READY_EVENT, (F) => {
        const q = this.calculateNetworkScores(F.stats);
        this.detectIssues({ data: F.stats }, q);
      }),
      this.statsReporter.on(S.STATS_REPORTS_PARSED, (F) => {
        const q = { timeTaken: F.timeTaken, ts: Date.now() };
        U.onStats && U.onStats(F.reportItems),
          this.eventEmitter.emit(t.StatsParsingFinished, q);
      });
  }
  watchNewPeerConnections() {
    if (!this.autoAddPeerConnections)
      throw new Error(
        "Auto add peer connections was disabled in the constructor."
      );
    _e(this, $e)
      ? this.logger.warn(
          "WebRTCIssueDetector is already started. Skip processing"
        )
      : (this.logger.info("Start watching peer connections"),
        De(this, $e, !0),
        this.statsReporter.startReporting());
  }
  stopWatchingNewPeerConnections() {
    _e(this, $e)
      ? (this.logger.info("Stop watching peer connections"),
        De(this, $e, !1),
        this.statsReporter.stopReporting())
      : this.logger.warn(
          "WebRTCIssueDetector is already stopped. Skip processing"
        );
  }
  handleNewPeerConnection(U, F) {
    _e(this, $e) || !this.autoAddPeerConnections
      ? (_e(this, $e) ||
          this.autoAddPeerConnections !== !1 ||
          (this.logger.info("Starting stats reporting for new peer connection"),
          De(this, $e, !0),
          this.statsReporter.startReporting()),
        this.logger.debug("Handling new peer connection", U),
        this.compositeStatsParser.addPeerConnection({ pc: U, id: F }))
      : this.logger.debug(
          "Skip handling new peer connection. Detector is not running",
          U
        );
  }
  emitIssues(U) {
    this.eventEmitter.emit(t.Issue, U);
  }
  detectIssues({ data: U }, F) {
    const q = this.detectors.reduce((j, V) => [...j, ...V.detect(U, F)], []);
    q.length > 0 && this.emitIssues(q);
  }
  calculateNetworkScores(U) {
    const F = this.networkScoresCalculator.calculate(U);
    return this.eventEmitter.emit(t.NetworkScoresUpdated, F), F;
  }
  wrapRTCPeerConnection() {
    if (!window.RTCPeerConnection)
      return void this.logger.warn(
        "No RTCPeerConnection found in browser window. Skipping"
      );
    const U = window.RTCPeerConnection,
      F = (j) => this.handleNewPeerConnection(j);
    function q(j) {
      const V = new U(j);
      return F(V), V;
    }
    (q.prototype = U.prototype), (window.RTCPeerConnection = q);
  }
}
$e = new WeakMap();
var WebRTCConnectionQualityIndicator = (function (B) {
    __extends(U, B);
    function U() {
      var F = (B !== null && B.apply(this, arguments)) || this;
      return (F.issueDetector = null), (F.mosScores = null), F;
    }
    return (
      (U.prototype._start = function (F) {
        var q = this;
        (this.issueDetector = new x({
          autoAddPeerConnections: !1,
          getStatsInterval: 3e3,
          onNetworkScoresUpdated: function (j) {
            (q.mosScores = j), q.handleStatsChanged();
          },
        })),
          this.issueDetector.handleNewPeerConnection(F);
      }),
      (U.prototype._stop = function () {
        this.issueDetector &&
          (this.issueDetector.stopWatchingNewPeerConnections(),
          (this.issueDetector = null)),
          (this.mosScores = null);
      }),
      (U.prototype.calculateConnectionQuality = function () {
        return !this.mosScores ||
          (this.mosScores.inbound && this.mosScores.outbound)
          ? ConnectionQuality.UNKNOWN
          : (this.mosScores.inbound && this.mosScores.inbound < 3) ||
            (this.mosScores.outbound && this.mosScores.outbound < 3)
          ? ConnectionQuality.BAD
          : ConnectionQuality.GOOD;
      }),
      U
    );
  })(AbstractConnectionQualityIndicator),
  VoiceChatState;
(function (B) {
  (B.INACTIVE = "inactive"),
    (B.STARTING = "starting"),
    (B.ACTIVE = "started"),
    (B.STOPPING = "stopping");
})(VoiceChatState || (VoiceChatState = {}));
var AbstractVoiceChat = (function () {
    function B() {}
    return B;
  })(),
  AbstractVoiceChatImplementation = (function (B) {
    __extends(U, B);
    function U() {
      var F = (B !== null && B.apply(this, arguments)) || this;
      return (F._isMuted = !0), (F.state = VoiceChatState.INACTIVE), F;
    }
    return (
      Object.defineProperty(U.prototype, "isMuted", {
        get: function () {
          return this._isMuted;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(U.prototype, "isVoiceChatting", {
        get: function () {
          return this.state !== VoiceChatState.INACTIVE;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (U.prototype.startVoiceChat = function (F) {
        return __awaiter$a(this, void 0, void 0, function () {
          var q;
          return __generator(this, function (j) {
            switch (j.label) {
              case 0:
                return this.state === VoiceChatState.INACTIVE
                  ? [3, 2]
                  : [4, this.stopVoiceChat()];
              case 1:
                j.sent(), (j.label = 2);
              case 2:
                return (
                  j.trys.push([2, 4, , 6]),
                  (this.state = VoiceChatState.STARTING),
                  [4, this._startVoiceChat(F)]
                );
              case 3:
                return j.sent(), (this.state = VoiceChatState.ACTIVE), [3, 6];
              case 4:
                return (q = j.sent()), [4, this.stopVoiceChat()];
              case 5:
                throw (j.sent(), q);
              case 6:
                return [2];
            }
          });
        });
      }),
      (U.prototype.stopVoiceChat = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (F) {
            switch (F.label) {
              case 0:
                return this.state === VoiceChatState.INACTIVE
                  ? [2]
                  : ((this.state = VoiceChatState.STOPPING),
                    [4, this._stopVoiceChat()]);
              case 1:
                return (
                  F.sent(),
                  (this._isMuted = !0),
                  (this.state = VoiceChatState.INACTIVE),
                  [2]
                );
            }
          });
        });
      }),
      (U.prototype._mute = function () {}),
      (U.prototype._unmute = function () {}),
      (U.prototype.mute = function () {
        this.isVoiceChatting && (this._mute(), (this._isMuted = !0));
      }),
      (U.prototype.unmute = function () {
        this.isVoiceChatting && (this._unmute(), (this._isMuted = !1));
      }),
      U
    );
  })(AbstractVoiceChat);
function sleep(B) {
  return new Promise(function (U) {
    return setTimeout(U, B);
  });
}
function convertFloat32ToS16PCM(B) {
  for (var U = new Int16Array(B.length), F = 0; F < B.length; F++) {
    var q = Math.max(-1, Math.min(1, B[F]));
    U[F] = q < 0 ? q * 32768 : q * 32767;
  }
  return U;
}
var LivekitVoiceChat = (function (B) {
    __extends(U, B);
    function U() {
      var F = (B !== null && B.apply(this, arguments)) || this;
      return (F.room = null), (F.track = null), F;
    }
    return (
      (U.prototype._startVoiceChat = function (F) {
        return __awaiter$a(this, void 0, void 0, function () {
          var q, j;
          return __generator(this, function (V) {
            switch (V.label) {
              case 0:
                return (
                  (this.room = F.room),
                  (q = this),
                  [
                    4,
                    createLocalAudioTrack({
                      echoCancellation: !0,
                      noiseSuppression: !0,
                      autoGainControl: !0,
                    }),
                  ]
                );
              case 1:
                return (
                  (q.track = V.sent()),
                  [4, this.room.localParticipant.publishTrack(this.track)]
                );
              case 2:
                return (
                  V.sent(),
                  !((j = F.config) === null || j === void 0) && j.defaultMuted
                    ? this.mute()
                    : this.unmute(),
                  [4, sleep(4e3)]
                );
              case 3:
                return V.sent(), [2];
            }
          });
        });
      }),
      (U.prototype._stopVoiceChat = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          var F;
          return __generator(this, function (q) {
            return (
              !((F = this.room) === null || F === void 0) &&
                F.localParticipant &&
                this.room.localParticipant
                  .getTrackPublications()
                  .forEach(function (j) {
                    j.track &&
                      j.track.kind === Track.Kind.Audio &&
                      j.track.stop();
                  }),
              this.track && (this.track.stop(), (this.track = null)),
              [2]
            );
          });
        });
      }),
      (U.prototype._mute = function () {
        this.track && !this.track.isMuted && this.track.mute();
      }),
      (U.prototype._unmute = function () {
        this.track && this.track.isMuted && this.track.unmute();
      }),
      U
    );
  })(AbstractVoiceChatImplementation),
  WebSocketVoiceChat = (function (B) {
    __extends(U, B);
    function U() {
      var F = (B !== null && B.apply(this, arguments)) || this;
      return (
        (F.audioContext = null),
        (F.webSocket = null),
        (F.scriptProcessor = null),
        (F.mediaStreamAudioSource = null),
        (F.mediaDevicesStream = null),
        (F.audioRawFrame = null),
        F
      );
    }
    return (
      (U.prototype._startVoiceChat = function (F) {
        return __awaiter$a(this, void 0, void 0, function () {
          var q,
            j = this,
            V,
            $,
            W,
            K;
          return __generator(this, function (G) {
            switch (G.label) {
              case 0:
                if (
                  !navigator.mediaDevices ||
                  !navigator.mediaDevices.getUserMedia
                )
                  throw new Error(
                    "Cannot start voice chat without media devices"
                  );
                return (
                  (this.webSocket = F.webSocket),
                  (this.audioRawFrame = F.audioRawFrame),
                  (this.audioContext = new window.AudioContext({
                    latencyHint: "interactive",
                    sampleRate: 16e3,
                  })),
                  (!((V = F.config) === null || V === void 0) &&
                    V.defaultMuted) ||
                    this.unmute(),
                  [
                    4,
                    navigator.mediaDevices.getUserMedia({
                      audio: {
                        sampleRate: 16e3,
                        channelCount: 1,
                        autoGainControl: !0,
                        echoCancellation: !0,
                        noiseSuppression: !0,
                      },
                    }),
                  ]
                );
              case 1:
                return (
                  (q = G.sent()),
                  (this.mediaDevicesStream = q),
                  (this.mediaStreamAudioSource =
                    ($ = this.audioContext) === null || $ === void 0
                      ? void 0
                      : $.createMediaStreamSource(q)),
                  (this.scriptProcessor =
                    (W = this.audioContext) === null || W === void 0
                      ? void 0
                      : W.createScriptProcessor(512, 1, 1)),
                  this.mediaStreamAudioSource.connect(this.scriptProcessor),
                  this.scriptProcessor.connect(
                    (K = this.audioContext) === null || K === void 0
                      ? void 0
                      : K.destination
                  ),
                  (this.scriptProcessor.onaudioprocess = function (H) {
                    var Q;
                    if (!(!j.webSocket || !j.audioRawFrame)) {
                      var z;
                      j.isMuted
                        ? (z = new Float32Array(512))
                        : (z = H.inputBuffer.getChannelData(0));
                      var Y = convertFloat32ToS16PCM(z),
                        X = new Uint8Array(Y.buffer),
                        Z = j.audioRawFrame.create({
                          audio: {
                            audio: Array.from(X),
                            sampleRate: 16e3,
                            numChannels: 1,
                          },
                        }),
                        se = new Uint8Array(j.audioRawFrame.encode(Z).finish());
                      (Q = j.webSocket) === null || Q === void 0 || Q.send(se);
                    }
                  }),
                  [4, sleep(2e3)]
                );
              case 2:
                return G.sent(), [2];
            }
          });
        });
      }),
      (U.prototype._stopVoiceChat = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          var F, q;
          return __generator(this, function (j) {
            return (
              this.audioContext && (this.audioContext = null),
              this.scriptProcessor &&
                (this.scriptProcessor.disconnect(),
                (this.scriptProcessor = null)),
              this.mediaStreamAudioSource &&
                (this.mediaStreamAudioSource.disconnect(),
                (this.mediaStreamAudioSource = null)),
              this.mediaDevicesStream &&
                ((q =
                  (F = this.mediaDevicesStream) === null || F === void 0
                    ? void 0
                    : F.getTracks()) === null ||
                  q === void 0 ||
                  q.forEach(function (V) {
                    return V.stop();
                  }),
                (this.mediaDevicesStream = null)),
              [2]
            );
          });
        });
      }),
      U
    );
  })(AbstractVoiceChatImplementation),
  VoiceChatTransport;
(function (B) {
  (B.LIVEKIT = "livekit"), (B.WEBSOCKET = "websocket");
})(VoiceChatTransport || (VoiceChatTransport = {}));
var VoiceChatFactory = (function (B) {
    __extends(U, B);
    function U(F) {
      var q = F.voiceChatInstance,
        j = F.initialConfig,
        V = B.call(this) || this;
      return (V.initialConfig = j), (V.voiceChat = q), V;
    }
    return (
      Object.defineProperty(U.prototype, "isMuted", {
        get: function () {
          return this.voiceChat.isMuted;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(U.prototype, "isVoiceChatting", {
        get: function () {
          return this.voiceChat.isVoiceChatting;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (U.prototype.startVoiceChat = function (F) {
        return __awaiter$a(this, arguments, void 0, function (q) {
          var j = q.config;
          return __generator(this, function (V) {
            switch (V.label) {
              case 0:
                return [
                  4,
                  this.voiceChat.startVoiceChat(
                    __assign(__assign({}, this.initialConfig), { config: j })
                  ),
                ];
              case 1:
                return V.sent(), [2];
            }
          });
        });
      }),
      (U.prototype.stopVoiceChat = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (F) {
            switch (F.label) {
              case 0:
                return [4, this.voiceChat.stopVoiceChat()];
              case 1:
                return F.sent(), [2];
            }
          });
        });
      }),
      (U.prototype.mute = function () {
        this.voiceChat.mute();
      }),
      (U.prototype.unmute = function () {
        this.voiceChat.unmute();
      }),
      (U.createLiveKitVoiceChat = function (F) {
        return new this({
          voiceChatInstance: new LivekitVoiceChat(),
          initialConfig: F,
        });
      }),
      (U.createWebSocketVoiceChat = function (F) {
        return new this({
          voiceChatInstance: new WebSocketVoiceChat(),
          initialConfig: F,
        });
      }),
      U
    );
  })(AbstractVoiceChat),
  AvatarQuality;
(function (B) {
  (B.Low = "low"), (B.Medium = "medium"), (B.High = "high");
})(AvatarQuality || (AvatarQuality = {}));
var VoiceEmotion;
(function (B) {
  (B.EXCITED = "excited"),
    (B.SERIOUS = "serious"),
    (B.FRIENDLY = "friendly"),
    (B.SOOTHING = "soothing"),
    (B.BROADCASTER = "broadcaster");
})(VoiceEmotion || (VoiceEmotion = {}));
var ElevenLabsModel;
(function (B) {
  (B.eleven_flash_v2_5 = "eleven_flash_v2_5"),
    (B.eleven_multilingual_v2 = "eleven_multilingual_v2");
})(ElevenLabsModel || (ElevenLabsModel = {}));
var STTProvider;
(function (B) {
  (B.DEEPGRAM = "deepgram"), (B.GLADIA = "gladia");
})(STTProvider || (STTProvider = {}));
var TaskType;
(function (B) {
  (B.TALK = "talk"), (B.REPEAT = "repeat");
})(TaskType || (TaskType = {}));
var TaskMode;
(function (B) {
  (B.SYNC = "sync"), (B.ASYNC = "async");
})(TaskMode || (TaskMode = {}));
var StreamingEvents;
(function (B) {
  (B.AVATAR_START_TALKING = "avatar_start_talking"),
    (B.AVATAR_STOP_TALKING = "avatar_stop_talking"),
    (B.AVATAR_TALKING_MESSAGE = "avatar_talking_message"),
    (B.AVATAR_END_MESSAGE = "avatar_end_message"),
    (B.USER_TALKING_MESSAGE = "user_talking_message"),
    (B.USER_END_MESSAGE = "user_end_message"),
    (B.USER_START = "user_start"),
    (B.USER_STOP = "user_stop"),
    (B.USER_SILENCE = "user_silence"),
    (B.STREAM_READY = "stream_ready"),
    (B.STREAM_DISCONNECTED = "stream_disconnected"),
    (B.CONNECTION_QUALITY_CHANGED = "connection_quality_changed");
})(StreamingEvents || (StreamingEvents = {}));
var APIError = (function (B) {
    __extends(U, B);
    function U(F, q, j) {
      var V = B.call(this, F) || this;
      return (V.name = "APIError"), (V.status = q), (V.responseText = j), V;
    }
    return U;
  })(Error),
  ConnectionQualityIndicatorClass = QualityIndicatorMixer(
    {
      TrackerClass: LiveKitConnectionQualityIndicator,
      getParams: function (B) {
        return B;
      },
    },
    {
      TrackerClass: WebRTCConnectionQualityIndicator,
      getParams: function (B) {
        var U;
        return (
          (U = B.engine.pcManager) === null || U === void 0
            ? void 0
            : U.subscriber
        )._pc;
      },
    }
  ),
  StreamingAvatar = (function () {
    function B(U) {
      var F = U.token,
        q = U.basePath,
        j = q === void 0 ? "https://api.heygen.com" : q,
        V = this;
      (this.room = null),
        (this.mediaStream = null),
        (this.eventTarget = new EventTarget()),
        (this.webSocket = null),
        (this.sessionId = null),
        (this.voiceChat = null),
        (this.isLiveKitTransport = !1),
        (this.token = F),
        (this.basePath = j),
        (this.connectionQualityIndicator = new ConnectionQualityIndicatorClass(
          function ($) {
            return V.emit(StreamingEvents.CONNECTION_QUALITY_CHANGED, $);
          }
        ));
    }
    return (
      Object.defineProperty(B.prototype, "connectionQuality", {
        get: function () {
          return this.connectionQualityIndicator.connectionQuality;
        },
        enumerable: !1,
        configurable: !0,
      }),
      Object.defineProperty(B.prototype, "isInputAudioMuted", {
        get: function () {
          var U, F;
          return (F =
            (U = this.voiceChat) === null || U === void 0
              ? void 0
              : U.isMuted) !== null && F !== void 0
            ? F
            : !0;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (B.prototype.muteInputAudio = function () {
        var U;
        (U = this.voiceChat) === null || U === void 0 || U.mute();
      }),
      (B.prototype.unmuteInputAudio = function () {
        var U;
        (U = this.voiceChat) === null || U === void 0 || U.unmute();
      }),
      (B.prototype.createStartAvatar = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F;
          return __generator(this, function (q) {
            switch (q.label) {
              case 0:
                return [4, this.newSession(U)];
              case 1:
                return (F = q.sent()), [2, this.startAvatar(U, F)];
            }
          });
        });
      }),
      (B.prototype.startAvatar = function (U, F) {
        return __awaiter$a(this, void 0, void 0, function () {
          var q,
            j,
            V = this;
          return __generator(this, function ($) {
            switch ($.label) {
              case 0:
                (this.sessionId = F.session_id),
                  (this.isLiveKitTransport =
                    U.voiceChatTransport === VoiceChatTransport.LIVEKIT),
                  (q = new Room({
                    adaptiveStream: !0,
                    dynacast: !0,
                    videoCaptureDefaults: {
                      resolution: VideoPresets.h720.resolution,
                    },
                  })),
                  (this.room = q),
                  (this.mediaStream = null),
                  q.on(RoomEvent.DataReceived, function (W) {
                    var K = null;
                    try {
                      var G = new TextDecoder().decode(W);
                      K = JSON.parse(G);
                    } catch (H) {
                      console.error(H);
                    }
                    K && V.emit(K.type, K);
                  }),
                  (j = new MediaStream()),
                  q.on(RoomEvent.TrackSubscribed, function (W) {
                    if (W.kind === "video" || W.kind === "audio") {
                      j.addTrack(W.mediaStreamTrack);
                      var K = j.getVideoTracks().length > 0,
                        G = j.getAudioTracks().length > 0;
                      K &&
                        G &&
                        !V.mediaStream &&
                        ((V.mediaStream = j),
                        V.emit(StreamingEvents.STREAM_READY, V.mediaStream));
                    }
                  }),
                  q.on(RoomEvent.TrackUnsubscribed, function (W) {
                    var K = W.mediaStreamTrack;
                    K && j.removeTrack(K);
                  }),
                  q.on(RoomEvent.Disconnected, function (W) {
                    V.emit(StreamingEvents.STREAM_DISCONNECTED, W);
                  }),
                  ($.label = 1);
              case 1:
                return (
                  $.trys.push([1, 3, , 4]),
                  [4, q.prepareConnection(F.url, F.access_token)]
                );
              case 2:
                return $.sent(), [3, 4];
              case 3:
                return $.sent(), [3, 4];
              case 4:
                return [4, this.startSession()];
              case 5:
                return $.sent(), [4, q.connect(F.url, F.access_token)];
              case 6:
                return (
                  $.sent(),
                  [
                    4,
                    this.connectWebSocket({
                      useSilencePrompt: !!U.useSilencePrompt,
                    }),
                  ]
                );
              case 7:
                return (
                  $.sent(),
                  this.initVoiceChat(
                    U.voiceChatTransport || VoiceChatTransport.WEBSOCKET
                  ),
                  this.connectionQualityIndicator.start(q),
                  [2, F]
                );
            }
          });
        });
      }),
      (B.prototype.startVoiceChat = function () {
        return __awaiter$a(this, arguments, void 0, function (U) {
          var F,
            q = U === void 0 ? {} : U,
            j = q.isInputAudioMuted;
          return __generator(this, function (V) {
            switch (V.label) {
              case 0:
                return [
                  4,
                  (F = this.voiceChat) === null || F === void 0
                    ? void 0
                    : F.startVoiceChat({ config: { defaultMuted: j } }),
                ];
              case 1:
                return V.sent(), [2];
            }
          });
        });
      }),
      (B.prototype.closeVoiceChat = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          var U;
          return __generator(this, function (F) {
            switch (F.label) {
              case 0:
                return [
                  4,
                  (U = this.voiceChat) === null || U === void 0
                    ? void 0
                    : U.stopVoiceChat(),
                ];
              case 1:
                return F.sent(), [2];
            }
          });
        });
      }),
      (B.prototype.newSession = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F, q, j, V, $;
          return __generator(this, function (W) {
            return [
              2,
              this.request("/v1/streaming.new", {
                avatar_name: U.avatarName,
                quality: U.quality,
                knowledge_base_id: U.knowledgeId,
                knowledge_base: U.knowledgeBase,
                voice: {
                  voice_id:
                    (F = U.voice) === null || F === void 0 ? void 0 : F.voiceId,
                  rate:
                    (q = U.voice) === null || q === void 0 ? void 0 : q.rate,
                  emotion:
                    (j = U.voice) === null || j === void 0 ? void 0 : j.emotion,
                  elevenlabs_settings: __assign(
                    __assign(
                      {},
                      (V = U == null ? void 0 : U.voice) === null ||
                        V === void 0
                        ? void 0
                        : V.elevenlabsSettings
                    ),
                    {
                      model_id:
                        ($ = U.voice) === null || $ === void 0
                          ? void 0
                          : $.model,
                    }
                  ),
                },
                language: U.language,
                version: "v2",
                video_encoding: "H264",
                source: "sdk",
                disable_idle_timeout: U.disableIdleTimeout,
                stt_settings: U.sttSettings,
                ia_is_livekit_transport:
                  U.voiceChatTransport === VoiceChatTransport.LIVEKIT,
                silence_response: U.useSilencePrompt,
                activity_idle_timeout: U.activityIdleTimeout,
              }),
            ];
          });
        });
      }),
      (B.prototype.startSession = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return [
              2,
              this.request("/v1/streaming.start", {
                session_id: this.sessionId,
              }),
            ];
          });
        });
      }),
      (B.prototype.speak = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F, q;
          return __generator(this, function (j) {
            if (
              ((F = U.taskType || U.task_type || TaskType.TALK),
              (q = U.taskMode || TaskMode.ASYNC),
              F === TaskType.TALK && q === TaskMode.ASYNC)
            ) {
              if (this.isLiveKitTransport && this.room)
                return this.sendLivekitMessage(U.text), [2];
              if (
                !this.isLiveKitTransport &&
                this.webSocket &&
                this.audioRawFrame
              )
                return this.sendWebsocketMessage(U.text), [2];
            }
            return [
              2,
              this.request("/v1/streaming.task", {
                text: U.text,
                session_id: this.sessionId,
                task_mode: U.taskMode,
                task_type: U.taskType,
              }),
            ];
          });
        });
      }),
      (B.prototype.startListening = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return [
              2,
              this.request("/v1/streaming.start_listening", {
                session_id: this.sessionId,
              }),
            ];
          });
        });
      }),
      (B.prototype.stopListening = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return [
              2,
              this.request("/v1/streaming.stop_listening", {
                session_id: this.sessionId,
              }),
            ];
          });
        });
      }),
      (B.prototype.interrupt = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return [
              2,
              this.request("/v1/streaming.interrupt", {
                session_id: this.sessionId,
              }),
            ];
          });
        });
      }),
      (B.prototype.stopAvatar = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return (
              this.closeVoiceChat(),
              this.connectionQualityIndicator.stop(),
              (this.voiceChat = null),
              this.webSocket &&
                (this.webSocket.close(), (this.webSocket = null)),
              [
                2,
                this.request("/v1/streaming.stop", {
                  session_id: this.sessionId,
                }),
              ]
            );
          });
        });
      }),
      (B.prototype.keepAlive = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          return __generator(this, function (U) {
            return [
              2,
              this.request("/v1/streaming.keep_alive", {
                session_id: this.sessionId,
              }),
            ];
          });
        });
      }),
      (B.prototype.on = function (U, F) {
        return this.eventTarget.addEventListener(U, F), this;
      }),
      (B.prototype.off = function (U, F) {
        return this.eventTarget.removeEventListener(U, F), this;
      }),
      (B.prototype.sendLivekitMessage = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F;
          return __generator(this, function (q) {
            return this.room
              ? ((F = new TextEncoder().encode(JSON.stringify(U))),
                this.room.localParticipant.publishData(F, { reliable: !0 }),
                [2])
              : [2];
          });
        });
      }),
      (B.prototype.sendWebsocketMessage = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F, q, j, V;
          return __generator(this, function ($) {
            return !this.webSocket || !this.audioRawFrame
              ? [2]
              : ((F =
                  (j = this.audioRawFrame) === null || j === void 0
                    ? void 0
                    : j.create({ text: { text: U } })),
                (q = new Uint8Array(
                  (V = this.audioRawFrame) === null || V === void 0
                    ? void 0
                    : V.encode(F).finish()
                )),
                this.webSocket.send(q),
                [2]);
          });
        });
      }),
      (B.prototype.initVoiceChat = function (U) {
        if (U === VoiceChatTransport.WEBSOCKET) {
          if (
            (this.loadAudioRawFrame(), !this.audioRawFrame || !this.webSocket)
          )
            return;
          this.voiceChat = VoiceChatFactory.createWebSocketVoiceChat({
            webSocket: this.webSocket,
            audioRawFrame: this.audioRawFrame,
          });
        } else {
          if (!this.room) return;
          this.voiceChat = VoiceChatFactory.createLiveKitVoiceChat({
            room: this.room,
          });
        }
      }),
      (B.prototype.request = function (U, F, q) {
        return __awaiter$a(this, void 0, void 0, function () {
          var j, V, $, W;
          return __generator(this, function (K) {
            switch (K.label) {
              case 0:
                return (
                  K.trys.push([0, 5, , 6]),
                  [
                    4,
                    fetch(this.getRequestUrl(U), {
                      method: "POST",
                      headers: {
                        Authorization: "Bearer ".concat(this.token),
                        "Content-Type": "application/json",
                      },
                      body: JSON.stringify(F),
                    }),
                  ]
                );
              case 1:
                return (j = K.sent()), j.ok ? [3, 3] : [4, j.text()];
              case 2:
                throw (
                  ((V = K.sent()),
                  new APIError(
                    "API request failed with status ".concat(j.status),
                    j.status,
                    V
                  ))
                );
              case 3:
                return [4, j.json()];
              case 4:
                return ($ = K.sent()), [2, $.data];
              case 5:
                throw ((W = K.sent()), W);
              case 6:
                return [2];
            }
          });
        });
      }),
      (B.prototype.emit = function (U, F) {
        var q = new CustomEvent(U, { detail: F });
        this.eventTarget.dispatchEvent(q);
      }),
      (B.prototype.getRequestUrl = function (U) {
        return "".concat(this.basePath).concat(U);
      }),
      (B.prototype.connectWebSocket = function (U) {
        return __awaiter$a(this, void 0, void 0, function () {
          var F,
            q = this;
          return __generator(this, function (j) {
            return (
              (F = "wss://"
                .concat(
                  new URL(this.basePath).hostname,
                  "/v1/ws/streaming.chat?session_id="
                )
                .concat(this.sessionId, "&session_token=")
                .concat(this.token)
                .concat(
                  this.isLiveKitTransport ? "&arch_version=v2" : "",
                  "&silence_response="
                )
                .concat(U.useSilencePrompt)),
              (this.webSocket = new WebSocket(F)),
              this.webSocket.addEventListener("message", function (V) {
                var $ = null;
                try {
                  $ = JSON.parse(V.data);
                } catch (W) {
                  console.error(W);
                  return;
                }
                $ && q.emit($.event_type, $);
              }),
              this.webSocket.addEventListener("close", function (V) {
                q.webSocket = null;
              }),
              [
                2,
                new Promise(function (V, $) {
                  var W, K;
                  (W = q.webSocket) === null ||
                    W === void 0 ||
                    W.addEventListener("error", function (G) {
                      (q.webSocket = null), $(G);
                    }),
                    (K = q.webSocket) === null ||
                      K === void 0 ||
                      K.addEventListener("open", function () {
                        V(!0);
                      });
                }),
              ]
            );
          });
        });
      }),
      (B.prototype.loadAudioRawFrame = function () {
        return __awaiter$a(this, void 0, void 0, function () {
          var U;
          return __generator(this, function (F) {
            return (
              this.audioRawFrame ||
                ((U = protobuf.Root.fromJSON(jsonDescriptor)),
                (this.audioRawFrame =
                  U == null ? void 0 : U.lookupType("pipecat.Frame"))),
              [2]
            );
          });
        });
      }),
      B
    );
  })();
class DeepgramError extends Error {
  constructor(U) {
    super(U), (this.__dgError = !0), (this.name = "DeepgramError");
  }
}
function isDeepgramError(B) {
  return typeof B == "object" && B !== null && "__dgError" in B;
}
class DeepgramApiError extends DeepgramError {
  constructor(U, F) {
    super(U), (this.name = "DeepgramApiError"), (this.status = F);
  }
  toJSON() {
    return { name: this.name, message: this.message, status: this.status };
  }
}
class DeepgramUnknownError extends DeepgramError {
  constructor(U, F) {
    super(U), (this.name = "DeepgramUnknownError"), (this.originalError = F);
  }
}
class DeepgramVersionError extends DeepgramError {
  constructor() {
    super(
      "You are attempting to use an old format for a newer SDK version. Read more here: https://dpgr.am/js-v3"
    ),
      (this.name = "DeepgramVersionError");
  }
}
class DeepgramWebSocketError extends DeepgramError {
  constructor(U, F = {}) {
    super(U),
      (this.name = "DeepgramWebSocketError"),
      (this.originalEvent = F.originalEvent),
      (this.statusCode = F.statusCode),
      (this.requestId = F.requestId),
      (this.responseHeaders = F.responseHeaders),
      (this.url = F.url),
      (this.readyState = F.readyState);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      statusCode: this.statusCode,
      requestId: this.requestId,
      responseHeaders: this.responseHeaders,
      url: this.url,
      readyState: this.readyState,
      originalEvent: this.originalEvent
        ? {
            type: this.originalEvent.type,
            timeStamp: this.originalEvent.timeStamp,
          }
        : void 0,
    };
  }
}
var events = { exports: {} },
  hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B = typeof Reflect == "object" ? Reflect : null,
    U =
      B && typeof B.apply == "function"
        ? B.apply
        : function (ne, oe, ce) {
            return Function.prototype.apply.call(ne, oe, ce);
          },
    F;
  B && typeof B.ownKeys == "function"
    ? (F = B.ownKeys)
    : Object.getOwnPropertySymbols
    ? (F = function (ne) {
        return Object.getOwnPropertyNames(ne).concat(
          Object.getOwnPropertySymbols(ne)
        );
      })
    : (F = function (ne) {
        return Object.getOwnPropertyNames(ne);
      });
  function q(te) {
    console && console.warn && console.warn(te);
  }
  var j =
    Number.isNaN ||
    function (ne) {
      return ne !== ne;
    };
  function V() {
    V.init.call(this);
  }
  (events.exports = V),
    (events.exports.once = ee),
    (V.EventEmitter = V),
    (V.prototype._events = void 0),
    (V.prototype._eventsCount = 0),
    (V.prototype._maxListeners = void 0);
  var $ = 10;
  function W(te) {
    if (typeof te != "function")
      throw new TypeError(
        'The "listener" argument must be of type Function. Received type ' +
          typeof te
      );
  }
  Object.defineProperty(V, "defaultMaxListeners", {
    enumerable: !0,
    get: function () {
      return $;
    },
    set: function (te) {
      if (typeof te != "number" || te < 0 || j(te))
        throw new RangeError(
          'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
            te +
            "."
        );
      $ = te;
    },
  }),
    (V.init = function () {
      (this._events === void 0 ||
        this._events === Object.getPrototypeOf(this)._events) &&
        ((this._events = Object.create(null)), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0);
    }),
    (V.prototype.setMaxListeners = function (ne) {
      if (typeof ne != "number" || ne < 0 || j(ne))
        throw new RangeError(
          'The value of "n" is out of range. It must be a non-negative number. Received ' +
            ne +
            "."
        );
      return (this._maxListeners = ne), this;
    });
  function K(te) {
    return te._maxListeners === void 0
      ? V.defaultMaxListeners
      : te._maxListeners;
  }
  (V.prototype.getMaxListeners = function () {
    return K(this);
  }),
    (V.prototype.emit = function (ne) {
      for (var oe = [], ce = 1; ce < arguments.length; ce++)
        oe.push(arguments[ce]);
      var le = ne === "error",
        he = this._events;
      if (he !== void 0) le = le && he.error === void 0;
      else if (!le) return !1;
      if (le) {
        var de;
        if ((oe.length > 0 && (de = oe[0]), de instanceof Error)) throw de;
        var pe = new Error(
          "Unhandled error." + (de ? " (" + de.message + ")" : "")
        );
        throw ((pe.context = de), pe);
      }
      var Te = he[ne];
      if (Te === void 0) return !1;
      if (typeof Te == "function") U(Te, this, oe);
      else
        for (var Pe = Te.length, ye = X(Te, Pe), ce = 0; ce < Pe; ++ce)
          U(ye[ce], this, oe);
      return !0;
    });
  function G(te, ne, oe, ce) {
    var le, he, de;
    if (
      (W(oe),
      (he = te._events),
      he === void 0
        ? ((he = te._events = Object.create(null)), (te._eventsCount = 0))
        : (he.newListener !== void 0 &&
            (te.emit("newListener", ne, oe.listener ? oe.listener : oe),
            (he = te._events)),
          (de = he[ne])),
      de === void 0)
    )
      (de = he[ne] = oe), ++te._eventsCount;
    else if (
      (typeof de == "function"
        ? (de = he[ne] = ce ? [oe, de] : [de, oe])
        : ce
        ? de.unshift(oe)
        : de.push(oe),
      (le = K(te)),
      le > 0 && de.length > le && !de.warned)
    ) {
      de.warned = !0;
      var pe = new Error(
        "Possible EventEmitter memory leak detected. " +
          de.length +
          " " +
          String(ne) +
          " listeners added. Use emitter.setMaxListeners() to increase limit"
      );
      (pe.name = "MaxListenersExceededWarning"),
        (pe.emitter = te),
        (pe.type = ne),
        (pe.count = de.length),
        q(pe);
    }
    return te;
  }
  (V.prototype.addListener = function (ne, oe) {
    return G(this, ne, oe, !1);
  }),
    (V.prototype.on = V.prototype.addListener),
    (V.prototype.prependListener = function (ne, oe) {
      return G(this, ne, oe, !0);
    });
  function H() {
    if (!this.fired)
      return (
        this.target.removeListener(this.type, this.wrapFn),
        (this.fired = !0),
        arguments.length === 0
          ? this.listener.call(this.target)
          : this.listener.apply(this.target, arguments)
      );
  }
  function Q(te, ne, oe) {
    var ce = { fired: !1, wrapFn: void 0, target: te, type: ne, listener: oe },
      le = H.bind(ce);
    return (le.listener = oe), (ce.wrapFn = le), le;
  }
  (V.prototype.once = function (ne, oe) {
    return W(oe), this.on(ne, Q(this, ne, oe)), this;
  }),
    (V.prototype.prependOnceListener = function (ne, oe) {
      return W(oe), this.prependListener(ne, Q(this, ne, oe)), this;
    }),
    (V.prototype.removeListener = function (ne, oe) {
      var ce, le, he, de, pe;
      if ((W(oe), (le = this._events), le === void 0)) return this;
      if (((ce = le[ne]), ce === void 0)) return this;
      if (ce === oe || ce.listener === oe)
        --this._eventsCount === 0
          ? (this._events = Object.create(null))
          : (delete le[ne],
            le.removeListener &&
              this.emit("removeListener", ne, ce.listener || oe));
      else if (typeof ce != "function") {
        for (he = -1, de = ce.length - 1; de >= 0; de--)
          if (ce[de] === oe || ce[de].listener === oe) {
            (pe = ce[de].listener), (he = de);
            break;
          }
        if (he < 0) return this;
        he === 0 ? ce.shift() : Z(ce, he),
          ce.length === 1 && (le[ne] = ce[0]),
          le.removeListener !== void 0 &&
            this.emit("removeListener", ne, pe || oe);
      }
      return this;
    }),
    (V.prototype.off = V.prototype.removeListener),
    (V.prototype.removeAllListeners = function (ne) {
      var oe, ce, le;
      if (((ce = this._events), ce === void 0)) return this;
      if (ce.removeListener === void 0)
        return (
          arguments.length === 0
            ? ((this._events = Object.create(null)), (this._eventsCount = 0))
            : ce[ne] !== void 0 &&
              (--this._eventsCount === 0
                ? (this._events = Object.create(null))
                : delete ce[ne]),
          this
        );
      if (arguments.length === 0) {
        var he = Object.keys(ce),
          de;
        for (le = 0; le < he.length; ++le)
          (de = he[le]), de !== "removeListener" && this.removeAllListeners(de);
        return (
          this.removeAllListeners("removeListener"),
          (this._events = Object.create(null)),
          (this._eventsCount = 0),
          this
        );
      }
      if (((oe = ce[ne]), typeof oe == "function")) this.removeListener(ne, oe);
      else if (oe !== void 0)
        for (le = oe.length - 1; le >= 0; le--) this.removeListener(ne, oe[le]);
      return this;
    });
  function z(te, ne, oe) {
    var ce = te._events;
    if (ce === void 0) return [];
    var le = ce[ne];
    return le === void 0
      ? []
      : typeof le == "function"
      ? oe
        ? [le.listener || le]
        : [le]
      : oe
      ? se(le)
      : X(le, le.length);
  }
  (V.prototype.listeners = function (ne) {
    return z(this, ne, !0);
  }),
    (V.prototype.rawListeners = function (ne) {
      return z(this, ne, !1);
    }),
    (V.listenerCount = function (te, ne) {
      return typeof te.listenerCount == "function"
        ? te.listenerCount(ne)
        : Y.call(te, ne);
    }),
    (V.prototype.listenerCount = Y);
  function Y(te) {
    var ne = this._events;
    if (ne !== void 0) {
      var oe = ne[te];
      if (typeof oe == "function") return 1;
      if (oe !== void 0) return oe.length;
    }
    return 0;
  }
  V.prototype.eventNames = function () {
    return this._eventsCount > 0 ? F(this._events) : [];
  };
  function X(te, ne) {
    for (var oe = new Array(ne), ce = 0; ce < ne; ++ce) oe[ce] = te[ce];
    return oe;
  }
  function Z(te, ne) {
    for (; ne + 1 < te.length; ne++) te[ne] = te[ne + 1];
    te.pop();
  }
  function se(te) {
    for (var ne = new Array(te.length), oe = 0; oe < ne.length; ++oe)
      ne[oe] = te[oe].listener || te[oe];
    return ne;
  }
  function ee(te, ne) {
    return new Promise(function (oe, ce) {
      function le(de) {
        te.removeListener(ne, he), ce(de);
      }
      function he() {
        typeof te.removeListener == "function" &&
          te.removeListener("error", le),
          oe([].slice.call(arguments));
      }
      re(te, ne, he, { once: !0 }), ne !== "error" && ie(te, le, { once: !0 });
    });
  }
  function ie(te, ne, oe) {
    typeof te.on == "function" && re(te, "error", ne, oe);
  }
  function re(te, ne, oe, ce) {
    if (typeof te.on == "function") ce.once ? te.once(ne, oe) : te.on(ne, oe);
    else if (typeof te.addEventListener == "function")
      te.addEventListener(ne, function le(he) {
        ce.once && te.removeEventListener(ne, le), oe(he);
      });
    else
      throw new TypeError(
        'The "emitter" argument must be of type EventEmitter. Received type ' +
          typeof te
      );
  }
  return events.exports;
}
var eventsExports = requireEvents(),
  browserPonyfill$1 = { exports: {} },
  hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
  return (
    hasRequiredBrowserPonyfill ||
      ((hasRequiredBrowserPonyfill = 1),
      (function (B, U) {
        var F =
            (typeof globalThis < "u" && globalThis) ||
            (typeof self < "u" && self) ||
            (typeof commonjsGlobal < "u" && commonjsGlobal),
          q = (function () {
            function V() {
              (this.fetch = !1), (this.DOMException = F.DOMException);
            }
            return (V.prototype = F), new V();
          })();
        (function (V) {
          (function ($) {
            var W =
                (typeof V < "u" && V) ||
                (typeof self < "u" && self) ||
                (typeof commonjsGlobal < "u" && commonjsGlobal) ||
                {},
              K = {
                searchParams: "URLSearchParams" in W,
                iterable: "Symbol" in W && "iterator" in Symbol,
                blob:
                  "FileReader" in W &&
                  "Blob" in W &&
                  (function () {
                    try {
                      return new Blob(), !0;
                    } catch {
                      return !1;
                    }
                  })(),
                formData: "FormData" in W,
                arrayBuffer: "ArrayBuffer" in W,
              };
            function G(ae) {
              return ae && DataView.prototype.isPrototypeOf(ae);
            }
            if (K.arrayBuffer)
              var H = [
                  "[object Int8Array]",
                  "[object Uint8Array]",
                  "[object Uint8ClampedArray]",
                  "[object Int16Array]",
                  "[object Uint16Array]",
                  "[object Int32Array]",
                  "[object Uint32Array]",
                  "[object Float32Array]",
                  "[object Float64Array]",
                ],
                Q =
                  ArrayBuffer.isView ||
                  function (ae) {
                    return (
                      ae && H.indexOf(Object.prototype.toString.call(ae)) > -1
                    );
                  };
            function z(ae) {
              if (
                (typeof ae != "string" && (ae = String(ae)),
                /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(ae) || ae === "")
              )
                throw new TypeError(
                  'Invalid character in header field name: "' + ae + '"'
                );
              return ae.toLowerCase();
            }
            function Y(ae) {
              return typeof ae != "string" && (ae = String(ae)), ae;
            }
            function X(ae) {
              var ue = {
                next: function () {
                  var ve = ae.shift();
                  return { done: ve === void 0, value: ve };
                },
              };
              return (
                K.iterable &&
                  (ue[Symbol.iterator] = function () {
                    return ue;
                  }),
                ue
              );
            }
            function Z(ae) {
              (this.map = {}),
                ae instanceof Z
                  ? ae.forEach(function (ue, ve) {
                      this.append(ve, ue);
                    }, this)
                  : Array.isArray(ae)
                  ? ae.forEach(function (ue) {
                      if (ue.length != 2)
                        throw new TypeError(
                          "Headers constructor: expected name/value pair to be length 2, found" +
                            ue.length
                        );
                      this.append(ue[0], ue[1]);
                    }, this)
                  : ae &&
                    Object.getOwnPropertyNames(ae).forEach(function (ue) {
                      this.append(ue, ae[ue]);
                    }, this);
            }
            (Z.prototype.append = function (ae, ue) {
              (ae = z(ae)), (ue = Y(ue));
              var ve = this.map[ae];
              this.map[ae] = ve ? ve + ", " + ue : ue;
            }),
              (Z.prototype.delete = function (ae) {
                delete this.map[z(ae)];
              }),
              (Z.prototype.get = function (ae) {
                return (ae = z(ae)), this.has(ae) ? this.map[ae] : null;
              }),
              (Z.prototype.has = function (ae) {
                return this.map.hasOwnProperty(z(ae));
              }),
              (Z.prototype.set = function (ae, ue) {
                this.map[z(ae)] = Y(ue);
              }),
              (Z.prototype.forEach = function (ae, ue) {
                for (var ve in this.map)
                  this.map.hasOwnProperty(ve) &&
                    ae.call(ue, this.map[ve], ve, this);
              }),
              (Z.prototype.keys = function () {
                var ae = [];
                return (
                  this.forEach(function (ue, ve) {
                    ae.push(ve);
                  }),
                  X(ae)
                );
              }),
              (Z.prototype.values = function () {
                var ae = [];
                return (
                  this.forEach(function (ue) {
                    ae.push(ue);
                  }),
                  X(ae)
                );
              }),
              (Z.prototype.entries = function () {
                var ae = [];
                return (
                  this.forEach(function (ue, ve) {
                    ae.push([ve, ue]);
                  }),
                  X(ae)
                );
              }),
              K.iterable &&
                (Z.prototype[Symbol.iterator] = Z.prototype.entries);
            function se(ae) {
              if (!ae._noBody) {
                if (ae.bodyUsed)
                  return Promise.reject(new TypeError("Already read"));
                ae.bodyUsed = !0;
              }
            }
            function ee(ae) {
              return new Promise(function (ue, ve) {
                (ae.onload = function () {
                  ue(ae.result);
                }),
                  (ae.onerror = function () {
                    ve(ae.error);
                  });
              });
            }
            function ie(ae) {
              var ue = new FileReader(),
                ve = ee(ue);
              return ue.readAsArrayBuffer(ae), ve;
            }
            function re(ae) {
              var ue = new FileReader(),
                ve = ee(ue),
                Ce = /charset=([A-Za-z0-9_-]+)/.exec(ae.type),
                we = Ce ? Ce[1] : "utf-8";
              return ue.readAsText(ae, we), ve;
            }
            function te(ae) {
              for (
                var ue = new Uint8Array(ae), ve = new Array(ue.length), Ce = 0;
                Ce < ue.length;
                Ce++
              )
                ve[Ce] = String.fromCharCode(ue[Ce]);
              return ve.join("");
            }
            function ne(ae) {
              if (ae.slice) return ae.slice(0);
              var ue = new Uint8Array(ae.byteLength);
              return ue.set(new Uint8Array(ae)), ue.buffer;
            }
            function oe() {
              return (
                (this.bodyUsed = !1),
                (this._initBody = function (ae) {
                  (this.bodyUsed = this.bodyUsed),
                    (this._bodyInit = ae),
                    ae
                      ? typeof ae == "string"
                        ? (this._bodyText = ae)
                        : K.blob && Blob.prototype.isPrototypeOf(ae)
                        ? (this._bodyBlob = ae)
                        : K.formData && FormData.prototype.isPrototypeOf(ae)
                        ? (this._bodyFormData = ae)
                        : K.searchParams &&
                          URLSearchParams.prototype.isPrototypeOf(ae)
                        ? (this._bodyText = ae.toString())
                        : K.arrayBuffer && K.blob && G(ae)
                        ? ((this._bodyArrayBuffer = ne(ae.buffer)),
                          (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                        : K.arrayBuffer &&
                          (ArrayBuffer.prototype.isPrototypeOf(ae) || Q(ae))
                        ? (this._bodyArrayBuffer = ne(ae))
                        : (this._bodyText = ae =
                            Object.prototype.toString.call(ae))
                      : ((this._noBody = !0), (this._bodyText = "")),
                    this.headers.get("content-type") ||
                      (typeof ae == "string"
                        ? this.headers.set(
                            "content-type",
                            "text/plain;charset=UTF-8"
                          )
                        : this._bodyBlob && this._bodyBlob.type
                        ? this.headers.set("content-type", this._bodyBlob.type)
                        : K.searchParams &&
                          URLSearchParams.prototype.isPrototypeOf(ae) &&
                          this.headers.set(
                            "content-type",
                            "application/x-www-form-urlencoded;charset=UTF-8"
                          ));
                }),
                K.blob &&
                  (this.blob = function () {
                    var ae = se(this);
                    if (ae) return ae;
                    if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                      return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                      throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]));
                  }),
                (this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var ae = se(this);
                    return (
                      ae ||
                      (ArrayBuffer.isView(this._bodyArrayBuffer)
                        ? Promise.resolve(
                            this._bodyArrayBuffer.buffer.slice(
                              this._bodyArrayBuffer.byteOffset,
                              this._bodyArrayBuffer.byteOffset +
                                this._bodyArrayBuffer.byteLength
                            )
                          )
                        : Promise.resolve(this._bodyArrayBuffer))
                    );
                  } else {
                    if (K.blob) return this.blob().then(ie);
                    throw new Error("could not read as ArrayBuffer");
                  }
                }),
                (this.text = function () {
                  var ae = se(this);
                  if (ae) return ae;
                  if (this._bodyBlob) return re(this._bodyBlob);
                  if (this._bodyArrayBuffer)
                    return Promise.resolve(te(this._bodyArrayBuffer));
                  if (this._bodyFormData)
                    throw new Error("could not read FormData body as text");
                  return Promise.resolve(this._bodyText);
                }),
                K.formData &&
                  (this.formData = function () {
                    return this.text().then(de);
                  }),
                (this.json = function () {
                  return this.text().then(JSON.parse);
                }),
                this
              );
            }
            var ce = [
              "CONNECT",
              "DELETE",
              "GET",
              "HEAD",
              "OPTIONS",
              "PATCH",
              "POST",
              "PUT",
              "TRACE",
            ];
            function le(ae) {
              var ue = ae.toUpperCase();
              return ce.indexOf(ue) > -1 ? ue : ae;
            }
            function he(ae, ue) {
              if (!(this instanceof he))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                );
              ue = ue || {};
              var ve = ue.body;
              if (ae instanceof he) {
                if (ae.bodyUsed) throw new TypeError("Already read");
                (this.url = ae.url),
                  (this.credentials = ae.credentials),
                  ue.headers || (this.headers = new Z(ae.headers)),
                  (this.method = ae.method),
                  (this.mode = ae.mode),
                  (this.signal = ae.signal),
                  !ve &&
                    ae._bodyInit != null &&
                    ((ve = ae._bodyInit), (ae.bodyUsed = !0));
              } else this.url = String(ae);
              if (
                ((this.credentials =
                  ue.credentials || this.credentials || "same-origin"),
                (ue.headers || !this.headers) &&
                  (this.headers = new Z(ue.headers)),
                (this.method = le(ue.method || this.method || "GET")),
                (this.mode = ue.mode || this.mode || null),
                (this.signal =
                  ue.signal ||
                  this.signal ||
                  (function () {
                    if ("AbortController" in W) {
                      var be = new AbortController();
                      return be.signal;
                    }
                  })()),
                (this.referrer = null),
                (this.method === "GET" || this.method === "HEAD") && ve)
              )
                throw new TypeError(
                  "Body not allowed for GET or HEAD requests"
                );
              if (
                (this._initBody(ve),
                (this.method === "GET" || this.method === "HEAD") &&
                  (ue.cache === "no-store" || ue.cache === "no-cache"))
              ) {
                var Ce = /([?&])_=[^&]*/;
                if (Ce.test(this.url))
                  this.url = this.url.replace(
                    Ce,
                    "$1_=" + new Date().getTime()
                  );
                else {
                  var we = /\?/;
                  this.url +=
                    (we.test(this.url) ? "&" : "?") +
                    "_=" +
                    new Date().getTime();
                }
              }
            }
            he.prototype.clone = function () {
              return new he(this, { body: this._bodyInit });
            };
            function de(ae) {
              var ue = new FormData();
              return (
                ae
                  .trim()
                  .split("&")
                  .forEach(function (ve) {
                    if (ve) {
                      var Ce = ve.split("="),
                        we = Ce.shift().replace(/\+/g, " "),
                        be = Ce.join("=").replace(/\+/g, " ");
                      ue.append(decodeURIComponent(we), decodeURIComponent(be));
                    }
                  }),
                ue
              );
            }
            function pe(ae) {
              var ue = new Z(),
                ve = ae.replace(/\r?\n[\t ]+/g, " ");
              return (
                ve
                  .split("\r")
                  .map(function (Ce) {
                    return Ce.indexOf(`
`) === 0
                      ? Ce.substr(1, Ce.length)
                      : Ce;
                  })
                  .forEach(function (Ce) {
                    var we = Ce.split(":"),
                      be = we.shift().trim();
                    if (be) {
                      var Ie = we.join(":").trim();
                      try {
                        ue.append(be, Ie);
                      } catch (Ne) {
                        console.warn("Response " + Ne.message);
                      }
                    }
                  }),
                ue
              );
            }
            oe.call(he.prototype);
            function Te(ae, ue) {
              if (!(this instanceof Te))
                throw new TypeError(
                  'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
                );
              if (
                (ue || (ue = {}),
                (this.type = "default"),
                (this.status = ue.status === void 0 ? 200 : ue.status),
                this.status < 200 || this.status > 599)
              )
                throw new RangeError(
                  "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
                );
              (this.ok = this.status >= 200 && this.status < 300),
                (this.statusText =
                  ue.statusText === void 0 ? "" : "" + ue.statusText),
                (this.headers = new Z(ue.headers)),
                (this.url = ue.url || ""),
                this._initBody(ae);
            }
            oe.call(Te.prototype),
              (Te.prototype.clone = function () {
                return new Te(this._bodyInit, {
                  status: this.status,
                  statusText: this.statusText,
                  headers: new Z(this.headers),
                  url: this.url,
                });
              }),
              (Te.error = function () {
                var ae = new Te(null, { status: 200, statusText: "" });
                return (ae.ok = !1), (ae.status = 0), (ae.type = "error"), ae;
              });
            var Pe = [301, 302, 303, 307, 308];
            (Te.redirect = function (ae, ue) {
              if (Pe.indexOf(ue) === -1)
                throw new RangeError("Invalid status code");
              return new Te(null, { status: ue, headers: { location: ae } });
            }),
              ($.DOMException = W.DOMException);
            try {
              new $.DOMException();
            } catch {
              ($.DOMException = function (ue, ve) {
                (this.message = ue), (this.name = ve);
                var Ce = Error(ue);
                this.stack = Ce.stack;
              }),
                ($.DOMException.prototype = Object.create(Error.prototype)),
                ($.DOMException.prototype.constructor = $.DOMException);
            }
            function ye(ae, ue) {
              return new Promise(function (ve, Ce) {
                var we = new he(ae, ue);
                if (we.signal && we.signal.aborted)
                  return Ce(new $.DOMException("Aborted", "AbortError"));
                var be = new XMLHttpRequest();
                function Ie() {
                  be.abort();
                }
                (be.onload = function () {
                  var Le = {
                    statusText: be.statusText,
                    headers: pe(be.getAllResponseHeaders() || ""),
                  };
                  we.url.indexOf("file://") === 0 &&
                  (be.status < 200 || be.status > 599)
                    ? (Le.status = 200)
                    : (Le.status = be.status),
                    (Le.url =
                      "responseURL" in be
                        ? be.responseURL
                        : Le.headers.get("X-Request-URL"));
                  var We = "response" in be ? be.response : be.responseText;
                  setTimeout(function () {
                    ve(new Te(We, Le));
                  }, 0);
                }),
                  (be.onerror = function () {
                    setTimeout(function () {
                      Ce(new TypeError("Network request failed"));
                    }, 0);
                  }),
                  (be.ontimeout = function () {
                    setTimeout(function () {
                      Ce(new TypeError("Network request timed out"));
                    }, 0);
                  }),
                  (be.onabort = function () {
                    setTimeout(function () {
                      Ce(new $.DOMException("Aborted", "AbortError"));
                    }, 0);
                  });
                function Ne(Le) {
                  try {
                    return Le === "" && W.location.href ? W.location.href : Le;
                  } catch {
                    return Le;
                  }
                }
                if (
                  (be.open(we.method, Ne(we.url), !0),
                  we.credentials === "include"
                    ? (be.withCredentials = !0)
                    : we.credentials === "omit" && (be.withCredentials = !1),
                  "responseType" in be &&
                    (K.blob
                      ? (be.responseType = "blob")
                      : K.arrayBuffer && (be.responseType = "arraybuffer")),
                  ue &&
                    typeof ue.headers == "object" &&
                    !(
                      ue.headers instanceof Z ||
                      (W.Headers && ue.headers instanceof W.Headers)
                    ))
                ) {
                  var Ue = [];
                  Object.getOwnPropertyNames(ue.headers).forEach(function (Le) {
                    Ue.push(z(Le)), be.setRequestHeader(Le, Y(ue.headers[Le]));
                  }),
                    we.headers.forEach(function (Le, We) {
                      Ue.indexOf(We) === -1 && be.setRequestHeader(We, Le);
                    });
                } else
                  we.headers.forEach(function (Le, We) {
                    be.setRequestHeader(We, Le);
                  });
                we.signal &&
                  (we.signal.addEventListener("abort", Ie),
                  (be.onreadystatechange = function () {
                    be.readyState === 4 &&
                      we.signal.removeEventListener("abort", Ie);
                  })),
                  be.send(typeof we._bodyInit > "u" ? null : we._bodyInit);
              });
            }
            return (
              (ye.polyfill = !0),
              W.fetch ||
                ((W.fetch = ye),
                (W.Headers = Z),
                (W.Request = he),
                (W.Response = Te)),
              ($.Headers = Z),
              ($.Request = he),
              ($.Response = Te),
              ($.fetch = ye),
              Object.defineProperty($, "__esModule", { value: !0 }),
              $
            );
          })({});
        })(q),
          (q.fetch.ponyfill = !0),
          delete q.fetch.polyfill;
        var j = F.fetch ? F : q;
        (U = j.fetch),
          (U.default = j.fetch),
          (U.fetch = j.fetch),
          (U.Headers = j.Headers),
          (U.Request = j.Request),
          (U.Response = j.Response),
          (B.exports = U);
      })(browserPonyfill$1, browserPonyfill$1.exports)),
    browserPonyfill$1.exports
  );
}
var browserPonyfillExports = requireBrowserPonyfill();
const crossFetch = getDefaultExportFromCjs(browserPonyfillExports),
  browserPonyfill = _mergeNamespaces({ __proto__: null, default: crossFetch }, [
    browserPonyfillExports,
  ]);
var cjs, hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var B = function (ie) {
    return U(ie) && !F(ie);
  };
  function U(ee) {
    return !!ee && typeof ee == "object";
  }
  function F(ee) {
    var ie = Object.prototype.toString.call(ee);
    return ie === "[object RegExp]" || ie === "[object Date]" || V(ee);
  }
  var q = typeof Symbol == "function" && Symbol.for,
    j = q ? Symbol.for("react.element") : 60103;
  function V(ee) {
    return ee.$$typeof === j;
  }
  function $(ee) {
    return Array.isArray(ee) ? [] : {};
  }
  function W(ee, ie) {
    return ie.clone !== !1 && ie.isMergeableObject(ee) ? Z($(ee), ee, ie) : ee;
  }
  function K(ee, ie, re) {
    return ee.concat(ie).map(function (te) {
      return W(te, re);
    });
  }
  function G(ee, ie) {
    if (!ie.customMerge) return Z;
    var re = ie.customMerge(ee);
    return typeof re == "function" ? re : Z;
  }
  function H(ee) {
    return Object.getOwnPropertySymbols
      ? Object.getOwnPropertySymbols(ee).filter(function (ie) {
          return Object.propertyIsEnumerable.call(ee, ie);
        })
      : [];
  }
  function Q(ee) {
    return Object.keys(ee).concat(H(ee));
  }
  function z(ee, ie) {
    try {
      return ie in ee;
    } catch {
      return !1;
    }
  }
  function Y(ee, ie) {
    return (
      z(ee, ie) &&
      !(
        Object.hasOwnProperty.call(ee, ie) &&
        Object.propertyIsEnumerable.call(ee, ie)
      )
    );
  }
  function X(ee, ie, re) {
    var te = {};
    return (
      re.isMergeableObject(ee) &&
        Q(ee).forEach(function (ne) {
          te[ne] = W(ee[ne], re);
        }),
      Q(ie).forEach(function (ne) {
        Y(ee, ne) ||
          (z(ee, ne) && re.isMergeableObject(ie[ne])
            ? (te[ne] = G(ne, re)(ee[ne], ie[ne], re))
            : (te[ne] = W(ie[ne], re)));
      }),
      te
    );
  }
  function Z(ee, ie, re) {
    (re = re || {}),
      (re.arrayMerge = re.arrayMerge || K),
      (re.isMergeableObject = re.isMergeableObject || B),
      (re.cloneUnlessOtherwiseSpecified = W);
    var te = Array.isArray(ie),
      ne = Array.isArray(ee),
      oe = te === ne;
    return oe ? (te ? re.arrayMerge(ee, ie, re) : X(ee, ie, re)) : W(ie, re);
  }
  Z.all = function (ie, re) {
    if (!Array.isArray(ie))
      throw new Error("first argument should be an array");
    return ie.reduce(function (te, ne) {
      return Z(te, ne, re);
    }, {});
  };
  var se = Z;
  return (cjs = se), cjs;
}
var cjsExports = requireCjs();
const merge = getDefaultExportFromCjs(cjsExports),
  NODE_VERSION =
    typeof process < "u" && process.versions && process.versions.node
      ? process.versions.node
      : "unknown",
  BUN_VERSION =
    typeof process < "u" && process.versions && process.versions.bun
      ? process.versions.bun
      : "unknown",
  BROWSER_AGENT =
    typeof window < "u" && window.navigator && window.navigator.userAgent
      ? window.navigator.userAgent
      : "unknown",
  isBrowser = () => BROWSER_AGENT !== "unknown",
  isNode = () => NODE_VERSION !== "unknown",
  isBun = () => BUN_VERSION !== "unknown";
function applyDefaults(B = {}, U = {}) {
  return merge(U, B);
}
function appendSearchParams(B, U) {
  Object.keys(U).forEach((F) => {
    Array.isArray(U[F])
      ? U[F].forEach((j) => {
          B.append(F, String(j));
        })
      : B.append(F, String(U[F]));
  });
}
const resolveHeadersConstructor = () =>
    typeof Headers > "u" ? browserPonyfillExports.Headers : Headers,
  isUrlSource = (B) => !!(B && B.url),
  isTextSource = (B) => !!(B && B.text),
  isFileSource = (B) => !!(isReadStreamSource(B) || isBufferSource(B)),
  isBufferSource = (B) => B != null && Buffer.isBuffer(B),
  isReadStreamSource = (B) =>
    B == null || isBrowser()
      ? !1
      : typeof B == "object" &&
        typeof B.pipe == "function" &&
        typeof B.read == "function" &&
        typeof B._readableState == "object",
  convertProtocolToWs = (B) =>
    ((F) => F.toLowerCase().replace(/^http/, "ws"))(B),
  convertLegacyOptions = (B) => {
    var U, F, q, j, V, $;
    const W = {};
    return (
      B._experimentalCustomFetch &&
        (W.global = { fetch: { client: B._experimentalCustomFetch } }),
      (B = merge(B, W)),
      !((U = B.restProxy) === null || U === void 0) &&
        U.url &&
        (W.global = {
          fetch: {
            options: {
              proxy: {
                url:
                  (F = B.restProxy) === null || F === void 0 ? void 0 : F.url,
              },
            },
          },
        }),
      (B = merge(B, W)),
      !((q = B.global) === null || q === void 0) &&
        q.url &&
        (W.global = {
          fetch: { options: { url: B.global.url } },
          websocket: { options: { url: B.global.url } },
        }),
      (B = merge(B, W)),
      !((j = B.global) === null || j === void 0) &&
        j.headers &&
        (W.global = {
          fetch: {
            options: {
              headers:
                (V = B.global) === null || V === void 0 ? void 0 : V.headers,
            },
          },
          websocket: {
            options: {
              _nodeOnlyHeaders:
                ($ = B.global) === null || $ === void 0 ? void 0 : $.headers,
            },
          },
        }),
      (B = merge(B, W)),
      B
    );
  },
  version = "4.11.3",
  getAgent = () =>
    isNode()
      ? `node/${NODE_VERSION}`
      : isBun()
      ? `bun/${BUN_VERSION}`
      : isBrowser()
      ? `javascript ${BROWSER_AGENT}`
      : "unknown",
  DEFAULT_HEADERS = {
    "Content-Type": "application/json",
    "X-Client-Info": `@deepgram/sdk; ${
      isBrowser() ? "browser" : "server"
    }; v${version}`,
    "User-Agent": `@deepgram/sdk/${version} ${getAgent()}`,
  },
  DEFAULT_URL = "https://api.deepgram.com",
  DEFAULT_AGENT_URL = "wss://agent.deepgram.com",
  DEFAULT_GLOBAL_OPTIONS = {
    fetch: { options: { url: DEFAULT_URL, headers: DEFAULT_HEADERS } },
    websocket: {
      options: {
        url: convertProtocolToWs(DEFAULT_URL),
        _nodeOnlyHeaders: DEFAULT_HEADERS,
      },
    },
  },
  DEFAULT_AGENT_OPTIONS = {
    fetch: { options: { url: DEFAULT_URL, headers: DEFAULT_HEADERS } },
    websocket: {
      options: { url: DEFAULT_AGENT_URL, _nodeOnlyHeaders: DEFAULT_HEADERS },
    },
  },
  DEFAULT_OPTIONS = {
    global: DEFAULT_GLOBAL_OPTIONS,
    agent: DEFAULT_AGENT_OPTIONS,
  };
var SOCKET_STATES;
(function (B) {
  (B[(B.connecting = 0)] = "connecting"),
    (B[(B.open = 1)] = "open"),
    (B[(B.closing = 2)] = "closing"),
    (B[(B.closed = 3)] = "closed");
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CONNECTION_STATE;
(function (B) {
  (B.Connecting = "connecting"),
    (B.Open = "open"),
    (B.Closing = "closing"),
    (B.Closed = "closed");
})(CONNECTION_STATE || (CONNECTION_STATE = {}));
var define_process_env_default = {};
const noop = () => {};
class AbstractClient extends eventsExports.EventEmitter {
  constructor(U) {
    if (
      (super(),
      (this.factory = void 0),
      (this.key = void 0),
      (this.accessToken = void 0),
      (this.namespace = "global"),
      (this.version = "v1"),
      (this.baseUrl = DEFAULT_URL),
      (this.logger = noop),
      typeof U.accessToken == "function"
        ? ((this.factory = U.accessToken), (this.accessToken = this.factory()))
        : (this.accessToken = U.accessToken),
      typeof U.key == "function"
        ? ((this.factory = U.key), (this.key = this.factory()))
        : (this.key = U.key),
      !this.key &&
        !this.accessToken &&
        ((this.accessToken = define_process_env_default.DEEPGRAM_ACCESS_TOKEN),
        this.accessToken ||
          (this.key = define_process_env_default.DEEPGRAM_API_KEY)),
      !this.key && !this.accessToken)
    )
      throw new DeepgramError(
        "A deepgram API key or access token is required."
      );
    (U = convertLegacyOptions(U)),
      (this.options = applyDefaults(U, DEFAULT_OPTIONS));
  }
  v(U = "v1") {
    return (this.version = U), this;
  }
  get namespaceOptions() {
    const U = applyDefaults(this.options[this.namespace], this.options.global);
    return Object.assign(Object.assign({}, U), { key: this.key });
  }
  getRequestUrl(U, F = { version: this.version }, q) {
    (F.version = this.version),
      (U = U.replace(/:(\w+)/g, function (V, $) {
        return F[$];
      }));
    const j = new URL(U, this.baseUrl);
    return q && appendSearchParams(j.searchParams, q), j;
  }
  log(U, F, q) {
    this.logger(U, F, q);
  }
}
const scriptRel = "modulepreload",
  assetsURL = function (B) {
    return "/" + B;
  },
  seen = {},
  __vitePreload = function B(U, F, q) {
    let j = Promise.resolve();
    if (F && F.length > 0) {
      let $ = function (G) {
        return Promise.all(
          G.map((H) =>
            Promise.resolve(H).then(
              (Q) => ({ status: "fulfilled", value: Q }),
              (Q) => ({ status: "rejected", reason: Q })
            )
          )
        );
      };
      document.getElementsByTagName("link");
      const W = document.querySelector("meta[property=csp-nonce]"),
        K =
          (W == null ? void 0 : W.nonce) ||
          (W == null ? void 0 : W.getAttribute("nonce"));
      j = $(
        F.map((G) => {
          if (((G = assetsURL(G)), G in seen)) return;
          seen[G] = !0;
          const H = G.endsWith(".css"),
            Q = H ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${G}"]${Q}`)) return;
          const z = document.createElement("link");
          if (
            ((z.rel = H ? "stylesheet" : scriptRel),
            H || (z.as = "script"),
            (z.crossOrigin = ""),
            (z.href = G),
            K && z.setAttribute("nonce", K),
            document.head.appendChild(z),
            H)
          )
            return new Promise((Y, X) => {
              z.addEventListener("load", Y),
                z.addEventListener("error", () =>
                  X(new Error(`Unable to preload CSS for ${G}`))
                );
            });
        })
      );
    }
    function V($) {
      const W = new Event("vite:preloadError", { cancelable: !0 });
      if (((W.payload = $), window.dispatchEvent(W), !W.defaultPrevented))
        throw $;
    }
    return j.then(($) => {
      for (const W of $ || []) W.status === "rejected" && V(W.reason);
      return U().catch(V);
    });
  };
var __awaiter$9 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
const NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket < "u";
class AbstractLiveClient extends AbstractClient {
  constructor(U) {
    super(U),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.reconnect = noop);
    const {
      key: F,
      websocket: { options: q, client: j },
    } = this.namespaceOptions;
    this.proxy ? (this.baseUrl = q.proxy.url) : (this.baseUrl = q.url),
      j ? (this.transport = j) : (this.transport = null),
      q._nodeOnlyHeaders
        ? (this.headers = q._nodeOnlyHeaders)
        : (this.headers = {}),
      "Authorization" in this.headers ||
        (this.accessToken
          ? (this.headers.Authorization = `Bearer ${this.accessToken}`)
          : (this.headers.Authorization = `Token ${F}`));
  }
  connect(U, F) {
    if (this.conn) return;
    this.reconnect = ($ = U) => {
      this.connect($, F);
    };
    const q = this.getRequestUrl(F, {}, U),
      j = this.accessToken,
      V = this.key;
    if (!j && !V)
      throw new Error(
        "No key or access token provided for WebSocket connection."
      );
    if (this.transport) {
      (this.conn = new this.transport(q, void 0, { headers: this.headers })),
        this.setupConnection();
      return;
    }
    if (isBun()) {
      __vitePreload(async () => {
        const { default: $ } = await import("./browser-B7Sz9Umv.js").then(
          (W) => W.b
        );
        return { default: $ };
      }, []).then(({ default: $ }) => {
        (this.conn = new $(q, { headers: this.headers })),
          console.log("Using WS package"),
          this.setupConnection();
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      (this.conn = new WebSocket(q, j ? ["bearer", j] : ["token", V])),
        this.setupConnection();
      return;
    }
    (this.conn = new WSWebSocketDummy(q, void 0, {
      close: () => {
        this.conn = null;
      },
    })),
      __vitePreload(async () => {
        const { default: $ } = await import("./browser-B7Sz9Umv.js").then(
          (W) => W.b
        );
        return { default: $ };
      }, []).then(({ default: $ }) => {
        (this.conn = new $(q, void 0, { headers: this.headers })),
          this.setupConnection();
      });
  }
  disconnect(U, F) {
    this.conn &&
      ((this.conn.onclose = function () {}),
      U ? this.conn.close(U, F ?? "") : this.conn.close(),
      (this.conn = null));
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case SOCKET_STATES.connecting:
        return CONNECTION_STATE.Connecting;
      case SOCKET_STATES.open:
        return CONNECTION_STATE.Open;
      case SOCKET_STATES.closing:
        return CONNECTION_STATE.Closing;
      default:
        return CONNECTION_STATE.Closed;
    }
  }
  getReadyState() {
    var U, F;
    return (F =
      (U = this.conn) === null || U === void 0 ? void 0 : U.readyState) !==
      null && F !== void 0
      ? F
      : SOCKET_STATES.closed;
  }
  isConnected() {
    return this.connectionState() === CONNECTION_STATE.Open;
  }
  send(U) {
    const F = () =>
      __awaiter$9(this, void 0, void 0, function* () {
        var q;
        if (U instanceof Blob) {
          if (U.size === 0) {
            this.log("warn", "skipping `send` for zero-byte blob", U);
            return;
          }
          U = yield U.arrayBuffer();
        }
        if (typeof U != "string" && !(U != null && U.byteLength)) {
          this.log("warn", "skipping `send` for zero-byte payload", U);
          return;
        }
        (q = this.conn) === null || q === void 0 || q.send(U);
      });
    this.isConnected() ? F() : this.sendBuffer.push(F);
  }
  get proxy() {
    var U;
    return (
      this.key === "proxy" &&
      !!(
        !(
          (U = this.namespaceOptions.websocket.options.proxy) === null ||
          U === void 0
        ) && U.url
      )
    );
  }
  extractErrorInformation(U, F) {
    var q;
    const j = {};
    if (
      (F &&
        ((j.readyState = F.readyState),
        (j.url =
          typeof F.url == "string"
            ? F.url
            : (q = F.url) === null || q === void 0
            ? void 0
            : q.toString())),
      F && typeof F == "object")
    ) {
      const V = F;
      if (
        V._req &&
        V._req.res &&
        ((j.statusCode = V._req.res.statusCode), V._req.res.headers)
      ) {
        j.responseHeaders = Object.assign({}, V._req.res.headers);
        const $ =
          V._req.res.headers["dg-request-id"] ||
          V._req.res.headers["x-dg-request-id"];
        $ && (j.requestId = $);
      }
      if (U && "target" in U && U.target) {
        const $ = U.target;
        $.url && (j.url = $.url),
          $.readyState !== void 0 && (j.readyState = $.readyState);
      }
    }
    return j;
  }
  createEnhancedError(U, F) {
    const q = new DeepgramWebSocketError(
      U.message || "WebSocket connection error",
      Object.assign({ originalEvent: U }, F)
    );
    return Object.assign(Object.assign({}, U), {
      error: q,
      statusCode: F.statusCode,
      requestId: F.requestId,
      responseHeaders: F.responseHeaders,
      url: F.url,
      readyState: F.readyState,
      message: this.buildEnhancedErrorMessage(U, F),
    });
  }
  buildEnhancedErrorMessage(U, F) {
    let q = U.message || "WebSocket connection error";
    const j = [];
    if (
      (F.statusCode && j.push(`Status: ${F.statusCode}`),
      F.requestId && j.push(`Request ID: ${F.requestId}`),
      F.readyState !== void 0)
    ) {
      const $ =
        ["CONNECTING", "OPEN", "CLOSING", "CLOSED"][F.readyState] ||
        `Unknown(${F.readyState})`;
      j.push(`Ready State: ${$}`);
    }
    return (
      F.url && j.push(`URL: ${F.url}`),
      j.length > 0 && (q += ` (${j.join(", ")})`),
      q
    );
  }
  setupConnectionEvents(U) {
    this.conn &&
      ((this.conn.onopen = () => {
        this.emit(U.Open, this);
      }),
      (this.conn.onclose = (F) => {
        this.emit(U.Close, F);
      }),
      (this.conn.onerror = (F) => {
        const q = this.extractErrorInformation(F, this.conn || void 0),
          j = this.createEnhancedError(F, q);
        this.emit(U.Error, j);
      }));
  }
}
class WSWebSocketDummy {
  constructor(U, F, q) {
    (this.binaryType = "arraybuffer"),
      (this.onclose = () => {}),
      (this.onerror = () => {}),
      (this.onmessage = () => {}),
      (this.onopen = () => {}),
      (this.readyState = SOCKET_STATES.connecting),
      (this.send = () => {}),
      (this.url = null),
      (this.url = U.toString()),
      (this.close = q.close);
  }
}
var __awaiter$8 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
const resolveFetch = (B) => {
    let U;
    return (
      B ? (U = B) : typeof fetch > "u" ? (U = crossFetch) : (U = fetch),
      (...F) => U(...F)
    );
  },
  fetchWithAuth = ({ apiKey: B, customFetch: U, accessToken: F }) => {
    const q = resolveFetch(U),
      j = resolveHeadersConstructor();
    return (V, $) =>
      __awaiter$8(void 0, void 0, void 0, function* () {
        const W = new j($ == null ? void 0 : $.headers);
        return (
          W.has("Authorization") ||
            W.set("Authorization", F ? `Bearer ${F}` : `Token ${B}`),
          q(V, Object.assign(Object.assign({}, $), { headers: W }))
        );
      });
  },
  resolveResponse = () =>
    __awaiter$8(void 0, void 0, void 0, function* () {
      return typeof Response > "u"
        ? (yield __vitePreload(
            () => Promise.resolve().then(() => browserPonyfill),
            void 0
          )).Response
        : Response;
    });
var __awaiter$7 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class AbstractRestClient extends AbstractClient {
  constructor(U) {
    if ((super(U), isBrowser() && !this.proxy))
      throw new DeepgramError(
        "Due to CORS we are unable to support REST-based API calls to our API from the browser. Please consider using a proxy: https://dpgr.am/js-proxy for more information."
      );
    const { accessToken: F, key: q, fetch: j } = this;
    (this.fetch = fetchWithAuth({ accessToken: F, apiKey: q, customFetch: j })),
      this.proxy
        ? (this.baseUrl = this.namespaceOptions.fetch.options.proxy.url)
        : (this.baseUrl = this.namespaceOptions.fetch.options.url);
  }
  _getErrorMessage(U) {
    return (
      U.msg || U.message || U.error_description || U.error || JSON.stringify(U)
    );
  }
  _handleError(U, F) {
    return __awaiter$7(this, void 0, void 0, function* () {
      const q = yield resolveResponse();
      U instanceof q
        ? U.json()
            .then((j) => {
              F(
                new DeepgramApiError(this._getErrorMessage(j), U.status || 500)
              );
            })
            .catch((j) => {
              F(new DeepgramUnknownError(this._getErrorMessage(j), j));
            })
        : F(new DeepgramUnknownError(this._getErrorMessage(U), U));
    });
  }
  _getRequestOptions(U, F, q) {
    let j = { method: U };
    return (
      U === "GET" || U === "DELETE"
        ? (j = Object.assign(Object.assign({}, j), F))
        : (j = Object.assign(Object.assign({ duplex: "half", body: F }, j), q)),
      merge(this.namespaceOptions.fetch.options, j, { clone: !1 })
    );
  }
  _handleRequest(U, F, q, j) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return new Promise((V, $) => {
        const W = this.fetch;
        W(F, this._getRequestOptions(U, q, j))
          .then((K) => {
            if (!K.ok) throw K;
            V(K);
          })
          .catch((K) => this._handleError(K, $));
      });
    });
  }
  get(U, F) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this._handleRequest("GET", U, F);
    });
  }
  post(U, F, q) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this._handleRequest("POST", U, F, q);
    });
  }
  put(U, F, q) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this._handleRequest("PUT", U, F, q);
    });
  }
  patch(U, F, q) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this._handleRequest("PATCH", U, F, q);
    });
  }
  delete(U, F) {
    return __awaiter$7(this, void 0, void 0, function* () {
      return this._handleRequest("DELETE", U, F);
    });
  }
  get proxy() {
    var U;
    return (
      this.key === "proxy" &&
      !!(
        !(
          (U = this.namespaceOptions.fetch.options.proxy) === null ||
          U === void 0
        ) && U.url
      )
    );
  }
}
var AgentEvents;
(function (B) {
  (B.Open = "Open"),
    (B.Close = "Close"),
    (B.Error = "Error"),
    (B.Audio = "Audio"),
    (B.Welcome = "Welcome"),
    (B.SettingsApplied = "SettingsApplied"),
    (B.ConversationText = "ConversationText"),
    (B.UserStartedSpeaking = "UserStartedSpeaking"),
    (B.AgentThinking = "AgentThinking"),
    (B.FunctionCallRequest = "FunctionCallRequest"),
    (B.AgentStartedSpeaking = "AgentStartedSpeaking"),
    (B.AgentAudioDone = "AgentAudioDone"),
    (B.InjectionRefused = "InjectionRefused"),
    (B.PromptUpdated = "PromptUpdated"),
    (B.SpeakUpdated = "SpeakUpdated"),
    (B.Unhandled = "Unhandled");
})(AgentEvents || (AgentEvents = {}));
class AgentLiveClient extends AbstractLiveClient {
  constructor(U, F = "/:version/agent/converse") {
    var q, j, V, $;
    super(U),
      (this.namespace = "agent"),
      (this.baseUrl =
        ($ =
          (V =
            (j =
              (q = U.agent) === null || q === void 0 ? void 0 : q.websocket) ===
              null || j === void 0
              ? void 0
              : j.options) === null || V === void 0
            ? void 0
            : V.url) !== null && $ !== void 0
          ? $
          : DEFAULT_AGENT_URL),
      this.connect({}, F);
  }
  setupConnection() {
    this.setupConnectionEvents({
      Open: AgentEvents.Open,
      Close: AgentEvents.Close,
      Error: AgentEvents.Error,
    }),
      this.conn &&
        (this.conn.onmessage = (U) => {
          this.handleMessage(U);
        });
  }
  handleMessage(U) {
    var F, q, j, V, $, W;
    if (typeof U.data == "string")
      try {
        const K = JSON.parse(U.data);
        this.handleTextMessage(K);
      } catch (K) {
        this.emit(AgentEvents.Error, {
          event: U,
          data:
            ((F = U.data) === null || F === void 0
              ? void 0
              : F.toString().substring(0, 200)) +
            (((q = U.data) === null || q === void 0
              ? void 0
              : q.toString().length) > 200
              ? "..."
              : ""),
          message: "Unable to parse `data` as JSON.",
          error: K,
          url: (j = this.conn) === null || j === void 0 ? void 0 : j.url,
          readyState:
            (V = this.conn) === null || V === void 0 ? void 0 : V.readyState,
        });
      }
    else
      U.data instanceof Blob
        ? U.data.arrayBuffer().then((K) => {
            this.handleBinaryMessage(Buffer.from(K));
          })
        : U.data instanceof ArrayBuffer
        ? this.handleBinaryMessage(Buffer.from(U.data))
        : Buffer.isBuffer(U.data)
        ? this.handleBinaryMessage(U.data)
        : (console.log("Received unknown data type", U.data),
          this.emit(AgentEvents.Error, {
            event: U,
            message: "Received unknown data type.",
            url: ($ = this.conn) === null || $ === void 0 ? void 0 : $.url,
            readyState:
              (W = this.conn) === null || W === void 0 ? void 0 : W.readyState,
            dataType: typeof U.data,
          }));
  }
  handleBinaryMessage(U) {
    this.emit(AgentEvents.Audio, U);
  }
  handleTextMessage(U) {
    U.type in AgentEvents
      ? this.emit(U.type, U)
      : this.emit(AgentEvents.Unhandled, U);
  }
  configure(U) {
    const F = JSON.stringify(Object.assign({ type: "Settings" }, U));
    this.send(F);
  }
  updatePrompt(U) {
    this.send(JSON.stringify({ type: "UpdatePrompt", prompt: U }));
  }
  updateSpeak(U) {
    this.send(JSON.stringify({ type: "UpdateSpeak", speak: U }));
  }
  injectAgentMessage(U) {
    this.send(JSON.stringify({ type: "InjectAgentMessage", content: U }));
  }
  injectUserMessage(U) {
    this.send(JSON.stringify({ type: "InjectUserMessage", content: U }));
  }
  functionCallResponse(U) {
    this.send(
      JSON.stringify(Object.assign({ type: "FunctionCallResponse" }, U))
    );
  }
  keepAlive() {
    this.send(JSON.stringify({ type: "KeepAlive" }));
  }
}
var __awaiter$6 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class AuthRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "auth");
  }
  grantToken(U = {}, F = ":version/auth/grant") {
    return __awaiter$6(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F),
          j = JSON.stringify(U);
        return {
          result: yield this.post(q, j, {
            headers: { "Content-Type": "application/json" },
          }).then(($) => $.json()),
          error: null,
        };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
}
var LiveTranscriptionEvents;
(function (B) {
  (B.Open = "open"),
    (B.Close = "close"),
    (B.Error = "error"),
    (B.Transcript = "Results"),
    (B.Metadata = "Metadata"),
    (B.UtteranceEnd = "UtteranceEnd"),
    (B.SpeechStarted = "SpeechStarted"),
    (B.Unhandled = "Unhandled");
})(LiveTranscriptionEvents || (LiveTranscriptionEvents = {}));
var LiveTTSEvents;
(function (B) {
  (B.Open = "Open"),
    (B.Close = "Close"),
    (B.Error = "Error"),
    (B.Metadata = "Metadata"),
    (B.Flushed = "Flushed"),
    (B.Warning = "Warning"),
    (B.Audio = "Audio"),
    (B.Unhandled = "Unhandled");
})(LiveTTSEvents || (LiveTTSEvents = {}));
class ListenLiveClient extends AbstractLiveClient {
  constructor(U, F = {}, q = ":version/listen") {
    super(U), (this.namespace = "listen"), this.connect(F, q);
  }
  setupConnection() {
    this.setupConnectionEvents({
      Open: LiveTranscriptionEvents.Open,
      Close: LiveTranscriptionEvents.Close,
      Error: LiveTranscriptionEvents.Error,
    }),
      this.conn &&
        (this.conn.onmessage = (U) => {
          var F, q, j, V;
          try {
            const $ = JSON.parse(U.data.toString());
            $.type === LiveTranscriptionEvents.Metadata
              ? this.emit(LiveTranscriptionEvents.Metadata, $)
              : $.type === LiveTranscriptionEvents.Transcript
              ? this.emit(LiveTranscriptionEvents.Transcript, $)
              : $.type === LiveTranscriptionEvents.UtteranceEnd
              ? this.emit(LiveTranscriptionEvents.UtteranceEnd, $)
              : $.type === LiveTranscriptionEvents.SpeechStarted
              ? this.emit(LiveTranscriptionEvents.SpeechStarted, $)
              : this.emit(LiveTranscriptionEvents.Unhandled, $);
          } catch ($) {
            this.emit(LiveTranscriptionEvents.Error, {
              event: U,
              message: "Unable to parse `data` as JSON.",
              error: $,
              url: (F = this.conn) === null || F === void 0 ? void 0 : F.url,
              readyState:
                (q = this.conn) === null || q === void 0
                  ? void 0
                  : q.readyState,
              data:
                ((j = U.data) === null || j === void 0
                  ? void 0
                  : j.toString().substring(0, 200)) +
                (((V = U.data) === null || V === void 0
                  ? void 0
                  : V.toString().length) > 200
                  ? "..."
                  : ""),
            });
          }
        });
  }
  configure(U) {
    this.send(JSON.stringify({ type: "Configure", processors: U }));
  }
  keepAlive() {
    this.send(JSON.stringify({ type: "KeepAlive" }));
  }
  finalize() {
    this.send(JSON.stringify({ type: "Finalize" }));
  }
  finish() {
    this.requestClose();
  }
  requestClose() {
    this.send(JSON.stringify({ type: "CloseStream" }));
  }
}
var __awaiter$5 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class ListenRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "listen");
  }
  transcribeUrl(U, F, q = ":version/listen") {
    var j, V;
    return __awaiter$5(this, void 0, void 0, function* () {
      try {
        let $;
        if (isUrlSource(U)) $ = JSON.stringify(U);
        else throw new DeepgramError("Unknown transcription source type");
        if (F !== void 0 && "callback" in F)
          throw new DeepgramError(
            "Callback cannot be provided as an option to a synchronous transcription. Use `transcribeUrlCallback` or `transcribeFileCallback` instead."
          );
        if (
          !((j = F == null ? void 0 : F.keyterm) === null || j === void 0) &&
          j.length &&
          !(!((V = F.model) === null || V === void 0) && V.startsWith("nova-3"))
        )
          throw new DeepgramError(
            "Keyterms are only supported with the Nova 3 models."
          );
        const W = this.getRequestUrl(q, {}, Object.assign({}, F));
        return {
          result: yield this.post(W, $).then((G) => G.json()),
          error: null,
        };
      } catch ($) {
        if (isDeepgramError($)) return { result: null, error: $ };
        throw $;
      }
    });
  }
  transcribeFile(U, F, q = ":version/listen") {
    return __awaiter$5(this, void 0, void 0, function* () {
      try {
        let j;
        if (isFileSource(U)) j = U;
        else throw new DeepgramError("Unknown transcription source type");
        if (F !== void 0 && "callback" in F)
          throw new DeepgramError(
            "Callback cannot be provided as an option to a synchronous transcription. Use `transcribeUrlCallback` or `transcribeFileCallback` instead."
          );
        const V = this.getRequestUrl(q, {}, Object.assign({}, F));
        return {
          result: yield this.post(V, j, {
            headers: { "Content-Type": "deepgram/audio+video" },
          }).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  transcribeUrlCallback(U, F, q, j = ":version/listen") {
    return __awaiter$5(this, void 0, void 0, function* () {
      try {
        let V;
        if (isUrlSource(U)) V = JSON.stringify(U);
        else throw new DeepgramError("Unknown transcription source type");
        const $ = this.getRequestUrl(
          j,
          {},
          Object.assign(Object.assign({}, q), { callback: F.toString() })
        );
        return {
          result: yield this.post($, V).then((K) => K.json()),
          error: null,
        };
      } catch (V) {
        if (isDeepgramError(V)) return { result: null, error: V };
        throw V;
      }
    });
  }
  transcribeFileCallback(U, F, q, j = ":version/listen") {
    return __awaiter$5(this, void 0, void 0, function* () {
      try {
        let V;
        if (isFileSource(U)) V = U;
        else throw new DeepgramError("Unknown transcription source type");
        const $ = this.getRequestUrl(
          j,
          {},
          Object.assign(Object.assign({}, q), { callback: F.toString() })
        );
        return {
          result: yield this.post($, V, {
            headers: { "Content-Type": "deepgram/audio+video" },
          }).then((K) => K.json()),
          error: null,
        };
      } catch (V) {
        if (isDeepgramError(V)) return { result: null, error: V };
        throw V;
      }
    });
  }
}
class ListenClient extends AbstractClient {
  constructor() {
    super(...arguments), (this.namespace = "listen");
  }
  get prerecorded() {
    return new ListenRestClient(this.options);
  }
  live(U = {}, F = ":version/listen") {
    return new ListenLiveClient(this.options, U, F);
  }
}
var __awaiter$4 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class ManageRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "manage");
  }
  getTokenDetails(U = ":version/auth/token") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const F = this.getRequestUrl(U);
        return { result: yield this.get(F).then((j) => j.json()), error: null };
      } catch (F) {
        if (isDeepgramError(F)) return { result: null, error: F };
        throw F;
      }
    });
  }
  getProjects(U = ":version/projects") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const F = this.getRequestUrl(U);
        return { result: yield this.get(F).then((j) => j.json()), error: null };
      } catch (F) {
        if (isDeepgramError(F)) return { result: null, error: F };
        throw F;
      }
    });
  }
  getProject(U, F = ":version/projects/:projectId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  updateProject(U, F, q = ":version/projects/:projectId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F),
          V = JSON.stringify(F);
        return {
          result: yield this.patch(j, V).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  deleteProject(U, F = ":version/projects/:projectId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return yield this.delete(q), { error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { error: q };
        throw q;
      }
    });
  }
  getProjectKeys(U, F = ":version/projects/:projectId/keys") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  getProjectKey(U, F, q = ":version/projects/:projectId/keys/:keyId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, keyId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  createProjectKey(U, F, q = ":version/projects/:projectId/keys") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F),
          V = JSON.stringify(F);
        return {
          result: yield this.post(j, V).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  deleteProjectKey(U, F, q = ":version/projects/:projectId/keys/:keyId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, keyId: F });
        return yield this.delete(j), { error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { error: j };
        throw j;
      }
    });
  }
  getProjectMembers(U, F = ":version/projects/:projectId/members") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  removeProjectMember(
    U,
    F,
    q = ":version/projects/:projectId/members/:memberId"
  ) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, memberId: F });
        return yield this.delete(j), { error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { error: j };
        throw j;
      }
    });
  }
  getProjectMemberScopes(
    U,
    F,
    q = ":version/projects/:projectId/members/:memberId/scopes"
  ) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, memberId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  updateProjectMemberScope(
    U,
    F,
    q,
    j = ":version/projects/:projectId/members/:memberId/scopes"
  ) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const V = this.getRequestUrl(j, { projectId: U, memberId: F }, q),
          $ = JSON.stringify(q);
        return {
          result: yield this.put(V, $).then((K) => K.json()),
          error: null,
        };
      } catch (V) {
        if (isDeepgramError(V)) return { result: null, error: V };
        throw V;
      }
    });
  }
  getProjectInvites(U, F = ":version/projects/:projectId/invites") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  sendProjectInvite(U, F, q = ":version/projects/:projectId/invites") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F),
          V = JSON.stringify(F);
        return {
          result: yield this.post(j, V).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  deleteProjectInvite(U, F, q = ":version/projects/:projectId/invites/:email") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, email: F });
        return yield this.delete(j), { error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { error: j };
        throw j;
      }
    });
  }
  leaveProject(U, F = ":version/projects/:projectId/leave") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return {
          result: yield this.delete(q).then((V) => V.json()),
          error: null,
        };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  getProjectUsageRequests(U, F, q = ":version/projects/:projectId/requests") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F);
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getProjectUsageRequest(
    U,
    F,
    q = ":version/projects/:projectId/requests/:requestId"
  ) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, requestId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getProjectUsageSummary(U, F, q = ":version/projects/:projectId/usage") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F);
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getProjectUsageFields(U, F, q = ":version/projects/:projectId/usage/fields") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F);
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getProjectBalances(U, F = ":version/projects/:projectId/balances") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  getProjectBalance(
    U,
    F,
    q = ":version/projects/:projectId/balances/:balanceId"
  ) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, balanceId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getAllModels(U, F = {}, q = ":version/projects/:projectId/models") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }, F);
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  getModel(U, F, q = ":version/projects/:projectId/models/:modelId") {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, modelId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
}
var __awaiter$3 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class ModelsRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "models");
  }
  getAll(U = ":version/models", F = {}) {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(U, {}, F);
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  getModel(U, F = ":version/models/:modelId") {
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { modelId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
}
var __awaiter$2 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class ReadRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "read");
  }
  analyzeUrl(U, F, q = ":version/read") {
    return __awaiter$2(this, void 0, void 0, function* () {
      try {
        let j;
        if (isUrlSource(U)) j = JSON.stringify(U);
        else throw new DeepgramError("Unknown source type");
        if (F !== void 0 && "callback" in F)
          throw new DeepgramError(
            "Callback cannot be provided as an option to a synchronous transcription. Use `analyzeUrlCallback` or `analyzeTextCallback` instead."
          );
        const V = this.getRequestUrl(q, {}, Object.assign({}, F));
        return {
          result: yield this.post(V, j).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  analyzeText(U, F, q = ":version/read") {
    return __awaiter$2(this, void 0, void 0, function* () {
      try {
        let j;
        if (isTextSource(U)) j = JSON.stringify(U);
        else throw new DeepgramError("Unknown source type");
        if (F !== void 0 && "callback" in F)
          throw new DeepgramError(
            "Callback cannot be provided as an option to a synchronous requests. Use `analyzeUrlCallback` or `analyzeTextCallback` instead."
          );
        const V = this.getRequestUrl(q, {}, Object.assign({}, F));
        return {
          result: yield this.post(V, j).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  analyzeUrlCallback(U, F, q, j = ":version/read") {
    return __awaiter$2(this, void 0, void 0, function* () {
      try {
        let V;
        if (isUrlSource(U)) V = JSON.stringify(U);
        else throw new DeepgramError("Unknown source type");
        const $ = this.getRequestUrl(
          j,
          {},
          Object.assign(Object.assign({}, q), { callback: F.toString() })
        );
        return {
          result: yield this.post($, V).then((K) => K.json()),
          error: null,
        };
      } catch (V) {
        if (isDeepgramError(V)) return { result: null, error: V };
        throw V;
      }
    });
  }
  analyzeTextCallback(U, F, q, j = ":version/read") {
    return __awaiter$2(this, void 0, void 0, function* () {
      try {
        let V;
        if (isTextSource(U)) V = JSON.stringify(U);
        else throw new DeepgramError("Unknown source type");
        const $ = this.getRequestUrl(
          j,
          {},
          Object.assign(Object.assign({}, q), { callback: F.toString() })
        );
        return {
          result: yield this.post($, V, {
            headers: { "Content-Type": "deepgram/audio+video" },
          }).then((K) => K.json()),
          error: null,
        };
      } catch (V) {
        if (isDeepgramError(V)) return { result: null, error: V };
        throw V;
      }
    });
  }
}
var __awaiter$1 = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class SelfHostedRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "selfhosted");
  }
  listCredentials(
    U,
    F = ":version/projects/:projectId/onprem/distribution/credentials"
  ) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const q = this.getRequestUrl(F, { projectId: U });
        return { result: yield this.get(q).then((V) => V.json()), error: null };
      } catch (q) {
        if (isDeepgramError(q)) return { result: null, error: q };
        throw q;
      }
    });
  }
  getCredentials(
    U,
    F,
    q = ":version/projects/:projectId/onprem/distribution/credentials/:credentialsId"
  ) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, credentialsId: F });
        return { result: yield this.get(j).then(($) => $.json()), error: null };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  createCredentials(
    U,
    F,
    q = ":version/projects/:projectId/onprem/distribution/credentials"
  ) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U }),
          V = JSON.stringify(F);
        return {
          result: yield this.post(j, V).then((W) => W.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
  deleteCredentials(
    U,
    F,
    q = ":version/projects/:projectId/onprem/distribution/credentials/:credentialsId"
  ) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        const j = this.getRequestUrl(q, { projectId: U, credentialsId: F });
        return {
          result: yield this.delete(j).then(($) => $.json()),
          error: null,
        };
      } catch (j) {
        if (isDeepgramError(j)) return { result: null, error: j };
        throw j;
      }
    });
  }
}
class SpeakLiveClient extends AbstractLiveClient {
  constructor(U, F = {}, q = ":version/speak") {
    super(U), (this.namespace = "speak"), this.connect(F, q);
  }
  setupConnection() {
    this.setupConnectionEvents({
      Open: LiveTTSEvents.Open,
      Close: LiveTTSEvents.Close,
      Error: LiveTTSEvents.Error,
    }),
      this.conn &&
        (this.conn.onmessage = (U) => {
          this.handleMessage(U);
        });
  }
  handleTextMessage(U) {
    U.type === LiveTTSEvents.Metadata
      ? this.emit(LiveTTSEvents.Metadata, U)
      : U.type === LiveTTSEvents.Flushed
      ? this.emit(LiveTTSEvents.Flushed, U)
      : U.type === LiveTTSEvents.Warning
      ? this.emit(LiveTTSEvents.Warning, U)
      : this.emit(LiveTTSEvents.Unhandled, U);
  }
  handleBinaryMessage(U) {
    this.emit(LiveTTSEvents.Audio, U);
  }
  sendText(U) {
    this.send(JSON.stringify({ type: "Speak", text: U }));
  }
  flush() {
    this.send(JSON.stringify({ type: "Flush" }));
  }
  clear() {
    this.send(JSON.stringify({ type: "Clear" }));
  }
  requestClose() {
    this.send(JSON.stringify({ type: "Close" }));
  }
  handleMessage(U) {
    var F, q, j, V, $, W;
    if (typeof U.data == "string")
      try {
        const K = JSON.parse(U.data);
        this.handleTextMessage(K);
      } catch (K) {
        this.emit(LiveTTSEvents.Error, {
          event: U,
          message: "Unable to parse `data` as JSON.",
          error: K,
          url: (F = this.conn) === null || F === void 0 ? void 0 : F.url,
          readyState:
            (q = this.conn) === null || q === void 0 ? void 0 : q.readyState,
          data:
            ((j = U.data) === null || j === void 0
              ? void 0
              : j.toString().substring(0, 200)) +
            (((V = U.data) === null || V === void 0
              ? void 0
              : V.toString().length) > 200
              ? "..."
              : ""),
        });
      }
    else
      U.data instanceof Blob
        ? U.data.arrayBuffer().then((K) => {
            this.handleBinaryMessage(Buffer.from(K));
          })
        : U.data instanceof ArrayBuffer
        ? this.handleBinaryMessage(Buffer.from(U.data))
        : Buffer.isBuffer(U.data)
        ? this.handleBinaryMessage(U.data)
        : (console.log("Received unknown data type", U.data),
          this.emit(LiveTTSEvents.Error, {
            event: U,
            message: "Received unknown data type.",
            url: ($ = this.conn) === null || $ === void 0 ? void 0 : $.url,
            readyState:
              (W = this.conn) === null || W === void 0 ? void 0 : W.readyState,
            dataType: typeof U.data,
          }));
  }
}
var __awaiter = function (B, U, F, q) {
  function j(V) {
    return V instanceof F
      ? V
      : new F(function ($) {
          $(V);
        });
  }
  return new (F || (F = Promise))(function (V, $) {
    function W(H) {
      try {
        G(q.next(H));
      } catch (Q) {
        $(Q);
      }
    }
    function K(H) {
      try {
        G(q.throw(H));
      } catch (Q) {
        $(Q);
      }
    }
    function G(H) {
      H.done ? V(H.value) : j(H.value).then(W, K);
    }
    G((q = q.apply(B, U || [])).next());
  });
};
class SpeakRestClient extends AbstractRestClient {
  constructor() {
    super(...arguments), (this.namespace = "speak");
  }
  request(U, F, q = ":version/speak") {
    return __awaiter(this, void 0, void 0, function* () {
      let j;
      if (isTextSource(U)) j = JSON.stringify(U);
      else throw new DeepgramError("Unknown transcription source type");
      const V = this.getRequestUrl(
        q,
        {},
        Object.assign({ model: "aura-2-thalia-en" }, F)
      );
      return (
        (this.result = yield this.post(V, j, {
          headers: { Accept: "audio/*", "Content-Type": "application/json" },
        })),
        this
      );
    });
  }
  getStream() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.result)
        throw new DeepgramUnknownError(
          "Tried to get stream before making request",
          ""
        );
      return this.result.body;
    });
  }
  getHeaders() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.result)
        throw new DeepgramUnknownError(
          "Tried to get headers before making request",
          ""
        );
      return this.result.headers;
    });
  }
}
class SpeakClient extends AbstractClient {
  constructor() {
    super(...arguments), (this.namespace = "speak");
  }
  request(U, F, q = ":version/speak") {
    return new SpeakRestClient(this.options).request(U, F, q);
  }
  live(U = {}, F = ":version/speak") {
    return new SpeakLiveClient(this.options, U, F);
  }
}
class DeepgramClient extends AbstractClient {
  get auth() {
    return new AuthRestClient(this.options);
  }
  get listen() {
    return new ListenClient(this.options);
  }
  get manage() {
    return new ManageRestClient(this.options);
  }
  get models() {
    return new ModelsRestClient(this.options);
  }
  get onprem() {
    return this.selfhosted;
  }
  get selfhosted() {
    return new SelfHostedRestClient(this.options);
  }
  get read() {
    return new ReadRestClient(this.options);
  }
  get speak() {
    return new SpeakClient(this.options);
  }
  agent(U = "/:version/agent/converse") {
    return new AgentLiveClient(this.options, U);
  }
  get transcription() {
    throw new DeepgramVersionError();
  }
  get projects() {
    throw new DeepgramVersionError();
  }
  get keys() {
    throw new DeepgramVersionError();
  }
  get members() {
    throw new DeepgramVersionError();
  }
  get scopes() {
    throw new DeepgramVersionError();
  }
  get invitation() {
    throw new DeepgramVersionError();
  }
  get usage() {
    throw new DeepgramVersionError();
  }
  get billing() {
    throw new DeepgramVersionError();
  }
}
function createClient(B, U) {
  let F = {};
  return (
    typeof B == "string" || typeof B == "function"
      ? (F.key = B)
      : typeof B == "object" && (F = B),
    new DeepgramClient(F)
  );
}
const PLUGIN_OPTIONS = window.PLUGIN_OPTIONS,
  videoElement = document.getElementById("avatarVideo"),
  startButton = document.getElementById("startSession"),
  endButton = document.getElementById("endSession"),
  interruptTask = document.getElementById("interruptTask"),
  micToggle = document.getElementById("micToggler"),
  cameraToggle = document.getElementById("cameraToggler"),
  micIcon = document.getElementById("micIcon"),
  switchInteractionMode = document.getElementById("switchInteractionMode"),
  speakButton = document.getElementById("speakButton"),
  userInput = document.getElementById("userInput"),
  chatBoxContainer = document.getElementById("chatBox"),
  avatarContainer = document.querySelector(".avatarContainer"),
  avatarError = document.getElementById("avatarError"),
  ajaxURL = document.getElementById("ajaxURL"),
  heygenNonce = document.getElementById("avatar_studio_nonce"),
  avatar_studio_nonce = heygenNonce
    ? heygenNonce == null
      ? void 0
      : heygenNonce.value
    : "",
  ajaxurl = ajaxURL ? (ajaxURL == null ? void 0 : ajaxURL.value) : "",
  chatOnly = startButton.getAttribute("chatOnly") === "1",
  videoEnable = startButton.getAttribute("videoEnable") === "1",
  transcriptContainer = document.getElementById("transcriptContainer"),
  voiceTranscript = document.getElementById("voiceTranscript"),
  exportTranscriptToPDFButton = document.getElementById(
    "exportTranscriptToPDF"
  ),
  sendTranscriptToEmailButton = document.getElementById(
    "sendTranscriptToEmail"
  ),
  overlayQuestionContainer = document.getElementById("overlayQuestion"),
  overlayQuestionSubmitButton = document.getElementById(
    "overlayQuestionSubmit"
  ),
  closeOverlayQuestionButton = document.getElementById("closeOverlayQuestion"),
  countdownElement = document.getElementById("streamingCountdown"),
  avatarStudioIdElem = document.getElementById("avatarStudioId"),
  chatBoxClose = document.getElementById("chatBox-close");
let sessionId = "",
  tokenCall = 0,
  sessionData = null,
  notifications = [],
  deepgramToken = "",
  userTalkingText = "",
  avatarTalkingText = "",
  avatar = null,
  countdownTimer = null,
  language = startButton.getAttribute("language");
language = language && language != "null" ? language : "en";
let customRagEnabled = startButton.getAttribute("custom_rag_enable") === "true",
  deepgramConnection = null,
  isDeepgramMuted = !1,
  mediaRecorder = null,
  keepAliveInterval = null,
  questionnaires = [],
  renderedQuestionnaires = [],
  answerSubmit = !0;
function closeOverlayQuestion() {
  overlayQuestionContainer.classList.remove("show"),
    overlayQuestionContainer.removeAttribute("data-question-title"),
    overlayQuestionContainer.removeAttribute("data-question-type"),
    overlayQuestionContainer.removeAttribute("data-question_id");
  const B = questionnaires.shift();
  return B && renderedQuestionnaires.push(B), (answerSubmit = !0), !0;
}
function getTimeLimitSeconds(B) {
  const U = Number(B);
  if (Number.isFinite(U) && U > 0) return U * 60;
}
async function overlayQuestionSubmit() {
  const B = overlayQuestionContainer.getAttribute("data-question-title"),
    U = overlayQuestionContainer.getAttribute("data-question-type"),
    F = overlayQuestionContainer.getAttribute("data-question_id");
  let q = [];
  if (U === "checkbox")
    document
      .querySelectorAll('input[name="questionOption"]:checked')
      .forEach((V) => {
        q.push(V.value);
      });
  else if (U === "radio") {
    const j = document.querySelector('input[name="questionOption"]:checked');
    j && q.push(j.value);
  }
  return (
    avatar &&
      (await avatar.speak({ text: `${B} and user answer is ${q.join(",")}` })),
    ajaxurl
      ? await fetch(ajaxurl, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            action: "post_user_answer",
            session_id:
              (sessionData == null ? void 0 : sessionData.session_id) ?? "",
            access_token:
              (sessionData == null ? void 0 : sessionData.access_token) ?? "",
            question_id: F ?? "",
            title: B ?? "",
            answer: JSON.stringify(q),
          }),
        })
          .then((j) => j.json())
          .then(async (j) => {
            if (j.success) {
              const V = questionnaires.shift();
              V && renderedQuestionnaires.push(V),
                console.log("questionnaires", questionnaires),
                console.log("renderedQuestionnaires", renderedQuestionnaires),
                (answerSubmit = !0),
                overlayQuestionContainer.classList.remove("show");
            } else answerSubmit = !1;
          })
          .catch(
            (j) => (
              (answerSubmit = !1), console.error("There was an error!", j), ""
            )
          )
      : ""
  );
}
async function getAvatarQuestionnaires() {
  let B = avatarStudioIdElem ? avatarStudioIdElem.value : "0";
  if (!B || isNaN(parseInt(String(B)))) {
    console.warn("No Avatar Studio ID found");
    return;
  }
  return ajaxurl
    ? await fetch(ajaxurl, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          action: "get_avatar_studio_questionnaires",
          avatar_studio_id: B,
        }),
      })
        .then((U) => U.json())
        .then(async (U) => {
          U.success &&
            U != null &&
            U.data &&
            (questionnaires = U == null ? void 0 : U.data);
        })
        .catch((U) => (console.error("There was an error!", U), ""))
    : "";
}
async function getAvatarQuestionnaire(B) {
  return ajaxurl
    ? ((answerSubmit = !1),
      await fetch(ajaxurl, {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          action: "get_avatar_studio_questionnaire",
          id: B,
        }),
      })
        .then((U) => U.json())
        .then(async (U) => {
          var F, q;
          if (
            U.success &&
            (F = U == null ? void 0 : U.data) != null &&
            F.questionnaire
          ) {
            const j =
                (q = U == null ? void 0 : U.data) == null ? void 0 : q.options,
              V = U.data.questionnaire;
            overlayQuestionContainer.setAttribute(
              "data-question-title",
              escapeHtmlAttribute(V.title)
            ),
              overlayQuestionContainer.setAttribute(
                "data-question-type",
                V.questionType
              ),
              overlayQuestionContainer.setAttribute("data-question_id", V.id),
              (document.querySelector(".overlayQuestion-title").textContent =
                V.title);
            const $ = document.querySelector(".overlayQuestion-body");
            if (V.questionType == "radio" || V.questionType == "checkbox")
              if (j && j.length > 0) {
                let W = "";
                j.forEach((K) => {
                  V.questionType === "checkbox"
                    ? (W += `<div class="checkbox-option">
                    <input type="checkbox" name="questionOption" value="${K.option_title}" id="option-${K.id}">
                    <label for="option-${K.id}">${K.option_title}</label>
                  </div>`)
                    : V.questionType === "radio" &&
                      (W += `<div class="radio-option">
                  <input type="radio" name="questionOption" value="${K.option_title}" id="option-${K.id}">
                  <label for="option-${K.id}">${K.option_title}</label>
                </div>`);
                }),
                  ($.innerHTML = `<p>${V.description}</p>
              <div class="radio-options">${W}</div>`);
              } else $.innerHTML = `<p>${V.description}</p>`;
            overlayQuestionContainer.classList.add("show");
          }
        })
        .catch(
          (U) => (
            (answerSubmit = !0), console.error("There was an error!", U), ""
          )
        ))
    : "";
}
async function fetchAccessToken() {
  let B = document.getElementById("pageId"),
    U = document.getElementById("avatarStudioId");
  return (
    tokenCall++,
    ajaxurl
      ? await fetch(ajaxurl, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            action: "avanew_as_avatar_studio_heygenToken",
            nonce: avatar_studio_nonce,
            pageID: B ? String(B.value) : "0",
            avatar_studio_id: U ? String(U.value) : "0",
          }),
        })
          .then((F) => F.json())
          .then(async (F) => {
            var q, j, V, $;
            if (
              F.success &&
              ((q = F == null ? void 0 : F.data) == null ? void 0 : q.token) !=
                ""
            )
              return (
                (sessionId =
                  ((j = F == null ? void 0 : F.data) == null
                    ? void 0
                    : j.session_id) || ""),
                (notifications =
                  ((V = F == null ? void 0 : F.data) == null
                    ? void 0
                    : V.toast_messages) || []),
                (deepgramToken =
                  (($ = F == null ? void 0 : F.data) == null
                    ? void 0
                    : $.deepgram_token) || ""),
                F.data.token
              );
            if (tokenCall <= 5) return await fetchAccessToken();
          })
          .catch(
            (F) => (
              avatarContainer.classList.contains("loading") &&
                avatarContainer.classList.remove("loading"),
              console.error("There was an error!", F),
              ""
            )
          )
      : ""
  );
}
async function initializeAvatarSession() {
  (tokenCall = 0),
    avatarError &&
      ((avatarError.style.marginTop = "0px"), (avatarError.innerHTML = "")),
    avatarContainer.classList.contains("loading") ||
      avatarContainer.classList.add("loading"),
    getAvatarQuestionnaires();
  const B = await fetchAccessToken();
  if (B && B != "") {
    fetch(ajaxurl, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        action: "avanew_as_insert_avatar_studio_user",
        provider: "heygen",
        token: B,
      }),
    }),
      (avatar = new StreamingAvatar({ token: B })),
      avatar.on(StreamingEvents.AVATAR_START_TALKING, (W) => {
        console.log("Avatar started talking", W),
          avatarContainer.classList.contains("loading") &&
            avatarContainer.classList.remove("loading");
      }),
      avatar.on(StreamingEvents.AVATAR_STOP_TALKING, (W) => {
        console.log("Avatar stopped talking", W);
      }),
      avatar.on(StreamingEvents.STREAM_READY, handleStreamReady),
      avatar.on(StreamingEvents.STREAM_DISCONNECTED, handleStreamDisconnected),
      avatar.on(StreamingEvents.USER_START, (W) => {
        console.log(">>>>> User started talking:", W),
          (userTalkingText = ""),
          chatBoxContainer.classList.contains("talking") ||
            chatBoxContainer.classList.add("talking");
      }),
      avatar.on(StreamingEvents.USER_STOP, (W) => {
        console.log(">>>>> User stopped talking:", W),
          chatBoxContainer.classList.contains("talking") &&
            chatBoxContainer.classList.remove("talking");
      }),
      avatar.on(StreamingEvents.USER_SILENCE, () => {
        console.log("User is silent");
      }),
      avatar.on(StreamingEvents.USER_TALKING_MESSAGE, (W) => {
        var G;
        const K =
          ((G = W == null ? void 0 : W.detail) == null ? void 0 : G.message) ??
          "";
        (userTalkingText += ` ${K}`),
          createParagraphElement("user"),
          addTextToTranscript(K, "user", !1),
          console.log(" USER_TALKING_MESSAGE:", K, W.timeStamp);
      }),
      avatar.on(StreamingEvents.AVATAR_TALKING_MESSAGE, (W) => {
        var G;
        const K =
          ((G = W == null ? void 0 : W.detail) == null ? void 0 : G.message) ??
          "";
        avatarTalkingText += ` ${K}`;
      }),
      avatar.on(StreamingEvents.USER_END_MESSAGE, (W) => {
        let K = userTalkingText.trim();
        console.log("USER_END_MESSAGE", W, K), (userTalkingText = "");
      }),
      avatar.on(StreamingEvents.AVATAR_END_MESSAGE, (W) => {
        const K = avatarTalkingText.trim();
        console.log("AVATAR_END_MESSAGE", W, K),
          K.length > 0 &&
            (createParagraphElement("avatar"),
            addTextToTranscript(K, "avatar", !1),
            (avatarTalkingText = ""));
      });
    var U = startButton.getAttribute("aid"),
      F = startButton.getAttribute("kid"),
      q = startButton.getAttribute("opening_text");
    (q = q && q != "" ? q : "Hello, how can I help you?"),
      (U = U || "Ann_Therapist_public"),
      (F = F || "");
    let j = VoiceEmotion.EXCITED;
    PLUGIN_OPTIONS != null &&
      PLUGIN_OPTIONS.voice_emotion &&
      ((PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.voice_emotion) ==
      "excited"
        ? (j = VoiceEmotion.EXCITED)
        : (PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.voice_emotion) ==
          "serious"
        ? (j = VoiceEmotion.SERIOUS)
        : (PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.voice_emotion) ==
          "friendly"
        ? (j = VoiceEmotion.FRIENDLY)
        : (PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.voice_emotion) ==
          "soothing"
        ? (j = VoiceEmotion.SOOTHING)
        : (PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.voice_emotion) ==
            "broadcaster" && (j = VoiceEmotion.BROADCASTER));
    const V = {
      quality: AvatarQuality.High,
      avatarName: U,
      knowledgeId: F,
      voice: { rate: 1.5, emotion: j },
      language,
      useSilencePrompt: !1,
      disableIdleTimeout: !0,
      activityIdleTimeout: 180,
    };
    let $ = {};
    customRagEnabled && deepgramToken
      ? ($ = {
          ...V,
          sttSettings: {
            provider: STTProvider.DEEPGRAM,
            confidence: 0.55,
            continueSession: !1,
          },
        })
      : ($ = {
          ...V,
          sttSettings: { provider: STTProvider.DEEPGRAM, confidence: 0.55 },
        }),
      (sessionData = await avatar.createStartAvatar($)),
      (voiceTranscript.innerHTML = ""),
      (exportTranscriptToPDFButton.style.display = "none"),
      (sendTranscriptToEmailButton.style.display = "none"),
      console.log("Session data:", sessionData);
    try {
      chatOnly
        ? (chatBoxContainer.classList.add("text_mode"),
          chatBoxContainer.classList.add("showTranscript"),
          transcriptContainer.style.setProperty("display", "block"),
          (switchInteractionMode.style.display = "none"))
        : (navigator.mediaDevices
            .getUserMedia({ audio: !0 })
            .then((W) => {
              console.log("Microphone access granted.", W);
            })
            .catch((W) => {
              console.error("Permission denied or error:", W);
            }),
          customRagEnabled && deepgramToken
            ? ((isDeepgramMuted = !1),
              console.log("DEEEPRAM-CHECKS", { isDeepgramMuted, micIcon }),
              micIcon &&
                ((micIcon.className = isDeepgramMuted
                  ? "fa-solid fa-microphone-slash"
                  : "fa-solid fa-microphone"),
                console.log("DEEEPRAM-CHECKS", {
                  isDeepgramMuted,
                  micIcon,
                  class: micIcon == null ? void 0 : micIcon.className,
                })),
              await avatar.startVoiceChat({ isInputAudioMuted: !0 }),
              handleStartDeepgram(avatar))
            : (await avatar.startVoiceChat({ isInputAudioMuted: !1 }),
              micIcon &&
                (micIcon.className =
                  avatar != null && avatar.isInputAudioMuted
                    ? "fa-solid fa-microphone-slash"
                    : "fa-solid fa-microphone")),
          await avatar.speak({ text: q, task_type: TaskType.REPEAT }),
          chatBoxContainer.classList.remove("text_mode"),
          chatBoxContainer.classList.add("voice_mode"),
          micToggle && (micToggle.style.display = "block"),
          cameraToggle && videoEnable && (cameraToggle.style.display = "none"));
    } catch {
      setTimeout(function () {
        toggleInteractionMode(), avatarError && (avatarError.innerHTML = "");
      }, 1e3),
        avatarError &&
          (avatarError.innerHTML =
            '<span style="padding:10px; ">Voice mode isnt allowed now, so well switch to text mode instead! </span>');
    }
    startCountDown(
      getTimeLimitSeconds(
        PLUGIN_OPTIONS == null ? void 0 : PLUGIN_OPTIONS.time_limit
      )
    ),
      chatBoxContainer.classList.contains("avatarSessionStarted") ||
        chatBoxContainer.classList.add("avatarSessionStarted"),
      avatarContainer.classList.contains("loading") &&
        avatarContainer.classList.remove("loading"),
      avatarContainer.classList.contains("streamReady") ||
        avatarContainer.classList.add("streamReady");
  } else
    avatarError &&
      ((avatarError.style.marginTop = "70px"),
      (avatarError.innerHTML =
        '<span style="padding:10px; line-height: 26px; ">No Token Found, Please reload this page and Try again.</span>'),
      avatarContainer.classList.contains("loading") &&
        avatarContainer.classList.remove("loading"));
}
function handleStreamReady(B) {
  console.log(">>>>> Stream ready:", B),
    B.detail && videoElement
      ? ((videoElement.srcObject = B.detail),
        (videoElement.onloadedmetadata = () => {
          videoElement.play().catch(console.error);
        }))
      : console.error("Stream is not available");
}
function handleStreamDisconnected() {
  console.log("Stream disconnected"),
    videoElement && (videoElement.srcObject = null),
    avatarError &&
      ((avatarError.style.marginTop = "0px"), (avatarError.innerHTML = "")),
    customRagEnabled &&
      deepgramToken &&
      (deepgramConnection && cleanupDeepgram(), (sessionId = "")),
    countdownTimer !== null &&
      (clearInterval(countdownTimer),
      (countdownElement.textContent = "Session ended"),
      (countdownElement.style.color = "red"),
      countdownElement.classList.contains("session_expired") &&
        countdownElement.classList.remove("session_expired"),
      countdownElement.classList.contains("session_ended") ||
        countdownElement.classList.add("session_ended")),
    chatBoxContainer.classList.contains("avatarSessionStarted") &&
      chatBoxContainer.classList.remove("avatarSessionStarted"),
    chatBoxContainer.classList.contains("showTranscript") &&
      chatBoxContainer.classList.remove("showTranscript"),
    avatarContainer.classList.contains("streamReady") &&
      avatarContainer.classList.remove("streamReady"),
    avatarContainer.classList.contains("loading") &&
      avatarContainer.classList.remove("loading"),
    chatBoxContainer.classList.contains("talking") &&
      chatBoxContainer.classList.remove("talking"),
    chatBoxContainer.classList.remove("voice_mode"),
    chatBoxContainer.classList.remove("text_mode");
}
async function terminateAvatarSession() {
  !avatar ||
    !sessionData ||
    (customRagEnabled &&
      deepgramToken &&
      (deepgramConnection && cleanupDeepgram(), (sessionId = "")),
    await avatar.stopAvatar(),
    (videoElement.srcObject = null),
    (avatar = null),
    (notifications = []),
    avatarError && (avatarError.innerHTML = ""),
    countdownTimer !== null &&
      (clearInterval(countdownTimer),
      (countdownElement.textContent = "Session ended"),
      (countdownElement.style.color = "red"),
      countdownElement.classList.contains("session_expired") &&
        countdownElement.classList.remove("session_expired"),
      countdownElement.classList.contains("session_ended") ||
        countdownElement.classList.add("session_ended")),
    chatBoxContainer.classList.contains("avatarSessionStarted") &&
      chatBoxContainer.classList.remove("avatarSessionStarted"),
    chatBoxContainer.classList.contains("showTranscript") &&
      chatBoxContainer.classList.remove("showTranscript"),
    avatarContainer.classList.contains("streamReady") &&
      avatarContainer.classList.remove("streamReady"),
    avatarContainer.classList.contains("loading") &&
      avatarContainer.classList.remove("loading"),
    chatBoxContainer.classList.contains("talking") &&
      chatBoxContainer.classList.remove("talking"),
    chatBoxContainer.classList.remove("voice_mode"),
    chatBoxContainer.classList.remove("text_mode"));
}
async function handleInterrupt() {
  avatar && (await avatar.interrupt());
}
function handleMuteAudio() {
  customRagEnabled && deepgramToken
    ? toggleDeepgramMute()
    : avatar &&
      micToggle &&
      (avatar.isInputAudioMuted
        ? avatar.unmuteInputAudio()
        : avatar.muteInputAudio(),
      micIcon &&
        (micIcon.className =
          avatar != null && avatar.isInputAudioMuted
            ? "fa-solid fa-microphone-slash"
            : "fa-solid fa-microphone"),
      (micToggle.style.display = "block"));
}
async function handleSpeak() {
  let B = userInput.value;
  if (((userInput.value = ""), customRagEnabled && deepgramToken)) {
    handleInterrupt(),
      createParagraphElement("user"),
      addTextToTranscript(B, "user", !1);
    const U = await getAnswerPromptStudio(B);
    avatar && U && avatar.speak({ text: U, task_type: TaskType.REPEAT });
  } else
    avatar && B && (await avatar.speak({ text: B, task_type: TaskType.TALK }));
}
function createParagraphElement(B) {
  var V;
  let U = `${B} transcript`;
  const F = voiceTranscript.querySelectorAll(".transcript");
  let q = F[F.length - 1];
  if (
    q &&
    q.className == U &&
    ((V = q == null ? void 0 : q.textContent) == null ? void 0 : V.trim()) == ""
  )
    return;
  let j = document.createElement("p");
  (j.className = U),
    (j.style.margin = "0px"),
    (j.style.padding = "5px 10px"),
    (j.style.borderRadius = "5px"),
    (j.style.backgroundColor = B == "avatar" ? "#f0f0f0" : "#d0f0c0"),
    (j.style.color = B == "avatar" ? "#000" : "#333"),
    (j.style.fontSize = "14px"),
    (j.style.lineHeight = "1.5"),
    (j.style.whiteSpace = "pre-wrap"),
    (j.style.wordBreak = "break-word"),
    (j.style.marginBottom = "5px"),
    voiceTranscript.appendChild(j);
}
function addTextToTranscript(
  B,
  U = "avatar",
  F = !1,
  q = new Date().toISOString()
) {
  if (transcriptContainer) {
    window.getComputedStyle(exportTranscriptToPDFButton).display === "none" &&
      (exportTranscriptToPDFButton.style.display = "inline"),
      window.getComputedStyle(sendTranscriptToEmailButton).display === "none" &&
        (sendTranscriptToEmailButton.style.display = "inline");
    const j = voiceTranscript.querySelectorAll(`.${U}.transcript`);
    let V = j.length ? j[j.length - 1] : null;
    V ||
      (createParagraphElement(U),
      (V = voiceTranscript.querySelectorAll(`.${U}.transcript`)[0])),
      V.setAttribute("data-timestamp", q),
      V &&
        (F
          ? (V.textContent += ` ${B}`)
          : (!V.textContent ||
              (V == null ? void 0 : V.textContent.trim()) != B.trim()) &&
            (V.textContent = `${B}`));
  }
}
async function toggleInteractionMode() {
  if (
    (chatBoxContainer.classList.contains("text_mode")
      ? "text_mode"
      : "voice_mode") === "voice_mode"
  )
    chatBoxContainer.classList.remove("voice_mode"),
      chatBoxContainer.classList.add("text_mode"),
      chatBoxContainer.classList.add("showTranscript"),
      transcriptContainer.style.setProperty("display", "block"),
      avatar == null || avatar.muteInputAudio(),
      avatar == null || avatar.closeVoiceChat(),
      avatar &&
        micToggle &&
        (micIcon &&
          (micIcon.className =
            avatar != null && avatar.isInputAudioMuted
              ? "fa-solid fa-microphone-slash"
              : "fa-solid fa-microphone"),
        (micToggle.style.display = "block"));
  else {
    chatBoxContainer.classList.remove("text_mode"),
      chatBoxContainer.classList.add("voice_mode");
    try {
      await (avatar == null
        ? void 0
        : avatar.startVoiceChat({ isInputAudioMuted: !1 })),
        avatar == null || avatar.unmuteInputAudio(),
        avatar &&
          micToggle &&
          (micIcon &&
            (micIcon.className =
              avatar != null && avatar.isInputAudioMuted
                ? "fa-solid fa-microphone-slash"
                : "fa-solid fa-microphone"),
          (micToggle.style.display = "block"));
    } catch {
      setTimeout(function () {
        toggleInteractionMode(), avatarError && (avatarError.innerHTML = "");
      }, 1e3),
        avatarError &&
          (avatarError.innerHTML =
            '<span style="padding:10px; ">Voice mode isnt allowed now, so well switch to text mode instead! </span>');
    }
  }
}
function startCountDown(B = 300) {
  (countdownElement.style.display = "block"),
    B || (B = 300),
    countdownElement.classList.contains("session_ended") &&
      countdownElement.classList.remove("session_ended"),
    countdownElement.classList.contains("session_expired") &&
      countdownElement.classList.remove("session_expired");
  const U = new Map(),
    F = Date.now();
  notifications.forEach((q) => {
    const j = B - q.time;
    j >= 0 && U.set(j, q);
  }),
    (countdownTimer = setInterval(() => {
      const q = Date.now(),
        j = Math.floor((q - F) / 1e3),
        V = B - j;
      if (U.has(V)) {
        const K = U.get(V);
        console.log(" Notification Triggered:", {
          message: K.message,
          type: K.type,
          timeTriggered: V,
        }),
          showNotification(K.message, K.type, K.hideAfter),
          U.delete(V);
      }
      if (V <= 0) {
        (countdownElement.textContent = "Session expired!"),
          (countdownElement.style.color = "red"),
          countdownElement.classList.contains("session_ended") &&
            countdownElement.classList.remove("session_ended"),
          countdownElement.classList.contains("session_expired") ||
            countdownElement.classList.add("session_expired"),
          countdownTimer !== null &&
            (clearInterval(countdownTimer), (countdownTimer = null)),
          terminateAvatarSession();
        return;
      }
      if (questionnaires.length) {
        let K = questionnaires[0],
          G = isNaN(parseInt(K == null ? void 0 : K.renderOn))
            ? 600
            : parseInt(K == null ? void 0 : K.renderOn);
        j >= G && answerSubmit && getAvatarQuestionnaire(K.id);
      }
      const $ = Math.floor(V / 60),
        W = V % 60;
      countdownElement.textContent = `${$}:${W.toString().padStart(2, "0")}`;
    }, 1e3));
}
startButton && startButton.addEventListener("click", initializeAvatarSession);
endButton && endButton.addEventListener("click", terminateAvatarSession);
interruptTask && interruptTask.addEventListener("click", handleInterrupt);
micToggle && micToggle.addEventListener("click", handleMuteAudio);
speakButton && speakButton.addEventListener("click", handleSpeak);
switchInteractionMode &&
  !chatOnly &&
  switchInteractionMode.addEventListener("click", toggleInteractionMode);
overlayQuestionSubmitButton &&
  overlayQuestionSubmitButton.addEventListener("click", overlayQuestionSubmit);
closeOverlayQuestionButton &&
  closeOverlayQuestionButton.addEventListener("click", closeOverlayQuestion);
userInput &&
  userInput.addEventListener("keydown", function (B) {
    B.key === "Enter" && handleSpeak();
  });
chatBoxClose && chatBoxClose.addEventListener("click", terminateAvatarSession);
function escapeHtmlAttribute(B) {
  return B.replace(/&/g, "&amp;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}
function showNotification(B, U = "info", F = 5) {
  const q = document.getElementById("notification-container"),
    j = document.createElement("div");
  (j.className = `notification ${U}`),
    (j.innerHTML = `<span>${B}</span>`),
    q.appendChild(j),
    setTimeout(() => j.classList.add("show"), 50),
    setTimeout(
      () => hideNotification(j),
      Number.isFinite(Number(F)) ? Number(F) * 1e3 : 5e3
    );
  const V = j == null ? void 0 : j.querySelector(".close-btn");
  V && V.addEventListener("click", () => hideNotification(j));
}
function hideNotification(B) {
  B.classList.remove("show"), setTimeout(() => B.remove(), 400);
}
const getAnswerPromptStudio = async (B) => {
    var U;
    if (!(!B || !B.trim()))
      try {
        const q = await (
          await fetch(ajaxurl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
              query: B,
              language,
              action: "askQuestion",
              sessionID: sessionId,
              nonce: avatar_studio_nonce,
              avatarID: avatarStudioIdElem
                ? String(avatarStudioIdElem.value)
                : "0",
            }),
          })
        ).json();
        return (
          ((U = q == null ? void 0 : q.data) == null ? void 0 : U.response) ||
          ""
        );
      } catch (F) {
        return console.error("Error:", F), "";
      }
  },
  handleStartDeepgram = async (B, U = deepgramToken) => {
    try {
      if (!U) {
        console.error("No token received from backend");
        return;
      }
      if (typeof U != "string" || U.length === 0) {
        console.error("Invalid token format or empty token");
        return;
      }
      let F = "",
        q = "",
        j = "",
        V = null;
      const W = createClient({ accessToken: U }).listen.live({
        model: "nova-3",
        interim_results: !0,
        language: "multi",
        endpointing: 1500,
        utterance_end_ms: 1500,
        punctuate: !0,
        smart_format: !0,
      });
      (deepgramConnection = W),
        W.on(LiveTranscriptionEvents.Open, () => {
          console.log(" Deepgram connected successfully"),
            updateMicIcon(),
            navigator.mediaDevices
              .getUserMedia({ audio: !0 })
              .then((K) => {
                (mediaRecorder = new MediaRecorder(K)),
                  mediaRecorder.addEventListener("dataavailable", (G) => {
                    var H;
                    ((H =
                      deepgramConnection == null
                        ? void 0
                        : deepgramConnection.getReadyState) == null
                      ? void 0
                      : H.call(deepgramConnection)) === 1 &&
                      deepgramConnection.send(G.data);
                  }),
                  mediaRecorder.start(250),
                  console.log(" Recording started");
              })
              .catch((K) => {
                console.error(" getUserMedia error:", K),
                  K.name === "NotAllowedError"
                    ? console.error("Microphone permission denied")
                    : K.name === "NotFoundError" &&
                      console.error("No microphone device found");
              }),
            keepAliveInterval && clearInterval(keepAliveInterval),
            (keepAliveInterval = setInterval(() => {
              var K;
              try {
                ((K =
                  deepgramConnection == null
                    ? void 0
                    : deepgramConnection.getReadyState) == null
                  ? void 0
                  : K.call(deepgramConnection)) === 1 &&
                  (deepgramConnection.send(
                    JSON.stringify({ type: "KeepAlive" })
                  ),
                  console.log(" Keep-alive sent to Deepgram"));
              } catch (G) {
                console.error(" Error sending keep-alive:", G);
              }
            }, 3e3));
        }),
        W.on(LiveTranscriptionEvents.Transcript, async (K) => {
          var G, H;
          try {
            if (isDeepgramMuted) {
              console.log(" Skipping transcript processing - mic is muted");
              return;
            }
            const z = (G = K.channel.alternatives) == null ? void 0 : G[0];
            if (!z || z.confidence < 0.8) {
              console.log(" Low confidence transcript, skipping");
              return;
            }
            let Y = (H = z.transcript) == null ? void 0 : H.trim();
            const X = K.is_final;
            if (!Y) return;
            if (!X) {
              console.log(" User speaking (interim):", Y),
                (userTalkingText += ` ${Y}`),
                handleInterrupt();
              return;
            }
            if (X) {
              const Z = Y;
              (Y = ""),
                console.log(" Final transcript:", Y),
                addTextToTranscript(Z, "user", !1);
              let se = userTalkingText.trim();
              console.log("USER_END_MESSAGE (via Deepgram)", se),
                (userTalkingText = "");
              const ee = await getAnswerPromptStudio(Z);
              B && ee
                ? (console.log(" Avatar speaking:", ee),
                  createParagraphElement("avatar"),
                  await B.speak({ text: ee, task_type: TaskType.REPEAT }),
                  addTextToTranscript(ee, "avatar", !1),
                  console.log("AVATAR_END_MESSAGE (via Deepgram)", ee))
                : console.warn(" No avatar instance or empty answer");
            }
          } catch (Q) {
            console.error("Error processing transcript:", Q);
          }
        }),
        W.on(LiveTranscriptionEvents.UtteranceEnd, () => {
          console.log(" Natural speech pause detected"),
            V && clearTimeout(V),
            (V = setTimeout(() => {
              console.log(" Finalizing speech input"), (V = null);
            }, 500));
        }),
        W.on(LiveTranscriptionEvents.Error, (K) => {
          var G, H;
          console.error(" Deepgram error:", {
            message: K.message,
            statusCode: K.statusCode,
            requestId: K.requestId,
            url: K.url,
          }),
            K.statusCode === 401 ||
            ((G = K.message) != null && G.includes("401"))
              ? console.error(
                  " Authentication failed - token may be invalid or expired"
                )
              : K.statusCode === 403
              ? console.error(
                  " Permission denied - check Deepgram API key scopes"
                )
              : (H = K.message) != null &&
                H.includes("WebSocket") &&
                console.error(
                  " WebSocket connection failed - check network and token"
                );
        }),
        W.on(LiveTranscriptionEvents.Close, () => {
          console.log(" Deepgram connection closed"),
            keepAliveInterval &&
              (clearInterval(keepAliveInterval),
              (keepAliveInterval = null),
              console.log(" Keep-alive stopped")),
            mediaRecorder &&
              mediaRecorder.state === "recording" &&
              (mediaRecorder.stop(), console.log(" Recording stopped")),
            (deepgramConnection = null);
        });
    } catch (F) {
      console.error(" Failed to initialize Deepgram:", F),
        console.error(
          "Please check your Deepgram API key and network connection"
        );
    }
  };
function cleanupDeepgram() {
  if (
    (console.log(" Cleaning up Deepgram resources"),
    keepAliveInterval &&
      (clearInterval(keepAliveInterval),
      (keepAliveInterval = null),
      console.log(" Keep-alive stopped")),
    mediaRecorder &&
      (mediaRecorder.state === "recording" &&
        (mediaRecorder.stop(), console.log(" Recording stopped")),
      mediaRecorder.stream &&
        mediaRecorder.stream.getTracks().forEach((B) => {
          B.stop(), console.log(" Microphone track stopped");
        }),
      (mediaRecorder = null)),
    deepgramConnection)
  ) {
    try {
      deepgramConnection.finish(), console.log(" Deepgram connection closed");
    } catch (B) {
      console.error("Error closing Deepgram connection:", B);
    }
    deepgramConnection = null;
  }
  (isDeepgramMuted = !1),
    micToggle && (micToggle.style.display = "none"),
    micIcon && (micIcon.className = "fa-solid fa-microphone");
}
function muteDeepgram() {
  mediaRecorder &&
    mediaRecorder.state === "recording" &&
    (mediaRecorder.pause(),
    (isDeepgramMuted = !0),
    console.log(" Deepgram muted - stopped recording"),
    updateMicIcon());
}
function unmuteDeepgram() {
  mediaRecorder &&
    mediaRecorder.state === "paused" &&
    (mediaRecorder.resume(),
    (isDeepgramMuted = !1),
    console.log(" Deepgram unmuted - resumed recording"),
    updateMicIcon());
}
function toggleDeepgramMute() {
  isDeepgramMuted ? unmuteDeepgram() : muteDeepgram();
}
function updateMicIcon() {
  micIcon &&
    (isDeepgramMuted
      ? (micIcon.className = "fa-solid fa-microphone-slash")
      : (micIcon.className = "fa-solid fa-microphone"));
}
export { getDefaultExportFromCjs as g };
